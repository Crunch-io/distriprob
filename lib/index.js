"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright Zachary Martin 2016.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var cache_1 = require("./impls/cache");
var cache = new cache_1.Cache();
var betaDist_1 = require("./impls/betaDist");
var binomialDist_1 = require("./impls/binomialDist");
var chiSquaredDist_1 = require("./impls/chiSquaredDist");
var exponentialDist_1 = require("./impls/exponentialDist");
var fDist_1 = require("./impls/fDist");
var gammaDist_1 = require("./impls/gammaDist");
var hypergeometricDist_1 = require("./impls/hypergeometricDist");
var normalDist_1 = require("./impls/normalDist");
var poissonDist_1 = require("./impls/poissonDist");
var studentsTDist_1 = require("./impls/studentsTDist");
var uniformDist_1 = require("./impls/uniformDist");
var airy_1 = require("./impls/boostPorts/special_functions/airy");
var bessel_1 = require("./impls/boostPorts/special_functions/bessel");
var bessel_prime_1 = require("./impls/boostPorts/special_functions/bessel_prime");
var beta_1 = require("./impls/boostPorts/special_functions/beta");
var ibeta_inverse_1 = require("./impls/boostPorts/special_functions/detail/ibeta_inverse");
var ibeta_inv_ab_1 = require("./impls/boostPorts/special_functions/detail/ibeta_inv_ab");
var factorial_1 = require("./impls/boostPorts/special_functions/factorial");
var gamma_1 = require("./impls/boostPorts/special_functions/gamma");
var gamma_inva_1 = require("./impls/boostPorts/special_functions/detail/gamma_inva");
var igamma_inverse_1 = require("./impls/boostPorts/special_functions/detail/igamma_inverse");
var owens_t_1 = require("./impls/boostPorts/special_functions/owens_t");
var polygamma_1 = require("./impls/boostPorts/special_functions/polygamma");
var zeta_1 = require("./impls/boostPorts/special_functions/zeta");
var erf_1 = require("./impls/boostPorts/special_functions/erf");
var erf_inv_1 = require("./impls/boostPorts/special_functions/detail/erf_inv");
var Laborer_1 = require("./impls/Laborer");
var hypergeometricDist = new hypergeometricDist_1.HypergeometricDist(cache);
exports.airy = {
    ai: function (x) {
        return airy_1.Airy.airy_ai(x);
    },
    aiPrime: function (x) {
        return airy_1.Airy.airy_ai_prime(x);
    },
    aiRoot: function (m) {
        return airy_1.Airy.airy_ai_zero(m);
    },
    aiRootIter: function (startIndex, numRoots) {
        if (startIndex === void 0) { startIndex = 1; }
        return airy_1.Airy.airy_ai_zeros_iter(startIndex, numRoots);
    },
    bi: function (x) {
        return airy_1.Airy.airy_bi(x);
    },
    biPrime: function (x) {
        return airy_1.Airy.airy_bi_prime(x);
    },
    biRoot: function (m) {
        return airy_1.Airy.airy_bi_zero(m);
    },
    biRootIter: function (startIndex, numRoots) {
        if (startIndex === void 0) { startIndex = 1; }
        return airy_1.Airy.airy_bi_zeros_iter(startIndex, numRoots);
    },
};
exports.bessel = {
    i: function (v, x) {
        return bessel_1.Bessel.cyl_bessel_i(v, x);
    },
    iPrime: function (v, x) {
        return bessel_prime_1.BoostBesselPrime.cyl_bessel_i_prime(v, x);
    },
    j: function (v, x) {
        return bessel_1.Bessel.cyl_bessel_j(v, x);
    },
    jPrime: function (v, x) {
        return bessel_prime_1.BoostBesselPrime.cyl_bessel_j_prime(v, x);
    },
    jRoot: function (v, m) {
        return bessel_1.Bessel.cyl_bessel_j_zero(v, m);
    },
    jRootIter: function (v, startIndex, numRoots) {
        if (startIndex === void 0) { startIndex = 1; }
        return bessel_1.Bessel.cyl_bessel_j_zeros_iter(v, startIndex, numRoots);
    },
    k: function (v, x) {
        return bessel_1.Bessel.cyl_bessel_k(v, x);
    },
    kPrime: function (v, x) {
        return bessel_prime_1.BoostBesselPrime.cyl_bessel_k_prime(v, x);
    },
    y: function (v, x) {
        return bessel_1.Bessel.cyl_neumann(v, x);
    },
    yPrime: function (v, x) {
        return bessel_prime_1.BoostBesselPrime.cyl_neumann_prime(v, x);
    },
    yRoot: function (v, m) {
        return bessel_1.Bessel.cyl_neumann_zero(v, m);
    },
    yRootIter: function (v, startIndex, numRoots) {
        if (startIndex === void 0) { startIndex = 1; }
        return bessel_1.Bessel.cyl_neumann_zeros_iter(v, startIndex, numRoots);
    },
    sphJ: function (v, x) {
        return bessel_1.Bessel.sph_bessel(v, x);
    },
    sphJPrime: function (v, x) {
        return bessel_prime_1.BoostBesselPrime.sph_bessel_j_prime(v, x);
    },
    sphY: function (v, x) {
        return bessel_1.Bessel.sph_neumann(v, x);
    },
    sphYPrime: function (v, x) {
        return bessel_prime_1.BoostBesselPrime.sph_neumann_prime(v, x);
    }
};
exports.beta = {
    "function": function (a, b) {
        return beta_1.Beta.beta(a, b);
    },
    incomplete: function (a, b, x, lower, regularized) {
        if (lower === void 0) { lower = true; }
        if (regularized === void 0) { regularized = true; }
        if (regularized) {
            if (lower) {
                return beta_1.Beta.ibeta(a, b, x);
            }
            else {
                return beta_1.Beta.ibetac(a, b, x);
            }
        }
        else {
            if (lower) {
                return beta_1.Beta.beta(a, b, x);
            }
            else {
                return beta_1.Beta.betac(a, b, x);
            }
        }
    },
    incompleteInverse: function (a, b, p, lower) {
        if (lower === void 0) { lower = true; }
        if (lower) {
            return ibeta_inverse_1.IBetaInverse.ibeta_inv(a, b, p).result;
        }
        else {
            return ibeta_inverse_1.IBetaInverse.ibetac_inv(a, b, p).result;
        }
    },
    incompleteInverseParameter: function (otherParamVal, x, p, parameterToFind, lower) {
        if (parameterToFind === void 0) { parameterToFind = "A"; }
        if (lower === void 0) { lower = true; }
        if (parameterToFind === "A") {
            if (lower) {
                return ibeta_inv_ab_1.IBetaInvAB.ibeta_inva(otherParamVal, x, p);
            }
            else {
                return ibeta_inv_ab_1.IBetaInvAB.ibetac_inva(otherParamVal, x, p);
            }
        }
        else if (parameterToFind === "B") {
            if (lower) {
                return ibeta_inv_ab_1.IBetaInvAB.ibeta_invb(otherParamVal, x, p);
            }
            else {
                return ibeta_inv_ab_1.IBetaInvAB.ibetac_invb(otherParamVal, x, p);
            }
        }
        else {
            throw Error("The argument parameterToFind must be \"A\" or \"B\", got: " + parameterToFind);
        }
    },
    incompleteDerivative: function (a, b, x) {
        return beta_1.Beta.ibeta_derivative(a, b, x);
    },
    pdf: function (x, alpha, beta, ncp) {
        if (ncp === void 0) { ncp = 0; }
        return betaDist_1.BetaDist.pdf(x, alpha, beta, ncp);
    },
    cdf: function (x, alpha, beta, lowerTail, ncp) {
        if (lowerTail === void 0) { lowerTail = true; }
        if (ncp === void 0) { ncp = 0; }
        return betaDist_1.BetaDist.cdf(x, alpha, beta, lowerTail, ncp);
    },
    quantile: function (x, alpha, beta, lowerTail, ncp) {
        if (lowerTail === void 0) { lowerTail = true; }
        if (ncp === void 0) { ncp = 0; }
        return betaDist_1.BetaDist.quantile(x, alpha, beta, lowerTail, ncp);
    },
    random: function (n, alpha, beta, ncp, seed) {
        if (ncp === void 0) { ncp = 0; }
        return betaDist_1.BetaDist.random(n, alpha, beta, ncp, seed);
    }
};
exports.binomial = {
    coefficient: function (n, k) {
        return beta_1.Beta.binomial_coefficient(n, k);
    },
    pdf: function (k, trials, probSuccess) {
        return binomialDist_1.BinomialDist.pdf(k, trials, probSuccess);
    },
    cdf: function (k, trials, probSuccess, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return binomialDist_1.BinomialDist.cdf(k, trials, probSuccess, lowerTail);
    },
    quantile: function (p, trials, probSuccess, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return binomialDist_1.BinomialDist.quantile(p, trials, probSuccess, lowerTail);
    },
    random: function (n, trials, probSuccess, seed) {
        return binomialDist_1.BinomialDist.random(n, trials, probSuccess, seed);
    }
};
exports.chi2 = {
    pdf: function (x, degreesOfFreedom, ncp) {
        if (ncp === void 0) { ncp = 0; }
        return chiSquaredDist_1.ChiSquaredDist.pdf(x, degreesOfFreedom, ncp);
    },
    cdf: function (x, degreesOfFreedom, lowerTail, ncp) {
        if (lowerTail === void 0) { lowerTail = true; }
        if (ncp === void 0) { ncp = 0; }
        return chiSquaredDist_1.ChiSquaredDist.cdf(x, degreesOfFreedom, lowerTail, ncp);
    },
    quantile: function (p, degreesOfFreedom, lowerTail, ncp) {
        if (lowerTail === void 0) { lowerTail = true; }
        if (ncp === void 0) { ncp = 0; }
        return chiSquaredDist_1.ChiSquaredDist.quantile(p, degreesOfFreedom, lowerTail, ncp);
    },
    random: function (n, degreesOfFreedom, ncp, seed) {
        if (ncp === void 0) { ncp = 0; }
        return chiSquaredDist_1.ChiSquaredDist.random(n, degreesOfFreedom, ncp, seed);
    }
};
exports.error = {
    "function": function (z, complement) {
        if (complement === void 0) { complement = false; }
        if (complement) {
            return erf_1.Erf.erfc(z);
        }
        else {
            return erf_1.Erf.erf(z);
        }
    },
    functionInverse: function (p, complement) {
        if (complement === void 0) { complement = false; }
        if (complement) {
            return erf_inv_1.ErfInv.erfc_inv(p);
        }
        else {
            return erf_inv_1.ErfInv.erf_inv(p);
        }
    }
};
exports.exponential = {
    pdf: function (x, lambda) {
        return exponentialDist_1.ExponentialDist.pdf(x, lambda);
    },
    cdf: function (x, lambda, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return exponentialDist_1.ExponentialDist.cdf(x, lambda, lowerTail);
    },
    quantile: function (p, lambda, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return exponentialDist_1.ExponentialDist.quantile(p, lambda, lowerTail);
    },
    random: function (n, lambda, seed) {
        return exponentialDist_1.ExponentialDist.random(n, lambda, seed);
    }
};
exports.F = {
    pdf: function (x, dof1, dof2, ncp) {
        if (ncp === void 0) { ncp = 0; }
        return fDist_1.FDist.pdf(x, dof1, dof2, ncp);
    },
    cdf: function (x, dof1, dof2, lowerTail, ncp) {
        if (lowerTail === void 0) { lowerTail = true; }
        if (ncp === void 0) { ncp = 0; }
        return fDist_1.FDist.cdf(x, dof1, dof2, lowerTail, ncp);
    },
    quantile: function (p, dof1, dof2, lowerTail, ncp) {
        if (lowerTail === void 0) { lowerTail = true; }
        if (ncp === void 0) { ncp = 0; }
        return fDist_1.FDist.quantile(p, dof1, dof2, lowerTail, ncp);
    },
    random: function (n, dof1, dof2, ncp, seed) {
        return fDist_1.FDist.random(n, dof1, dof2, ncp, seed);
    }
};
exports.factorial = {
    value: function (n) {
        return factorial_1.Factorial.factorial(n);
    },
    double: function (n) {
        return factorial_1.Factorial.double_factorial(n);
    },
    rising: function (x, n) {
        return factorial_1.Factorial.rising_factorial(x, n);
    },
    falling: function (x, n) {
        return factorial_1.Factorial.falling_factorial(x, n);
    }
};
exports.gamma = {
    "function": function (z) {
        return gamma_1.Gamma.tgamma(z);
    },
    function1pm1: function (dz) {
        return gamma_1.Gamma.tgamma1pm1(dz);
    },
    functionRatio: function (a, b) {
        return gamma_1.Gamma.tgamma_ratio(a, b);
    },
    functionDeltaRatio: function (a, delta) {
        return gamma_1.Gamma.tgamma_delta_ratio(a, delta);
    },
    functionLog: function (z) {
        return gamma_1.Gamma.lgamma(z).result;
    },
    di: function (z) {
        return polygamma_1.Polygamma.polygamma(0, z);
    },
    tri: function (z) {
        return polygamma_1.Polygamma.polygamma(1, z);
    },
    poly: function (n, z) {
        return polygamma_1.Polygamma.polygamma(n, z);
    },
    incomplete: function (a, z, lower, regularized) {
        if (lower === void 0) { lower = true; }
        if (regularized === void 0) { regularized = true; }
        if (regularized) {
            if (lower) {
                return gamma_1.Gamma.gamma_p(a, z);
            }
            else {
                return gamma_1.Gamma.gamma_q(a, z);
            }
        }
        else {
            if (lower) {
                return gamma_1.Gamma.tgamma_lower(a, z);
            }
            else {
                return gamma_1.Gamma.tgamma(a, z);
            }
        }
    },
    incompletePrime: function (a, z, lower, regularized) {
        if (lower === void 0) { lower = true; }
        if (regularized === void 0) { regularized = true; }
        return gamma_1.Gamma.igamma_derivative(a, z, lower, regularized);
    },
    incompleteInverse: function (a, p, lower) {
        if (lower === void 0) { lower = true; }
        if (lower) {
            return igamma_inverse_1.IGammaInverse.gamma_p_inv(a, p);
        }
        else {
            return igamma_inverse_1.IGammaInverse.gamma_q_inv(a, p);
        }
    },
    incompleteInverseParameter: function (z, p, lower) {
        if (lower === void 0) { lower = true; }
        if (lower) {
            return gamma_inva_1.GammaInvA.gamma_p_inva(z, p);
        }
        else {
            return gamma_inva_1.GammaInvA.gamma_q_inva(z, p);
        }
    },
    pdf: function (x, shape, scale) {
        return gammaDist_1.GammaDist.pdf(x, shape, scale);
    },
    cdf: function (x, shape, scale, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return gammaDist_1.GammaDist.cdf(x, shape, scale, lowerTail);
    },
    quantile: function (p, shape, scale, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return gammaDist_1.GammaDist.quantile(p, shape, scale, lowerTail);
    },
    random: function (n, shape, scale, seed) {
        return gammaDist_1.GammaDist.random(n, shape, scale, seed);
    }
};
exports.hypergeometric = {
    pdf: function (sampleSuccesses, draws, successPop, totalPop) {
        return hypergeometricDist.pdf(sampleSuccesses, draws, successPop, totalPop);
    },
    cdf: function (sampleSuccesses, draws, successPop, totalPop, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return hypergeometricDist.cdf(sampleSuccesses, draws, successPop, totalPop, lowerTail);
    },
    quantile: function (p, draws, successPop, totalPop, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return hypergeometricDist.quantile(p, draws, successPop, totalPop, lowerTail);
    },
    random: function (n, draws, successPop, totalPop, seed) {
        return hypergeometricDist.random(n, draws, successPop, totalPop, seed);
    }
};
exports.normal = {
    pdf: function (x, mu, sigma) {
        return normalDist_1.NormalDist.pdf(x, mu, sigma);
    },
    cdf: function (x, mu, sigma, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return normalDist_1.NormalDist.cdf(x, mu, sigma, lowerTail);
    },
    quantile: function (p, mu, sigma, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return normalDist_1.NormalDist.quantile(p, mu, sigma, lowerTail);
    },
    random: function (n, mu, sigma, seed) {
        return normalDist_1.NormalDist.random(n, mu, sigma, seed);
    },
};
exports.owensT = function (h, a) {
    return owens_t_1.OwensT.owens_t(h, a);
};
exports.poisson = {
    pdf: function (k, lambda) {
        return poissonDist_1.PoissonDist.pdf(k, lambda);
    },
    cdf: function (k, lambda, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return poissonDist_1.PoissonDist.cdf(k, lambda, lowerTail);
    },
    quantile: function (p, lambda, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return poissonDist_1.PoissonDist.quantile(p, lambda, lowerTail);
    },
    random: function (n, lambda, seed) {
        return poissonDist_1.PoissonDist.random(n, lambda, seed);
    }
};
exports.t = {
    pdf: function (x, degreesOfFreedom, ncp) {
        if (ncp === void 0) { ncp = 0; }
        return studentsTDist_1.StudentsTDist.pdf(x, degreesOfFreedom, ncp);
    },
    cdf: function (x, degreesOfFreedom, lowerTail, ncp) {
        if (lowerTail === void 0) { lowerTail = true; }
        if (ncp === void 0) { ncp = 0; }
        return studentsTDist_1.StudentsTDist.cdf(x, degreesOfFreedom, lowerTail, ncp);
    },
    quantile: function (p, degreesOfFreedom, lowerTail, ncp) {
        if (lowerTail === void 0) { lowerTail = true; }
        if (ncp === void 0) { ncp = 0; }
        return studentsTDist_1.StudentsTDist.quantile(p, degreesOfFreedom, lowerTail, ncp);
    },
    random: function (n, degreesOfFreedom, ncp, seed) {
        if (ncp === void 0) { ncp = 0; }
        return studentsTDist_1.StudentsTDist.random(n, degreesOfFreedom, ncp, seed);
    }
};
exports.uniform = {
    pdf: function (x, lowerSupportBound, upperSupportBound) {
        return uniformDist_1.UniformDist.pdf(x, lowerSupportBound, upperSupportBound);
    },
    cdf: function (x, lowerSupportBound, upperSupportBound, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return uniformDist_1.UniformDist.cdf(x, lowerSupportBound, upperSupportBound, lowerTail);
    },
    quantile: function (x, lowerSupportBound, upperSupportBound, lowerTail) {
        if (lowerTail === void 0) { lowerTail = true; }
        return uniformDist_1.UniformDist.quantile(x, lowerSupportBound, upperSupportBound, lowerTail);
    },
    random: function (n, lowerSupportBound, upperSupportBound, seed) {
        return uniformDist_1.UniformDist.random(n, lowerSupportBound, upperSupportBound, seed);
    }
};
exports.worker = function (config) {
    return new Laborer_1.Laborer();
};
exports.zeta = function (s) {
    return zeta_1.Zeta.zeta(s);
};
