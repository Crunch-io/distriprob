"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var Precision = require("./precision").Precision;
var Sign = require("../special_functions/sign").Sign;
var Toms748 = /** @class */ (function () {
    function Toms748() {
    }
    Toms748.eps_tolerance = function (bits) {
        var eps = 4 * Precision.epsilon();
        if (typeof bits === "number") {
            eps = Math.max(Math.pow(2, 1 - bits), eps);
        }
        return function (a, b) {
            return Math.abs(a - b) <= (eps * Math.min(Math.abs(a), Math.abs(b)));
        };
    };
    Toms748.equal_floor = function (a, b) {
        return Math.floor(a) === Math.floor(b);
    };
    Toms748.equal_ceil = function (a, b) {
        return Math.ceil(a) === Math.ceil(b);
    };
    Toms748.equal_nearest_integer = function (a, b) {
        return Math.floor(a + 0.5) === Math.floor(b + 0.5);
    };
    Toms748.bracket = function (f, c, fps) {
        //
        // Given a point c inside the existing enclosing interval
        // [a, b] sets a = c if f(c) == 0, otherwise finds the new
        // enclosing interval: either [a, c] or [c, b] and sets
        // d and fd to the point that has just been removed from
        // the interval.  In other words d is the third best guess
        // to the root.
        //
        var tol = Precision.epsilon() * 2;
        //
        // If the interval [a,b] is very small, or if c is too close
        // to one end of the interval then we need to adjust the
        // location of c accordingly:
        //
        if ((fps.b - fps.a) < 2 * tol * fps.a) {
            c = fps.a + (fps.b - fps.a) / 2;
        }
        else if (c <= fps.a + Math.abs(fps.a) * tol) {
            c = fps.a + Math.abs(fps.a) * tol;
        }
        else if (c >= fps.b - Math.abs(fps.b) * tol) {
            c = fps.b - Math.abs(fps.b) * tol;
        }
        //
        // OK, lets invoke f(c):
        //
        var fc = f(c);
        //
        // if we have a zero then we have an exact solution to the root:
        //
        if (fc === 0) {
            fps.a = c;
            fps.fa = 0;
            fps.d = 0;
            fps.fd = 0;
            return;
        }
        //
        // Non-zero fc, update the interval:
        //
        if (Sign.sign(fps.fa) * Sign.sign(fc) < 0) {
            fps.d = fps.b;
            fps.fd = fps.fb;
            fps.b = c;
            fps.fb = fc;
        }
        else {
            fps.d = fps.a;
            fps.fd = fps.fa;
            fps.a = c;
            fps.fa = fc;
        }
        return;
    };
    Toms748.safe_div = function (num, denom, r) {
        //
        // return num / denom without overflow,
        // return r if overflow would occur.
        //
        if (Math.abs(denom) < 1) {
            if (Math.abs(denom * Number.MAX_VALUE) <= Math.abs(num)) {
                return r;
            }
        }
        return num / denom;
    };
    Toms748.secant_interpolate = function (a, b, fa, fb) {
        //
        // Performs standard secant interpolation of [a,b] given
        // function evaluations f(a) and f(b).  Performs a bisection
        // if secant interpolation would leave us very close to either
        // a or b.  Rationale: we only call this function when at least
        // one other form of interpolation has already failed, so we know
        // that the function is unlikely to be smooth with a root very
        // close to a or b.
        //
        var tol = Precision.epsilon() * 5;
        var c = a - (fa / (fb - fa)) * (b - a);
        if ((c <= a + Math.abs(a) * tol) || (c >= b - Math.abs(b) * tol)) {
            return (a + b) / 2;
        }
        return c;
    };
    Toms748.quadratic_interpolate = function (a, b, d, fa, fb, fd, count) {
        //
        // Performs quadratic interpolation to determine the next point,
        // takes count Newton steps to find the location of the
        // quadratic polynomial.
        //
        // Point d must lie outside of the interval [a,b], it is the third
        // best approximation to the root, after a and b.
        //
        // Note: this does not guarentee to find a root
        // inside [a, b], so we fall back to a secant step should
        // the result be out of range.
        //
        // Start by obtaining the coefficients of the quadratic polynomial:
        //
        var B = Toms748.safe_div(fb - fa, b - a, Number.MAX_VALUE);
        var A = Toms748.safe_div(fd - fb, d - b, Number.MAX_VALUE);
        A = Toms748.safe_div(A - B, d - a, 0);
        if (A === 0) {
            // failure to determine coefficients, try a secant step:
            return Toms748.secant_interpolate(a, b, fa, fb);
        }
        //
        // Determine the starting point of the Newton steps:
        //
        var c;
        if (Sign.sign(A) * Sign.sign(fa) > 0) {
            c = a;
        }
        else {
            c = b;
        }
        //
        // Take the Newton steps:
        //
        for (var i = 1; i <= count; i++) {
            c -= Toms748.safe_div(fa + (B + A * (c - b)) * (c - a), B + A * (2 * c - a - b), 1 + c - a);
        }
        if ((c <= a) || (c >= b)) {
            // Oops, failure, try a secant step:
            c = Toms748.secant_interpolate(a, b, fa, fb);
        }
        return c;
    };
    Toms748.cubic_interpolate = function (a, b, d, e, fa, fb, fd, fe) {
        //
        // Uses inverse cubic interpolation of f(x) at points
        // [a,b,d,e] to obtain an approximate root of f(x).
        // Points d and e lie outside the interval [a,b]
        // and are the third and forth best approximations
        // to the root that we have found so far.
        //
        // Note: this does not guarentee to find a root
        // inside [a, b], so we fall back to quadratic
        // interpolation in case of an erroneous result.
        //
        var q11 = (d - e) * fd / (fe - fd);
        var q21 = (b - d) * fb / (fd - fb);
        var q31 = (a - b) * fa / (fb - fa);
        var d21 = (b - d) * fd / (fd - fb);
        var d31 = (a - b) * fb / (fb - fa);
        var q22 = (d21 - q11) * fb / (fe - fb);
        var q32 = (d31 - q21) * fa / (fd - fa);
        var d32 = (d31 - q21) * fd / (fd - fa);
        var q33 = (d32 - q22) * fa / (fe - fa);
        var c = q31 + q32 + q33 + a;
        if ((c <= a) || (c >= b)) {
            // Out of bounds step, fall back to quadratic interpolation:
            c = Toms748.quadratic_interpolate(a, b, d, fa, fb, fd, 3);
        }
        return c;
    };
    Toms748.toms748_solve = function (f, ax, bx, fax, fbx, tol, max_iter) {
        //
        // Main entry point and logic for Toms Algorithm 748
        // root finder.
        //
        var iterations;
        var count = max_iter;
        var fps = {
            a: ax,
            b: bx,
            fa: fax,
            fb: fbx,
            d: NaN,
            fd: NaN
        };
        var c, u, fu, a0, b0, e, fe;
        var mu = 0.5;
        // initialise a, b and fa, fb:
        if (fps.a >= fps.b) {
            throw new Error("Domain error: Parameters a and b out of order: a=" + fps.a + ", b=" + fps.b);
        }
        if (tol(fps.a, fps.b) || (fps.fa === 0) || (fps.fb === 0)) {
            if (fps.fa === 0) {
                fps.b = fps.a;
            }
            else if (fps.fb === 0) {
                fps.a = fps.b;
            }
            return { a: fps.a, b: fps.b, iterations: 0 };
        }
        if (Sign.sign(fps.fa) * Sign.sign(fps.fb) > 0) {
            throw new Error("Domain error: Parameters a and b do not bracket the root: a=" + fps.a + ", b=" + fps.b);
        }
        // dummy value for fd, e and fe:
        fe = e = fps.fd = 1e5;
        if (fps.fa !== 0) {
            //
            // On the first step we take a secant step:
            //
            c = Toms748.secant_interpolate(fps.a, fps.b, fps.fa, fps.fb);
            Toms748.bracket(f, c, fps);
            count--;
            if (count && (fps.fa !== 0) && !tol(fps.a, fps.b)) {
                //
                // On the second step we take a quadratic interpolation:
                //
                c = Toms748.quadratic_interpolate(fps.a, fps.b, fps.d, fps.fa, fps.fb, fps.fd, 2);
                e = fps.d;
                fe = fps.fd;
                Toms748.bracket(f, c, fps);
                count--;
            }
        }
        while (count && (fps.fa !== 0) && !tol(fps.a, fps.b)) {
            // save our brackets:
            a0 = fps.a;
            b0 = fps.b;
            //
            // Starting with the third step taken
            // we can use either quadratic or cubic interpolation.
            // Cubic interpolation requires that all four function values
            // fa, fb, fd, and fe are distinct, should that not be the case
            // then variable prof will get set to true, and we'll end up
            // taking a quadratic step instead.
            //
            var min_diff = Number.MIN_VALUE * 32;
            var prof = (Math.abs(fps.fa - fps.fb) < min_diff) ||
                (Math.abs(fps.fa - fps.fd) < min_diff) ||
                (Math.abs(fps.fa - fe) < min_diff) ||
                (Math.abs(fps.fb - fps.fd) < min_diff) ||
                (Math.abs(fps.fb - fe) < min_diff) ||
                (Math.abs(fps.fd - fe) < min_diff);
            if (prof) {
                // can't take cubic step
                c = Toms748.quadratic_interpolate(fps.a, fps.b, fps.d, fps.fa, fps.fb, fps.fd, 2);
            }
            else {
                c = Toms748.cubic_interpolate(fps.a, fps.b, fps.d, e, fps.fa, fps.fb, fps.fd, fe);
            }
            //
            // re-bracket, and check for termination:
            //
            e = fps.d;
            fe = fps.fd;
            Toms748.bracket(f, c, fps);
            if ((0 === --count) || (fps.fa === 0) || tol(fps.a, fps.b)) {
                break;
            }
            //
            // Now another interpolated step:
            //
            prof = (Math.abs(fps.fa - fps.fb) < min_diff) ||
                (Math.abs(fps.fa - fps.fd) < min_diff) ||
                (Math.abs(fps.fa - fe) < min_diff) ||
                (Math.abs(fps.fb - fps.fd) < min_diff) ||
                (Math.abs(fps.fb - fe) < min_diff) ||
                (Math.abs(fps.fd - fe) < min_diff);
            if (prof) {
                // can't take cubic step
                c = Toms748.quadratic_interpolate(fps.a, fps.b, fps.d, fps.fa, fps.fb, fps.fd, 3);
            }
            else {
                c = Toms748.cubic_interpolate(fps.a, fps.b, fps.d, e, fps.fa, fps.fb, fps.fd, fe);
            }
            //
            // Bracket again, and check termination condition, update e:
            //
            Toms748.bracket(f, c, fps);
            if ((0 === --count) || (fps.fa === 0) || tol(fps.a, fps.b)) {
                break;
            }
            //
            // Now we take a double-length secant step:
            //
            if (Math.abs(fps.fa) < Math.abs(fps.fb)) {
                u = fps.a;
                fu = fps.fa;
            }
            else {
                u = fps.b;
                fu = fps.fb;
            }
            c = u - 2 * (fu / (fps.fb - fps.fa)) * (fps.b - fps.a);
            if (Math.abs(c - u) > (fps.b - fps.a) / 2) {
                c = fps.a + (fps.b - fps.a) / 2;
            }
            //
            // Bracket again, and check termination condition:
            //
            e = fps.d;
            fe = fps.fd;
            Toms748.bracket(f, c, fps);
            if ((0 === --count) || (fps.fa === 0) || tol(fps.a, fps.b)) {
                break;
            }
            //
            // And finally... check to see if an additional bisection step is
            // to be taken, we do this if we're not converging fast enough:
            //
            if ((fps.b - fps.a) < mu * (b0 - a0)) {
                continue;
            }
            //
            // bracket again on a bisection:
            //
            e = fps.d;
            fe = fps.fd;
            Toms748.bracket(f, fps.a + (fps.b - fps.a) / 2, fps);
            count--;
        } // while loop
        iterations = max_iter - count;
        if (fps.fa === 0) {
            fps.b = fps.a;
        }
        else if (fps.fb === 0) {
            fps.a = fps.b;
        }
        return { a: fps.a, b: fps.b, iterations: iterations };
    };
    Toms748.bracket_and_solve_root = function (f, guess, factor, rising, tol, max_iter) {
        //
        // Set up inital brackets:
        //
        var a = guess;
        var b = a;
        var fa = f(a);
        var fb = fa;
        //
        // Set up invocation count:
        //
        var count = max_iter - 1;
        var step = 32;
        if ((fa < 0) == (guess < 0 ? !rising : rising)) {
            //
            // Zero is to the right of b, so walk upwards
            // until we find it:
            //
            while (Sign.sign(fb) === Sign.sign(fa)) {
                if (count === 0) {
                    throw new Error("Evaluation error: Unable to bracket root, last nearest" + "" + " value was " + b);
                }
                //
                // Heuristic: normally it's best not to increase the step sizes as we'll just end
                // up with a really wide range to search for the root.  However, if the initial
                // guess was *really* bad then we need to speed up the search otherwise we'll take
                // forever if we're orders of magnitude out.  This happens most often if the guess
                // is a small value (say 1) and the result we're looking for is close to
                // std::numeric_limits<T>::min().
                //
                if ((max_iter - count) % step === 0) {
                    factor *= 2;
                    if (step > 1) {
                        step /= 2;
                    }
                }
                //
                // Now go ahead and move our guess by "factor":
                //
                a = b;
                fa = fb;
                b *= factor;
                fb = f(b);
                count--;
            }
        }
        else {
            //
            // Zero is to the left of a, so walk downwards
            // until we find it:
            //
            while (Sign.sign(fb) === Sign.sign(fa)) {
                if (Math.abs(a) < Number.MIN_VALUE) {
                    // Escape route just in case the answer is zero!
                    max_iter -= count;
                    max_iter += 1;
                    return a > 0 ?
                        { a: 0, b: a, iterations: max_iter }
                        :
                            { a: a, b: 0, iterations: max_iter };
                }
                if (count === 0) {
                    throw new Error("Evaluation error: Unable to bracket root, last nearest" + "" + " value was " + a);
                }
                //
                // Heuristic: normally it's best not to increase the step sizes as we'll just end
                // up with a really wide range to search for the root.  However, if the initial
                // guess was *really* bad then we need to speed up the search otherwise we'll take
                // forever if we're orders of magnitude out.  This happens most often if the guess
                // is a small value (say 1) and the result we're looking for is close to
                // std::numeric_limits<T>::min().
                //
                if ((max_iter - count) % step === 0) {
                    factor *= 2;
                    if (step > 1)
                        step /= 2;
                }
                //
                // Now go ahead and move are guess by "factor":
                //
                b = a;
                fb = fa;
                a /= factor;
                fa = f(a);
                count--;
            }
        }
        max_iter -= count;
        max_iter += 1;
        var r = Toms748.toms748_solve(f, (a < 0 ? b : a), (a < 0 ? a : b), (a < 0 ? fb : fa), (a < 0 ? fa : fb), tol, count);
        r.iterations += max_iter;
        return r;
    };
    return Toms748;
}());
exports.Toms748 = Toms748;
