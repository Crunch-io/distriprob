"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var sign_1 = require("../special_functions/sign");
var Roots = /** @class */ (function () {
    function Roots() {
    }
    Roots.handle_zero_derivative = function (state) {
        if (state.last_f0 === 0) {
            // this must be the first iteration, pretend that we had a
            // previous one at either min or max:
            if (state.result === state.min) {
                state.guess = state.max;
            }
            else {
                state.guess = state.min;
            }
            state.last_f0 = state.f(state.guess).f0;
            state.delta = state.guess - state.result;
        }
        if (sign_1.Sign.sign(state.last_f0) * sign_1.Sign.sign(state.f0) < 0) {
            // we've crossed over so move in opposite direction to last step:
            if (state.delta < 0) {
                state.delta = (state.result - state.min) / 2;
            }
            else {
                state.delta = (state.result - state.max) / 2;
            }
        }
        else {
            // move in same direction as last step:
            if (state.delta < 0) {
                state.delta = (state.result - state.max) / 2;
            }
            else {
                state.delta = (state.result - state.min) / 2;
            }
        }
    };
    Roots.bisect = function (f, min, max, tol, max_iter) {
        var fmin = f(min);
        var fmax = f(max);
        if (fmin === 0) {
            return { a: min, b: min, iterations: 2 };
        }
        if (fmax === 0) {
            return { a: max, b: max, iterations: 2 };
        }
        //
        // Error checking:
        //
        if (min >= max) {
            throw new Error("Evaluation error: Arguments in wrong order in BoostRoots.bisect" + "" + " (first arg=" + min + ")");
        }
        if (fmin * fmax >= 0) {
            throw new Error("Evaluation error: No change of sign in BoostRoots.bisect," + "" + " either there is no root to find, or there are multiple roots in the interval" + "" + " (f(min) = " + fmin);
        }
        //
        // Three function invocations so far:
        //
        var count = max_iter;
        if (count < 3) {
            count = 0;
        }
        else {
            count -= 3;
        }
        while (count && (!tol(min, max))) {
            var mid = (min + max) / 2;
            var fmid = f(mid);
            if ((mid === max) || (mid === min)) {
                break;
            }
            if (fmid === 0) {
                min = max = mid;
                break;
            }
            else if (sign_1.Sign.sign(fmid) * sign_1.Sign.sign(fmin) < 0) {
                max = mid;
                fmax = fmid;
            }
            else {
                min = mid;
                fmin = fmid;
            }
            --count;
        }
        max_iter -= count;
        return { a: min, b: max, iterations: max_iter };
    };
    Roots.newton_raphson_iterate = function (f, guess, min, max, digits, max_iter) {
        var state = {
            f: f,
            last_f0: 0,
            f0: 0,
            delta: Number.MAX_VALUE,
            result: guess,
            guess: guess,
            min: min,
            max: max,
        };
        var f1;
        var factor = Math.pow(2, 1 - digits);
        var delta1 = Number.MAX_VALUE;
        var delta2 = Number.MAX_VALUE;
        var count = max_iter;
        var fResult;
        do {
            state.last_f0 = state.f0;
            delta2 = delta1;
            delta1 = state.delta;
            fResult = f(state.result);
            state.f0 = fResult.f0;
            f1 = fResult.f1;
            count--;
            if (0 === state.f0) {
                break;
            }
            if (f1 === 0) {
                Roots.handle_zero_derivative(state);
            }
            else {
                state.delta = state.f0 / f1;
            }
            if (Math.abs(state.delta * 2) > Math.abs(delta2)) {
                // last two steps haven't converged, try bisection:
                state.delta = (state.delta > 0) ? (state.result - min) / 2 : (state.result - max) / 2;
            }
            state.guess = state.result;
            state.result -= state.delta;
            if (state.result <= min) {
                state.delta = 0.5 * (state.guess - state.min);
                state.result = state.guess - state.delta;
                if ((state.result == min) || (state.result == max)) {
                    break;
                }
            }
            else if (state.result >= state.max) {
                state.delta = 0.5 * (state.guess - state.max);
                state.result = state.guess - state.delta;
                if ((state.result == min) || (state.result == max)) {
                    break;
                }
            }
            // update brackets:
            if (state.delta > 0) {
                state.max = state.guess;
            }
            else {
                state.min = state.guess;
            }
        } while (count && (Math.abs(state.result * factor) < Math.abs(state.delta)));
        max_iter -= count;
        return { result: state.result, iterations: max_iter };
    };
    Roots.halley_step = function (x, f0, f1, f2) {
        var denom = 2 * f0;
        var num = 2 * f1 - f0 * (f2 / f1);
        var delta;
        if ((Math.abs(num) < 1) && (Math.abs(denom) >= Math.abs(num) * Number.MAX_VALUE)) {
            // possible overflow, use Newton step:
            delta = f0 / f1;
        }
        else {
            delta = denom / num;
        }
        return delta;
    };
    Roots.second_order_root_finder = function (f, guess, min, max, digits, max_iter, step) {
        var state = {
            f: f,
            last_f0: 0,
            f0: 0,
            delta: Math.max(10000000 * guess, 10000000),
            result: guess,
            guess: guess,
            min: min,
            max: max
        };
        var f1, f2;
        var factor = Math.pow(2, 1 - digits);
        var delta1 = state.delta;
        var delta2 = state.delta;
        var out_of_bounds_sentry = false;
        var count = max_iter;
        var fResult;
        do {
            state.last_f0 = state.f0;
            delta2 = delta1;
            delta1 = state.delta;
            fResult = f(state.result);
            state.f0 = fResult.f0;
            f1 = fResult.f1;
            f2 = fResult.f2;
            count--;
            if (0 === state.f0) {
                break;
            }
            if (f1 === 0) {
                // Oops zero derivative!!!
                Roots.handle_zero_derivative(state);
            }
            else {
                if (f2 !== 0) {
                    state.delta = step(state.result, state.f0, f1, f2);
                    if (state.delta * f1 / state.f0 < 0) {
                        // Oh dear, we have a problem as Newton and Halley steps
                        // disagree about which way we should move.  Probably
                        // there is cancelation error in the calculation of the
                        // Halley step, or else the derivatives are so small
                        // that their values are basically trash.  We will move
                        // in the direction indicated by a Newton step, but
                        // by no more than twice the current guess value, otherwise
                        // we can jump way out of bounds if we're not careful.
                        // See https://svn.boost.org/trac/boost/ticket/8314.
                        state.delta = state.f0 / f1;
                        if (Math.abs(state.delta) > 2 * Math.abs(state.guess))
                            state.delta = (state.delta < 0 ? -1 : 1) * 2 * Math.abs(state.guess);
                    }
                }
                else {
                    state.delta = state.f0 / f1;
                }
            }
            var convergence = Math.abs(state.delta / delta2);
            if ((convergence > 0.8) && (convergence < 2)) {
                // last two steps haven't converged, try bisection:
                state.delta = (state.delta > 0) ?
                    (state.result - state.min) / 2 : (state.result - state.max) / 2;
                if (Math.abs(state.delta) > state.result) {
                    // protect against huge jumps!
                    state.delta = sign_1.Sign.sign(state.delta) * state.result;
                }
                // reset delta2 so that this branch will *not* be taken on the
                // next iteration:
                delta2 = state.delta * 3;
            }
            state.guess = state.result;
            state.result -= state.delta;
            // check for out of bounds step:
            if (state.result < state.min) {
                var diff = ((Math.abs(state.min) < 1) &&
                    (Math.abs(state.result) > 1) &&
                    (Number.MAX_VALUE / Math.abs(state.result) < Math.abs(state.min))) ?
                    1000 : state.result / state.min;
                if (Math.abs(diff) < 1) {
                    diff = 1 / diff;
                }
                if (!out_of_bounds_sentry && (diff > 0) && (diff < 3)) {
                    // Only a small out of bounds step, lets assume that the result
                    // is probably approximately at min:
                    state.delta = 0.99 * (state.guess - state.min);
                    state.result = state.guess - state.delta;
                    out_of_bounds_sentry = true; // only take this branch once!
                }
                else {
                    state.delta = (state.guess - state.min) / 2;
                    state.result = state.guess - state.delta;
                    if ((state.result === state.min) || (state.result === state.max)) {
                        break;
                    }
                }
            }
            else if (state.result > state.max) {
                var diff = ((Math.abs(state.max) < 1) &&
                    (Math.abs(state.result) > 1) &&
                    (Number.MAX_VALUE / Math.abs(state.result) < Math.abs(state.max))) ?
                    1000 : state.result / state.max;
                if (Math.abs(diff) < 1) {
                    diff = 1 / diff;
                }
                if (!out_of_bounds_sentry && (diff > 0) && (diff < 3)) {
                    // Only a small out of bounds step, lets assume that the result
                    // is probably approximately at min:
                    state.delta = 0.99 * (state.guess - state.max);
                    state.result = state.guess - state.delta;
                    out_of_bounds_sentry = true; // only take this branch once!
                }
                else {
                    state.delta = (state.guess - state.max) / 2;
                    state.result = guess - state.delta;
                    if ((state.result === state.min) || (state.result === state.max)) {
                        break;
                    }
                }
            }
            // update brackets:
            if (state.delta > 0) {
                state.max = state.guess;
            }
            else {
                state.min = state.guess;
            }
        } while (count && (Math.abs(state.result * factor) < Math.abs(state.delta)));
        max_iter -= count;
        return { result: state.result, iterations: max_iter };
    };
    Roots.halley_iterate = function (f, guess, min, max, digits, max_iter) {
        return Roots.second_order_root_finder(f, guess, min, max, digits, max_iter, Roots.halley_step);
    };
    return Roots;
}());
exports.Roots = Roots;
