"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright John Maddock 2008.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var NonCentralBeta = require("./non_central_beta").NonCentralBeta;
var Precision = require("../tools/precision").Precision;
var Gamma = require("../special_functions/gamma").Gamma;
var Constants = require("../tools/constants").Constants;
var Beta = require("../special_functions/beta").Beta;
var UncheckedFactorial = require("../special_functions/detail/unchecked_factorial").UncheckedFactorial;
var NormalDist = require("../../normalDist").NormalDist;
var Sign = require("../special_functions/sign").Sign;
var GenericQuantile = require("./detail/generic_quantile").GenericQuantile;
var Log1p = require("../special_functions/log1p").Log1p;
var NonCentralT = /** @class */ (function () {
    function NonCentralT() {
    }
    NonCentralT.non_central_t2_p = function (v, delta, x, y, init_val) {
        //
        // Variables come first:
        //
        var max_iter = 500000;
        var errtol = Precision.epsilon();
        var d2 = delta * delta / 2;
        //
        // k is the starting point for iteration, and is the
        // maximum of the poisson weighting term, we don't
        // ever allow k == 0 as this can lead to catastrophic
        // cancellation errors later (test case is v = 1621286869049072.3
        // delta = 0.16212868690490723, x = 0.86987415482475994).
        //
        var k = Math.trunc(d2);
        var pois;
        if (k === 0) {
            k = 1;
        }
        // Starting PoissonDist weight:
        pois = Gamma.gamma_p_derivative(k + 1, d2)
            * Gamma.tgamma_delta_ratio(k + 1, 0.5)
            * delta / Constants.SQRT2();
        if (pois === 0) {
            return init_val;
        }
        // Recurrance & starting beta terms:
        var betaObj = x < y ?
            Beta.ibeta_imp(k + 1, v / 2, x, false, true)
            :
                Beta.ibeta_imp(v / 2, k + 1, y, true, true);
        var xterm = betaObj.pderivative;
        var beta = betaObj.result;
        xterm *= y / (v / 2 + k);
        var poisf = pois, betaf = beta, xtermf = xterm;
        var sum = init_val;
        if ((xterm === 0) && (beta === 0)) {
            return init_val;
        }
        //
        // Backwards recursion first, this is the stable
        // direction for recursion:
        //
        var count = 0;
        var last_term = 0;
        for (var i = k; i >= 0; i--) {
            var term = beta * pois;
            sum += term;
            // Don't terminate on first term in case we "fixed" k above:
            if ((Math.abs(last_term) > Math.abs(term)) && Math.abs(term / sum) < errtol) {
                break;
            }
            last_term = term;
            pois *= (i + 0.5) / d2;
            beta += xterm;
            xterm *= (i) / (x * (v / 2 + i - 1));
            count++;
        }
        last_term = 0;
        for (var i = k + 1;; i++) {
            poisf *= d2 / (i + 0.5);
            xtermf *= (x * (v / 2 + i - 1)) / (i);
            betaf -= xtermf;
            var term = poisf * betaf;
            sum += term;
            if ((Math.abs(last_term) >= Math.abs(term)) && (Math.abs(term / sum) < errtol)) {
                break;
            }
            last_term = term;
            ++count;
            if (count > max_iter) {
                throw new Error("Evaluation error: Series did not converge, closest value was " + sum);
            }
        }
        return sum;
    };
    NonCentralT.non_central_t2_q = function (v, delta, x, y, init_val) {
        //
        // Variables come first:
        //
        var max_iter = 500000;
        var errtol = Precision.epsilon();
        var d2 = delta * delta / 2;
        //
        // k is the starting point for iteration, and is the
        // maximum of the poisson weighting term, we don't allow
        // k == 0 as this can cause catastrophic cancellation errors
        // (test case is v = 561908036470413.25, delta = 0.056190803647041321,
        // x = 1.6155232703966216):
        //
        var k = Math.trunc(d2);
        if (k === 0) {
            k = 1;
        }
        // Starting PoissonDist weight:
        var pois;
        if ((k < UncheckedFactorial.max_factorial()) &&
            (d2 < Precision.log_max_value()) &&
            (Math.log(d2) * k < Precision.log_max_value())) {
            //
            // For small k we can optimise this calculation by using
            // a simpler reduced formula:
            //
            pois = Math.exp(-d2);
            pois *= Math.pow(d2, k);
            pois /= Gamma.tgamma(k + 1 + 0.5);
            pois *= delta / Constants.SQRT2();
        }
        else {
            pois = Gamma.gamma_p_derivative(k + 1, d2)
                * Gamma.tgamma_delta_ratio(k + 1, 0.5)
                * delta / Constants.SQRT2();
        }
        if (pois === 0) {
            return init_val;
        }
        // Recurance term:
        var xterm;
        var beta;
        // Starting beta term:
        if (k !== 0) {
            var betaObj = x < y ?
                Beta.ibeta_imp(k + 1, v / 2, x, true, true)
                :
                    Beta.ibeta_imp(v / 2, k + 1, y, false, true);
            beta = betaObj.result;
            xterm = betaObj.pderivative;
            xterm *= y / (v / 2 + k);
        }
        else {
            beta = Math.pow(y, v / 2);
            xterm = beta;
        }
        var poisf = pois, betaf = beta, xtermf = xterm;
        var sum = init_val;
        if ((xterm === 0) && (beta === 0)) {
            return init_val;
        }
        //
        // Fused forward and backwards recursion:
        //
        var count = 0;
        var last_term = 0;
        for (var i = k + 1, j = k;; i++, j--) {
            poisf *= d2 / (i + 0.5);
            xtermf *= (x * (v / 2 + i - 1)) / (i);
            betaf += xtermf;
            var term = poisf * betaf;
            if (j >= 0) {
                term += beta * pois;
                pois *= (j + 0.5) / d2;
                beta -= xterm;
                xterm *= (j) / (x * (v / 2 + j - 1));
            }
            sum += term;
            // Don't terminate on first term in case we "fixed" the value of k above:
            if ((Math.abs(last_term) > Math.abs(term)) && Math.abs(term / sum) < errtol) {
                break;
            }
            last_term = term;
            if (count > max_iter) {
                throw new Error("Evaluation error: Series did not converge, closest value was " + sum);
            }
            count++;
        }
        return sum;
    };
    NonCentralT.central_t_cdf = function (v, t, invert) {
        var df = v;
        var lowerTail = !invert;
        if (!lowerTail) {
            return NonCentralT.central_t_cdf(df, -t, false);
        }
        if (t === 0) {
            return 0.5;
        }
        var normalLimit = 1 / Precision.epsilon();
        if (df > normalLimit) {
            return NormalDist.cdf(t, 0, 1, lowerTail);
        }
        else {
            var t2 = t * t;
            var probability = void 0;
            if (df > 2 * t2) {
                var z = t2 / (df + t2);
                probability = Beta.ibetac(0.5, df / 2, z) / 2;
            }
            else {
                var z = df / (df + t2);
                probability = Beta.ibeta(df / 2, 0.5, z) / 2;
            }
            return (t > 0 ? 1 - probability : probability);
        }
    };
    NonCentralT.non_central_t_cdf = function (v, delta, t, invert) {
        if (t === Number.POSITIVE_INFINITY) {
            return invert ? 0 : 1;
        }
        else if (t === Number.NEGATIVE_INFINITY) {
            return invert ? 1 : 0;
        }
        if (v === Number.POSITIVE_INFINITY) {
            // Infinite degrees of freedom, so use normal distribution located at delta.
            return NormalDist.cdf(t, delta, 1, !invert);
        }
        //
        // Otherwise, for t < 0 we have to use the reflection formula:
        if (t < 0) {
            t = -t;
            delta = -delta;
            invert = !invert;
        }
        if (Math.abs(delta / (4 * v)) < Precision.epsilon()) {
            // Approximate with a Student's T centred on delta,
            // the crossover point is based on eq 2.6 from
            // "A Comparison of Approximations To Percentiles of the
            // Noncentral t-Distribution".  H. Sahai and M. M. Ojeda,
            // Revista Investigacion Operacional Vol 21, No 2, 2000.
            // Original sources referenced in the above are:
            // "Some Approximations to the Percentage Points of the Noncentral
            // t-Distribution". C. van Eeden. International Statistical Review, 29, 4-31.
            // "Continuous Univariate Distributions".  N.L. Johnson, S. Kotz and
            // N. Balkrishnan. 1995. John Wiley and Sons New York.
            var result_1 = NonCentralT.central_t_cdf(v, t - delta, false);
            return invert ? 1 - result_1 : result_1;
        }
        //
        // x and y are the corresponding random
        // variables for the noncentral beta distribution,
        // with y = 1 - x:
        //
        var x = t * t / (v + t * t);
        var y = v / (v + t * t);
        var d2 = delta * delta;
        var a = 0.5;
        var b = v / 2;
        var c = a + b + d2 / 2;
        //
        // Crossover point for calculating p or q is the same
        // as for the noncentral beta:
        //
        var cross = 1 - (b / c) * (1 + d2 / (2 * c * c));
        var result;
        if (x < cross) {
            //
            // Calculate p:
            //
            if (x !== 0) {
                result = NonCentralBeta.non_central_beta_p(a, b, d2, x, y);
                result = NonCentralT.non_central_t2_p(v, delta, x, y, result);
                result /= 2;
            }
            else {
                result = 0;
            }
            result += NormalDist.cdf(-delta);
        }
        else {
            //
            // Calculate q:
            //
            invert = !invert;
            if (x !== 0) {
                result = NonCentralBeta.non_central_beta_q(a, b, d2, x, y);
                result = NonCentralT.non_central_t2_q(v, delta, x, y, result);
                result /= 2;
            }
            else {
                result = NormalDist.cdf(-delta, 0, 1, false);
            }
        }
        if (invert) {
            result = 1 - result;
        }
        return result;
    };
    NonCentralT.non_central_t_quantile_functor = function (v, delta, target, comp) {
        return function (x) {
            var cdfEval = NonCentralT.non_central_t_cdf(v, delta, x, comp);
            return comp ? target - cdfEval : cdfEval - target;
        };
    };
    NonCentralT.non_central_t_quantile = function (v, delta, p, q) {
        var guess = 0;
        if ((v === Number.POSITIVE_INFINITY) || (v > 1 / Precision.epsilon())) {
            // Infinite or very large degrees of freedom, so use normal distribution located at
            // delta.
            if (p < q) {
                return NormalDist.quantile(p, delta, 1, true);
            }
            else {
                return NormalDist.quantile(q, delta, 1, false);
            }
        }
        else if (v > 3) {
            // Use normal distribution to calculate guess.
            var mean = (v > 1 / Precision.epsilon()) ?
                delta
                :
                    delta * Math.sqrt(v / 2) * Gamma.tgamma_delta_ratio((v - 1) * 0.5, 0.5);
            var vari = (v > 1 / Precision.epsilon()) ?
                1
                :
                    (((delta * delta + 1) * v) / (v - 2) - mean * mean);
            if (p < q) {
                guess = NormalDist.quantile(p, mean, vari, true);
            }
            else {
                guess = NormalDist.quantile(q, mean, vari, false);
            }
        }
        //
        // We *must* get the sign of the initial guess correct,
        // or our root-finder will fail, so double check it now:
        //
        var pzero = NonCentralT.non_central_t_cdf(v, delta, 0, !(p < q));
        var s;
        if (p < q) {
            s = Sign.sign(p - pzero);
        }
        else {
            s = Sign.sign(pzero - q);
        }
        if (s !== Sign.sign(guess)) {
            guess = s;
        }
        var f = NonCentralT.non_central_t_quantile_functor(v, delta, (p < q ? p : q), (p >= q));
        var result = GenericQuantile.generic_quantile(f, (p < q ? p : q), guess, (p >= q), Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
        return result;
    };
    NonCentralT.non_central_t2_pdf = function (n, delta, x, y, init_val) {
        //
        // Variables come first:
        //
        var max_iter = 500;
        var errtol = Precision.epsilon();
        var d2 = delta * delta / 2;
        //
        // k is the starting point for iteration, and is the
        // maximum of the poisson weighting term:
        //
        var k = Math.trunc(d2);
        var pois, xterm;
        if (k === 0) {
            k = 1;
        }
        // Starting PoissonDist weight:
        pois = Gamma.gamma_p_derivative(k + 1, d2)
            * Gamma.tgamma_delta_ratio(k + 1, 0.5)
            * delta / Constants.SQRT2();
        // Starting beta term:
        xterm = x < y ?
            Beta.ibeta_derivative(k + 1, n / 2, x)
            :
                Beta.ibeta_derivative(n / 2, k + 1, y);
        var poisf = pois, xtermf = xterm;
        var sum = init_val;
        if ((pois === 0) || (xterm === 0)) {
            return init_val;
        }
        //
        // Backwards recursion first, this is the stable
        // direction for recursion:
        //
        var count = 0;
        for (var i = k; i >= 0; i--) {
            var term = xterm * pois;
            sum += term;
            if (((Math.abs(term / sum) < errtol) && (i !== k)) || (term === 0)) {
                break;
            }
            pois *= (i + 0.5) / d2;
            xterm *= (i) / (x * (n / 2 + i));
            count++;
            if (count > max_iter) {
                throw new Error("Evaluation error: Series did not converge, closest value was " + sum);
            }
        }
        for (var i = k + 1;; i++) {
            poisf *= d2 / (i + 0.5);
            xtermf *= (x * (n / 2 + i)) / (i);
            var term = poisf * xtermf;
            sum += term;
            if ((Math.abs(term / sum) < errtol) || (term === 0)) {
                break;
            }
            count++;
            if (count > max_iter) {
                throw new Error("Evaluation error: Series did not converge, closest value was " + sum);
            }
        }
        return sum;
    };
    NonCentralT.central_t_pdf = function (n, t) {
        var df = n;
        var x = t;
        var normalLimit = 1 / Precision.epsilon();
        var result;
        if (df > normalLimit) {
            result = NormalDist.pdf(x, 0, 1);
        }
        else {
            var basem1 = x * x / df;
            if (basem1 < 0.125) {
                result = Math.exp(-Log1p.log1p(basem1) * (1 + df) / 2);
            }
            else {
                result = Math.pow(1 / (1 + basem1), (df + 1) / 2);
            }
            result /= Math.sqrt(df) * Beta.beta(df / 2, 0.5);
        }
        return result;
    };
    NonCentralT.non_central_t_pdf = function (n, delta, t) {
        if (t === Number.POSITIVE_INFINITY || t === Number.NEGATIVE_INFINITY) {
            return 0;
        }
        if (n === Number.POSITIVE_INFINITY) {
            // Infinite degrees of freedom, so use normal distribution located at delta.
            return NormalDist.pdf(t, delta, 1);
        }
        //
        // Otherwise, for t < 0 we have to use the reflection formula:
        if (t < 0) {
            t = -t;
            delta = -delta;
        }
        if (t === 0) {
            //
            // Handle this as a special case, using the formula
            // from Weisstein, Eric W.
            // "Noncentral Student's t-Distribution."
            // From MathWorld--A Wolfram Web Resource.
            // http://mathworld.wolfram.com/NoncentralStudentst-Distribution.html
            //
            // The formula is simplified thanks to the relation
            // 1F1(a,b,0) = 1.
            //
            return Gamma.tgamma_delta_ratio(n / 2 + 0.5, 0.5)
                * Math.sqrt(n / Math.PI)
                * Math.exp(-delta * delta / 2) / 2;
        }
        if (Math.abs(delta / (4 * n)) < Precision.epsilon()) {
            // Approximate with a Student's T centred on delta,
            // the crossover point is based on eq 2.6 from
            // "A Comparison of Approximations To Percentiles of the
            // Noncentral t-Distribution".  H. Sahai and M. M. Ojeda,
            // Revista Investigacion Operacional Vol 21, No 2, 2000.
            // Original sources referenced in the above are:
            // "Some Approximations to the Percentage Points of the Noncentral
            // t-Distribution". C. van Eeden. International Statistical Review, 29, 4-31.
            // "Continuous Univariate Distributions".  N.L. Johnson, S. Kotz and
            // N. Balkrishnan. 1995. John Wiley and Sons New York.
            return NonCentralT.central_t_pdf(n, t - delta);
        }
        //
        // x and y are the corresponding random
        // variables for the noncentral beta distribution,
        // with y = 1 - x:
        //
        var x = t * t / (n + t * t);
        var y = n / (n + t * t);
        var a = 0.5;
        var b = n / 2;
        var d2 = delta * delta;
        //
        // Calculate pdf:
        //
        var dt = n * t / (n * n + 2 * n * t * t + t * t * t * t);
        var result = NonCentralBeta.non_central_beta_pdf(a, b, d2, x, y);
        var tol = Precision.epsilon() * result * 500;
        result = NonCentralT.non_central_t2_pdf(n, delta, x, y, result);
        if (result <= tol) {
            result = 0;
        }
        result *= dt;
        return result;
    };
    return NonCentralT;
}());
exports.NonCentralT = NonCentralT;
