"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright John Maddock 2007.
 * (C) Copyright Zachary Martin 2016 (port to JavaScript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var Precision = require("../../tools/precision").Precision;
var Toms748 = require("../../tools/toms748_solve").Toms748;
var Sign = require("../../special_functions/sign").Sign;
var InvDiscreteQuantile = /** @class */ (function () {
    function InvDiscreteQuantile() {
    }
    InvDiscreteQuantile.distribution_quantile_finder = function (simplifiedCDF, targetP, comp) {
        return function (x) {
            return comp ? targetP - simplifiedCDF(x, false) : simplifiedCDF(x, true) - targetP;
        };
    };
    /**
     * The purpose of adjust_bounds, is to toggle the last bit of the
     * range so that both ends round to the same integer, if possible.
     * If they do both round the same then we terminate the search
     * for the root *very* quickly when finding an integer result.
     * At the point that this function is called we know that "a" is
     * below the root and "b" above it, so this change can not result
     * in the root no longer being bracketed.
     */
    InvDiscreteQuantile.adjust_bounds = function (bounds, type) {
        if (type === "equal_floor" || type === "equal_nearest_integer") {
            bounds.b -= Precision.epsilon() * bounds.b;
        }
        if (type === "equal_ceil" || type === "equal_nearest_integer") {
            bounds.a += Precision.epsilon() * bounds.a;
        }
    };
    InvDiscreteQuantile.getTol = function (type) {
        switch (type) {
            case "equal_nearest_integer":
                return Toms748.equal_nearest_integer;
            case "equal_ceil":
                return Toms748.equal_ceil;
            case "equal_floor":
                return Toms748.equal_floor;
            case "real":
                return Toms748.eps_tolerance(53);
        }
    };
    /**
     * This is where all the work is done:
     */
    InvDiscreteQuantile.do_inverse_discrete_quantile = function (simplifiedCDF, p, comp, guess, multiplier, adder, tolType, max_iter, max_bound, min_bound) {
        var f = InvDiscreteQuantile.distribution_quantile_finder(simplifiedCDF, p, comp);
        var tol = InvDiscreteQuantile.getTol(tolType);
        if (guess > max_bound)
            guess = max_bound;
        if (guess < min_bound)
            guess = min_bound;
        var fa = f(guess);
        var count = max_iter - 1;
        var fb = fa;
        var bounds = {
            a: guess,
            b: 0
        };
        if (fa === 0) {
            return guess;
        }
        //
        // For small expected results, just use a linear search:
        //
        if (guess < 10) {
            bounds.b = bounds.a;
            while ((bounds.a < 10) && (fa * fb >= 0)) {
                if (fb <= 0) {
                    bounds.a = bounds.b;
                    bounds.b = bounds.a + 1;
                    if (bounds.b > max_bound) {
                        bounds.b = max_bound;
                    }
                    fb = f(bounds.b);
                    count--;
                    if (fb === 0) {
                        return bounds.b;
                    }
                    if (bounds.a == bounds.b) {
                        return bounds.b; // can't go any higher!
                    }
                }
                else {
                    bounds.b = bounds.a;
                    bounds.a = Math.max(bounds.b - 1, 0);
                    if (bounds.a < min_bound) {
                        bounds.a = min_bound;
                    }
                    fa = f(bounds.a);
                    count--;
                    if (fa === 0) {
                        return bounds.a;
                    }
                    if (bounds.a === bounds.b) {
                        return bounds.a; //  We can't go any lower than this!
                    }
                }
            }
        }
        else if (adder !== 0) {
            //
            // If we're looking for a large result, then bump "adder" up
            // by a bit to increase our chances of bracketing the root:
            //
            //adder = (std::max)(adder, 0.001f * guess);
            if (fa < 0) {
                bounds.b = bounds.a + adder;
                if (bounds.b > max_bound) {
                    bounds.b = max_bound;
                }
            }
            else {
                bounds.b = Math.max(bounds.a - adder, 0);
                if (bounds.b < min_bound) {
                    bounds.b = min_bound;
                }
            }
            fb = f(bounds.b);
            count--;
            if (fb === 0) {
                return bounds.b;
            }
            if (count && (fa * fb >= 0)) {
                //
                // We didn't bracket the root, try
                // once more:
                //
                bounds.a = bounds.b;
                fa = fb;
                if (fa < 0) {
                    bounds.b = bounds.a + adder;
                    if (bounds.b > max_bound) {
                        bounds.b = max_bound;
                    }
                }
                else {
                    bounds.b = Math.max(bounds.a - adder, 0);
                    if (bounds.b < min_bound) {
                        bounds.b = min_bound;
                    }
                }
                fb = f(bounds.b);
                count--;
            }
            if (bounds.a > bounds.b) {
                var temp1 = bounds.a;
                bounds.a = bounds.b;
                bounds.b = temp1;
                var temp2 = fa;
                fa = fb;
                fb = temp2;
            }
        }
        //
        // If the root hasn't been bracketed yet, try again
        // using the multiplier this time:
        //
        if (Sign.sign(fb) === Sign.sign(fa)) {
            if (fa < 0) {
                //
                // Zero is to the right of x2, so walk upwards
                // until we find it:
                //
                while ((Sign.sign(fb) === Sign.sign(fa)) && (bounds.a !== bounds.b)) {
                    if (count === 0) {
                        throw new Error("Evaluation error: Unable to bracket root, last nearest" + "" + " value was " + bounds.b);
                    }
                    bounds.a = bounds.b;
                    fa = fb;
                    bounds.b *= multiplier;
                    if (bounds.b > max_bound) {
                        bounds.b = max_bound;
                    }
                    fb = f(bounds.b);
                    count--;
                }
            }
            else {
                //
                // Zero is to the left of a, so walk downwards
                // until we find it:
                //
                while ((Sign.sign(fb) === Sign.sign(fa)) && (bounds.a !== bounds.b)) {
                    if (Math.abs(bounds.a) < Number.MIN_VALUE) {
                        // Escape route just in case the answer is zero!
                        max_iter -= count;
                        max_iter += 1;
                        return 0;
                    }
                    if (count === 0) {
                        throw new Error("Evaluation error: Unable to bracket root, last nearest" + "" + " value was " + bounds.a);
                    }
                    bounds.b = bounds.a;
                    fb = fa;
                    bounds.a /= multiplier;
                    if (bounds.a < min_bound) {
                        bounds.a = min_bound;
                    }
                    fa = f(bounds.a);
                    count--;
                }
            }
        }
        max_iter -= count;
        if (fa === 0) {
            return bounds.a;
        }
        if (fb === 0) {
            return bounds.b;
        }
        if (bounds.a === bounds.b) {
            return bounds.b; // Ran out of bounds trying to bracket - there is no answer!
        }
        //
        // Adjust bounds so that if we're looking for an integer
        // result, then both ends round the same way:
        //
        InvDiscreteQuantile.adjust_bounds(bounds, tolType);
        //
        // We don't want zero or denorm lower bounds:
        //
        if (bounds.a < Number.MIN_VALUE) {
            bounds.a = Number.MIN_VALUE;
        }
        //
        // Go ahead and find the root:
        //
        var r = Toms748.toms748_solve(f, bounds.a, bounds.b, fa, fb, tol, count);
        max_iter += r.iterations;
        return (r.a + r.b) / 2;
    };
    //Some special routine for rounding up and down:
    // We want to check and see if we are very close to an integer, and if so test to see if
    // that integer is an exact root of the cdf.  We do this because our root finder only
    // guarantees to find *a root*, and there can sometimes be many consecutive floating
    // point values which are all roots.  This is especially true if the target probability
    // is very close 1.
    InvDiscreteQuantile.round_to_floor = function (simplifiedCDF, result, p, c, max_bound, min_bound) {
        var cc = Math.ceil(result);
        var pp = cc <= max_bound ? c ? simplifiedCDF(cc, false) : simplifiedCDF(cc, true) : 1;
        if (pp === p) {
            result = cc;
        }
        else {
            result = Math.floor(result);
        }
        //
        // Now find the smallest integer <= result for which we get an exact root:
        //
        while (result !== 0) {
            cc = result - 1;
            if (cc < min_bound) {
                break;
            }
            pp = c ? simplifiedCDF(cc, false) : simplifiedCDF(cc, true);
            if (pp === p) {
                result = cc;
            }
            else if (c ? pp > p : pp < p) {
                break;
            }
            result -= 1;
        }
        return result;
    };
    InvDiscreteQuantile.round_to_ceil = function (simplifiedCDF, result, p, c, max_bound, min_bound) {
        var cc = Math.floor(result);
        var pp = cc >= min_bound ? c ? simplifiedCDF(cc, false) : simplifiedCDF(cc, true) : 0;
        if (pp === p) {
            result = cc;
        }
        else {
            result = Math.ceil(result);
        }
        //
        // Now find the largest integer >= result for which we get an exact root:
        //
        while (true) {
            cc = result + 1;
            if (cc > max_bound) {
                break;
            }
            pp = c ? simplifiedCDF(cc, false) : simplifiedCDF(cc, true);
            if (pp === p) {
                result = cc;
            }
            else if (c ? pp < p : pp > p) {
                break;
            }
            result += 1;
        }
        return result;
    };
    InvDiscreteQuantile.inverse_discrete_quantile = function (simplifiedPDF, simplifiedCDF, p, c, guess, multiplier, adder, round, max_iter, max_bound, min_bound) {
        if (round === "real" && p > 0.5) {
            p = 1 - p;
            c = !c;
        }
        var pp = c ? 1 - p : p;
        if (pp <= simplifiedPDF(0)) {
            return 0;
        }
        if (round === "up") {
            var result = InvDiscreteQuantile.do_inverse_discrete_quantile(simplifiedCDF, p, c, Math.ceil(guess), multiplier, adder, "equal_ceil", max_iter, max_bound, min_bound);
            return InvDiscreteQuantile.round_to_ceil(simplifiedCDF, result, p, c, max_bound, min_bound);
        }
        else if (round === "down") {
            var result = InvDiscreteQuantile.do_inverse_discrete_quantile(simplifiedCDF, p, c, (guess < 1 ? 1 : Math.floor(guess)), multiplier, adder, "equal_floor", max_iter, max_bound, min_bound);
            return InvDiscreteQuantile.round_to_floor(simplifiedCDF, result, p, c, max_bound, min_bound);
        }
        else if (round === "real") {
            return InvDiscreteQuantile.do_inverse_discrete_quantile(simplifiedCDF, p, c, guess, multiplier, adder, "real", max_iter, max_bound, min_bound);
        }
        else {
            throw new Error("Unrecognized rounding option: " + round);
        }
    };
    return InvDiscreteQuantile;
}());
exports.InvDiscreteQuantile = InvDiscreteQuantile;
