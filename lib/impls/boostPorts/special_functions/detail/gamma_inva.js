"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var Gamma = require("../gamma").Gamma;
var ErfInv = require("./erf_inv").ErfInv;
var Constants = require("../../tools/constants").Constants;
var Toms748 = require("../../tools/toms748_solve").Toms748;
var GammaInvA = /** @class */ (function () {
    function GammaInvA() {
    }
    GammaInvA.gamma_inva_t = function (z, p, invert) {
        return function (a) {
            return invert ? p - Gamma.gamma_q(a, z) : Gamma.gamma_p(a, z) - p;
        };
    };
    GammaInvA.inverse_poisson_cornish_fisher = function (lambda, p, q) {
        // mean:
        var m = lambda;
        // standard deviation:
        var sigma = Math.sqrt(lambda);
        // skewness
        var sk = 1 / sigma;
        // kurtosis:
        // T k = 1/lambda;
        // Get the inverse of a std normal distribution:
        var x = ErfInv.erfc_inv(p > q ? 2 * q : 2 * p) * Constants.SQRT2();
        // Set the sign:
        if (p < 0.5) {
            x = -x;
        }
        var x2 = x * x;
        // w is correction term due to skewness
        var w = x + sk * (x2 - 1) / 6;
        /*
         // Add on correction due to kurtosis.
         // Disabled for now, seems to make things worse?
         //
         if(lambda >= 10)
         w += k * x * (x2 - 3) / 24 + sk * sk * x * (2 * x2 - 5) / -36;
         */
        w = m + sigma * w;
        return w > Number.MIN_VALUE ? w : Number.MIN_VALUE;
    };
    GammaInvA.gamma_inva_imp = function (z, p, q) {
        //
        // Special cases first:
        //
        if (p === 0) {
            throw new Error("Overflow error");
        }
        if (q === 0) {
            return Number.MIN_VALUE;
        }
        //
        // Function object, this is the functor whose root
        // we have to solve:
        //
        var f = GammaInvA.gamma_inva_t(z, (p < q) ? p : q, (p < q) ? false : true);
        //
        // Tolerance: full precision.
        //
        var tol = Toms748.eps_tolerance(53);
        //
        // Now figure out a starting guess for what a may be,
        // we'll start out with a value that'll put p or q
        // right bang in the middle of their range, the functions
        // are quite sensitive so we should need too many steps
        // to bracket the root from there:
        //
        var guess;
        var factor = 8;
        if (z >= 1) {
            //
            // We can use the relationship between the incomplete
            // gamma function and the poisson distribution to
            // calculate an approximate inverse, for large z
            // this is actually pretty accurate, but it fails badly
            // when z is very small.  Also set our step-factor according
            // to how accurate we think the result is likely to be:
            //
            guess = 1 + GammaInvA.inverse_poisson_cornish_fisher(z, q, p);
            if (z > 5) {
                if (z > 1000) {
                    factor = 1.01;
                }
                else if (z > 50) {
                    factor = 1.1;
                }
                else if (guess > 10) {
                    factor = 1.25;
                }
                else {
                    factor = 2;
                }
                if (guess < 1.1) {
                    factor = 8;
                }
            }
        }
        else if (z > 0.5) {
            guess = z * 1.2;
        }
        else {
            guess = -0.4 / Math.log(z);
        }
        //
        // Max iterations permitted:
        //
        var max_iter = 500;
        //
        // Use our generic derivative-free root finding procedure.
        // We could use Newton steps here, taking the PDF of the
        // PoissonDist distribution as our derivative, but that's
        // even worse performance-wise than the generic method :-(
        //
        var r = Toms748.bracket_and_solve_root(f, guess, factor, false, tol, max_iter);
        if (r.iterations >= max_iter) {
            throw new Error("Evaluation error: Unable to locate the root within a reasonable" + "" + " number of iterations, closest approximation so far was " + r.a + "\"");
        }
        return (r.a + r.b) / 2;
    };
    GammaInvA.gamma_p_inva = function (x, p) {
        // TODO: This border handling doesn't seem to make sense
        if (p === 0) {
            throw new Error("Overflow error");
        }
        if (p === 1) {
            return Number.MIN_VALUE;
        }
        return GammaInvA.gamma_inva_imp(x, p, 1 - p);
    };
    GammaInvA.gamma_q_inva = function (x, q) {
        // TODO: This border handling doesn't seem to make sense
        if (q === 1) {
            throw new Error("Overflow error");
        }
        if (q === 0) {
            return Number.MIN_VALUE;
        }
        return GammaInvA.gamma_inva_imp(x, 1 - q, q);
    };
    return GammaInvA;
}());
exports.GammaInvA = GammaInvA;
