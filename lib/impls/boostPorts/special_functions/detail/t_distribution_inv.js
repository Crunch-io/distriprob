"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright John Maddock 2007.
 * (C) Copyright Paul A. Bristow 2007.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var ErfInv = require("./erf_inv").ErfInv;
var Constants = require("../../tools/constants").Constants;
var Expm1 = require("../expm1").Expm1;
var Gamma = require("../gamma").Gamma;
var Beta = require("../beta").Beta;
var Rational = require("../../tools/rational").Rational;
var IBetaInverse = require("./ibeta_inverse").IBetaInverse;
var InverseStudentsT = /** @class */ (function () {
    function InverseStudentsT() {
    }
    InverseStudentsT.inverse_students_t_hill = function (ndf, u) {
        var a, b, c, d, q, x, y;
        if (ndf > 1e20) {
            return -ErfInv.erfc_inv(2 * u) * Constants.SQRT2();
        }
        a = 1 / (ndf - 0.5);
        b = 48 / (a * a);
        c = ((20700 * a / b - 98) * a - 16) * a + 96.36;
        d = ((94.5 / (b + c) - 3) / b + 1) * Math.sqrt(a * Constants.HALFPI()) * ndf;
        y = Math.pow(d * 2 * u, 2 / ndf);
        if (y > (0.05 + a)) {
            //
            // Asymptotic inverse expansion about normal:
            //
            x = -ErfInv.erfc_inv(2 * u) * Constants.SQRT2();
            y = x * x;
            if (ndf < 5) {
                c += 0.3 * (ndf - 4.5) * (x + 0.6);
            }
            c += (((0.05 * d * x - 5) * x - 7) * x - 2) * x + b;
            y = (((((0.4 * y + 6.3) * y + 36) * y + 94.5) / c - y - 3) / b + 1) * x;
            y = Expm1.expm1(a * y * y);
        }
        else {
            y = ((1 / (((ndf + 6) / (ndf * y) - 0.089 * d - 0.822) *
                (ndf + 2) * 3) + 0.5 / (ndf + 4)) * y - 1) *
                (ndf + 1) / (ndf + 2) + 1 / y;
        }
        q = Math.sqrt(ndf * y);
        return -q;
    };
    /**
     *
     * Tail and body series are due to Shaw:
     *
     * www.mth.kcl.ac.uk/~shaww/web_page/papers/Tdistribution06.pdf
     *
     * Shaw, W.T., 2006, "Sampling Student's T distribution - use of
     * the inverse cumulative distribution function."
     * Journal of Computational Finance, Vol 9 Issue 4, pp 37-73, Summer 2006
     *
     */
    InverseStudentsT.inverse_students_t_tail_series = function (df, v) {
        // Tail series expansion, see section 6 of Shaw's paper.
        // w is calculated using Eq 60:
        var w = Gamma.tgamma_delta_ratio(df / 2, 0.5) * Math.sqrt(df * Math.PI) * v;
        // define some variables:
        var np2 = df + 2;
        var np4 = df + 4;
        var np6 = df + 6;
        //
        // Calculate the coefficients d(k), these depend only on the
        // number of degrees of freedom df, so at least in theory
        // we could tabulate these for fixed df, see p15 of Shaw:
        //
        var d = [1];
        d.push(-(df + 1) / (2 * np2));
        np2 *= (df + 2);
        d.push(-df * (df + 1) * (df + 3) / (8 * np2 * np4));
        np2 *= df + 2;
        d.push(-df * (df + 1) * (df + 5) * (((3 * df) + 7) * df - 2) / (48 * np2 * np4 * np6));
        np2 *= (df + 2);
        np4 *= (df + 4);
        d.push(-df * (df + 1) * (df + 7) *
            ((((((15 * df) + 154) * df + 465) * df + 286) * df - 336) * df + 64)
            / (384 * np2 * np4 * np6 * (df + 8)));
        np2 *= (df + 2);
        d.push(-df * (df + 1) * (df + 3) * (df + 9)
            * (((((((35 * df + 452) * df + 1573) * df + 600) * df - 2020) * df) + 928) * df - 128)
            / (1280 * np2 * np4 * np6 * (df + 8) * (df + 10)));
        np2 *= (df + 2);
        np4 *= (df + 4);
        np6 *= (df + 6);
        d.push(-df * (df + 1) * (df + 11)
            * ((((((((((((945 * df) + 31506) * df + 425858) * df + 2980236) * df + 11266745) *
                df + 20675018) * df + 7747124) * df - 22574632) * df - 8565600) * df + 18108416) *
                df - 7099392) * df + 884736)
            / (46080 * np2 * np4 * np6 * (df + 8) * (df + 10) * (df + 12)));
        //
        // Now bring everthing together to provide the result,
        // this is Eq 62 of Shaw:
        //
        var rn = Math.sqrt(df);
        var div = Math.pow(rn * w, 1 / df);
        var power = div * div;
        var result = Rational.evaluate_polynomial(d, power);
        result *= rn;
        result /= div;
        return -result;
    };
    InverseStudentsT.inverse_students_t_body_series = function (df, u) {
        //
        // Body series for small N:
        //
        // Start with Eq 56 of Shaw:
        //
        var v = Gamma.tgamma_delta_ratio(df / 2, 0.5) * Math.sqrt(df * Math.PI) * (u - 0.5);
        //
        // Workspace for the polynomial coefficients:
        //
        var c = [0, 1];
        //
        // Figure out what the coefficients are, note these depend
        // only on the degrees of freedom (Eq 57 of Shaw):
        //
        var iN = 1 / df;
        c.push(0.16666666666666666667 + 0.16666666666666666667 * iN);
        c.push((0.0083333333333333333333 * iN
            + 0.066666666666666666667) * iN
            + 0.058333333333333333333);
        c.push(((0.00019841269841269841270 * iN
            + 0.0017857142857142857143) * iN
            + 0.026785714285714285714) * iN
            + 0.025198412698412698413);
        c.push((((2.7557319223985890653e-6 * iN
            + 0.00037477954144620811287) * iN
            - 0.0011078042328042328042) * iN
            + 0.010559964726631393298) * iN
            + 0.012039792768959435626);
        c.push(((((2.5052108385441718775e-8 * iN
            - 0.000062705427288760622094) * iN
            + 0.00059458674042007375341) * iN
            - 0.0016095979637646304313) * iN
            + 0.0061039211560044893378) * iN
            + 0.0038370059724226390893);
        c.push((((((1.6059043836821614599e-10 * iN
            + 0.000015401265401265401265) * iN
            - 0.00016376804137220803887) * iN
            + 0.00069084207973096861986) * iN
            - 0.0012579159844784844785) * iN
            + 0.0010898206731540064873) * iN
            + 0.0032177478835464946576);
        c.push(((((((7.6471637318198164759e-13 * iN
            - 3.9851014346715404916e-6) * iN
            + 0.000049255746366361445727) * iN
            - 0.00024947258047043099953) * iN
            + 0.00064513046951456342991) * iN
            - 0.00076245135440323932387) * iN
            + 0.000033530976880017885309) * iN
            + 0.0017438262298340009980);
        c.push((((((((2.8114572543455207632e-15 * iN
            + 1.0914179173496789432e-6) * iN
            - 0.000015303004486655377567) * iN
            + 0.000090867107935219902229) * iN
            - 0.00029133414466938067350) * iN
            + 0.00051406605788341121363) * iN
            - 0.00036307660358786885787) * iN
            - 0.00031101086326318780412) * iN
            + 0.00096472747321388644237);
        c.push(((((((((8.2206352466243297170e-18 * iN
            - 3.1239569599829868045e-7) * iN
            + 4.8903045291975346210e-6) * iN
            - 0.000033202652391372058698) * iN
            + 0.00012645437628698076975) * iN
            - 0.00028690924218514613987) * iN
            + 0.00035764655430568632777) * iN
            - 0.00010230378073700412687) * iN
            - 0.00036942667800009661203) * iN
            + 0.00054229262813129686486);
        //
        // The result is then a polynomial in v (see Eq 56 of Shaw):
        //
        return Rational.evaluate_odd_polynomial(c, v);
    };
    InverseStudentsT.inverse_students_t = function (df, u, v) {
        //
        // df = number of degrees of freedom.
        // u = probablity.
        // v = 1 - u.
        // l = lanczos type to use.
        //
        var invert = false;
        var result = 0;
        var pexact = false;
        if (u > v) {
            // function is symmetric, invert it:
            var temp = u;
            u = v;
            v = temp;
            invert = true;
        }
        if ((Math.floor(df) === df) && (df === 1 || df === 2 || df === 4 || df === 6)) {
            //
            // we have integer degrees of freedom, try for the special
            // cases first:
            //
            var tolerance = Math.pow(2, (2 * 53) / 3);
            switch (Math.trunc(df)) {
                case 1:
                    //
                    // df = 1 is the same as the Cauchy distribution, see
                    // Shaw Eq 35:
                    //
                    if (u === 0.5) {
                        result = 0;
                    }
                    else {
                        result = -Math.cos(Math.PI * u) / Math.sin(Math.PI * u);
                    }
                    pexact = true;
                    break;
                case 2:
                    //
                    // df = 2 has an exact result, see Shaw Eq 36:
                    //
                    result = (2 * u - 1) / Math.sqrt(2 * u * v);
                    pexact = true;
                    break;
                case 4:
                    //
                    // df = 4 has an exact result, see Shaw Eq 38 & 39:
                    //
                    var alpha = 4 * u * v;
                    var root_alpha = Math.sqrt(alpha);
                    var r = 4 * Math.cos(Math.acos(root_alpha) / 3) / root_alpha;
                    var x = Math.sqrt(r - 4);
                    result = u - 0.5 < 0 ? -x : x;
                    pexact = true;
                    break;
                case 6:
                    //
                    // We get numeric overflow in this area:
                    //
                    if (u < 1e-150) {
                        return {
                            result: (invert ? -1 : 1) *
                                InverseStudentsT.inverse_students_t_hill(df, u),
                            pexact: pexact
                        };
                    }
                    //
                    // Newton-Raphson iteration of a polynomial case,
                    // choice of seed value is taken from Shaw's online
                    // supplement:
                    //
                    var a = 4 * (u - u * u); //1 - 4 * (u - 0.5f) * (u - 0.5f);
                    var b = Math.cbrt(a);
                    var c = 0.85498797333834849467655443627193;
                    var p = 6 * (1 + c * (1 / b - 1));
                    var p0 = void 0;
                    do {
                        var p2 = p * p;
                        var p4 = p2 * p2;
                        var p5 = p * p4;
                        p0 = p;
                        // next term is given by Eq 41:
                        p = 2 * (8 * a * p5 - 270 * p2 + 2187) / (5 * (4 * a * p4 - 216 * p - 243));
                    } while (Math.abs((p - p0) / p) > tolerance);
                    //
                    // Use Eq 45 to extract the result:
                    //
                    p = Math.sqrt(p - df);
                    result = (u - 0.5) < 0 ? -p : p;
                    break;
            }
        }
        else {
            if (df > 0x10000000) {
                result = -ErfInv.erfc_inv(2 * u) * Constants.SQRT2();
                if (df >= 1e20) {
                    pexact = true;
                }
            }
            else if (df < 3) {
                //
                // Use a roughly linear scheme to choose between Shaw's
                // tail series and body series:
                //
                var crossover = 0.2742 - df * 0.0242143;
                if (u > crossover) {
                    result = InverseStudentsT.inverse_students_t_body_series(df, u);
                }
                else {
                    result = InverseStudentsT.inverse_students_t_tail_series(df, u);
                }
            }
            else {
                //
                // Use Hill's method except in the exteme tails
                // where we use Shaw's tail series.
                // The crossover point is roughly exponential in -df:
                //
                var crossover = Math.pow(2, Math.round(df / -0.654));
                if (u > crossover) {
                    result = InverseStudentsT.inverse_students_t_hill(df, u);
                }
                else {
                    result = InverseStudentsT.inverse_students_t_tail_series(df, u);
                }
            }
        }
        return { result: invert ? -result : result, pexact: pexact };
    };
    InverseStudentsT.find_ibeta_inv_from_t_dist = function (a, p, q) {
        var u = p / 2;
        var v = 1 - u;
        var df = a * 2;
        var t = InverseStudentsT.inverse_students_t(df, u, v).result;
        var py = t * t / (df + t * t);
        return { result: df / (df + t * t), py: py };
    };
    InverseStudentsT.fast_students_t_quantile_mlp_false = function (df, p) {
        //
        // Need to use inverse incomplete beta to get
        // required precision so not so fast:
        //
        var probability = (p > 0.5) ? 1 - p : p;
        var t, x;
        var y = 0;
        var iBetaInverseEval = IBetaInverse.ibeta_inv(df / 2, 0.5, 2 * probability);
        x = iBetaInverseEval.result;
        y = iBetaInverseEval.py;
        if (df * y > Number.MAX_VALUE * x) {
            throw new Error("Overflow error");
        }
        else {
            t = Math.sqrt(df * y / x);
        }
        //
        // Figure out sign based on the size of p:
        //
        if (p < 0.5) {
            t = -t;
        }
        return t;
    };
    InverseStudentsT.fast_students_t_quantile = function (df, p) {
        var invert = false;
        if ((df < 2) && (Math.floor(df) !== df)) {
            return InverseStudentsT.fast_students_t_quantile_mlp_false(df, p);
        }
        if (p > 0.5) {
            p = 1 - p;
            invert = true;
        }
        //
        // Get an estimate of the result:
        //
        var estimate = InverseStudentsT.inverse_students_t(df, p, 1 - p);
        var exact = estimate.pexact;
        var t = estimate.result;
        if ((t === 0) || exact) {
            return invert ? -t : t; // can't do better!
        }
        //
        // Change variables to inverse incomplete beta:
        //
        var t2 = t * t;
        var xb = df / (df + t2);
        var y = t2 / (df + t2);
        var a = df / 2;
        //
        // t can be so large that x underflows,
        // just return our estimate in that case:
        //
        if (xb === 0) {
            return t;
        }
        //
        // Get incomplete beta and it's derivative:
        //
        var resultObj = xb < y ?
            Beta.ibeta_imp(a, 0.5, xb, false, true)
            :
                Beta.ibeta_imp(0.5, a, y, true, true);
        var f1 = resultObj.pderivative;
        var f0 = resultObj.result;
        // Get cdf from incomplete beta result:
        var p0 = f0 / 2 - p;
        // Get pdf from derivative:
        var p1 = f1 * Math.sqrt(y * xb * xb * xb / df);
        //
        // Second derivative divided by p1:
        //
        // yacas gives:
        //
        // In> PrettyForm(Simplify(D(t) (1 + t^2/v) ^ (-(v+1)/2)))
        //
        //  |                        | v + 1     |     |
        //  |                       -| ----- + 1 |     |
        //  |                        |   2       |     |
        // -|             |  2     |                   |
        //  |             | t      |                   |
        //  |             | -- + 1 |                   |
        //  | ( v + 1 ) * | v      |               * t |
        // ---------------------------------------------
        //                       v
        //
        // Which after some manipulation is:
        //
        // -p1 * t * (df + 1) / (t^2 + df)
        //
        var p2 = t * (df + 1) / (t * t + df);
        // Halley step:
        t = Math.abs(t);
        t += p0 / (p1 + p0 * p2 / 2);
        return !invert ? -t : t;
    };
    return InverseStudentsT;
}());
exports.InverseStudentsT = InverseStudentsT;
