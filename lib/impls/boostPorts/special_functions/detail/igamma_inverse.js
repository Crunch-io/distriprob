"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var Rational = require("../../tools/rational").Rational;
var Gamma = require("../gamma").Gamma;
var Log1p = require("../log1p").Log1p;
var Precision = require("../../tools/precision").Precision;
var Roots = require("../../tools/roots").Roots;
var IGammaInverse = /** @class */ (function () {
    function IGammaInverse() {
    }
    IGammaInverse.find_inverse_s = function (p, q) {
        //
        // Computation of the Incomplete Gamma Function Ratios and their Inverse
        // ARMIDO R. DIDONATO and ALFRED H. MORRIS, JR.
        // ACM Transactions on Mathematical Software, Vol. 12, No. 4,
        // December 1986, Pages 377-393.
        //
        // See equation 32.
        //
        var t;
        if (p < 0.5) {
            t = Math.sqrt(-2 * Math.log(p));
        }
        else {
            t = Math.sqrt(-2 * Math.log(q));
        }
        var a = [
            3.31125922108741,
            11.6616720288968,
            4.28342155967104,
            0.213623493715853
        ];
        var b = [
            1,
            6.61053765625462,
            6.40691597760039,
            1.27364489782223,
            0.3611708101884203e-1
        ];
        var s = t - Rational.evaluate_polynomial(a, t) /
            Rational.evaluate_polynomial(b, t);
        if (p < 0.5) {
            s = -s;
        }
        return s;
    };
    IGammaInverse.didonato_SN = function (a, x, N, tolerance) {
        if (tolerance === void 0) { tolerance = 0; }
        //
        // Computation of the Incomplete Gamma Function Ratios and their Inverse
        // ARMIDO R. DIDONATO and ALFRED H. MORRIS, JR.
        // ACM Transactions on Mathematical Software, Vol. 12, No. 4,
        // December 1986, Pages 377-393.
        //
        // See equation 34.
        //
        var sum = 1;
        if (N >= 1) {
            var partial = x / (a + 1);
            sum += partial;
            for (var i = 2; i <= N; i++) {
                partial *= x / (a + i);
                sum += partial;
                if (partial < tolerance) {
                    break;
                }
            }
        }
        return sum;
    };
    IGammaInverse.didonato_FN = function (p, a, x, N, tolerance) {
        //
        // Computation of the Incomplete Gamma Function Ratios and their Inverse
        // ARMIDO R. DIDONATO and ALFRED H. MORRIS, JR.
        // ACM Transactions on Mathematical Software, Vol. 12, No. 4,
        // December 1986, Pages 377-393.
        //
        // See equation 34.
        //
        var u = Math.log(p) + Gamma.lgamma(a + 1).result;
        return Math.exp((u + x - Math.log(IGammaInverse.didonato_SN(a, x, N, tolerance))) / a);
    };
    IGammaInverse.find_inverse_gamma = function (a, p, q) {
        //
        // In order to understand what's going on here, you will
        // need to refer to:
        //
        // Computation of the Incomplete Gamma Function Ratios and their Inverse
        // ARMIDO R. DIDONATO and ALFRED H. MORRIS, JR.
        // ACM Transactions on Mathematical Software, Vol. 12, No. 4,
        // December 1986, Pages 377-393.
        //
        var result;
        var p_has_10_digits = false;
        if (a === 1) {
            result = -Math.log(q);
        }
        else if (a < 1) {
            var g = Gamma.tgamma(a);
            var b = q * g;
            if ((b > 0.6) || ((b >= 0.45) && (a >= 0.3))) {
                // DiDonato & Morris Eq 21:
                //
                // There is a slight variation from DiDonato and Morris here:
                // the first form given here is unstable when p is close to 1,
                // making it impossible to compute the inverse of Q(a,x) for small
                // q.  Fortunately the second form works perfectly well in this case.
                //
                var u = void 0;
                if ((b * q > 1e-8) && (q > 1e-5)) {
                    u = Math.pow(p * g * a, 1 / a);
                }
                else {
                    u = Math.exp((-q / a) - Math.E);
                }
                result = u / (1 - (u / (a + 1)));
            }
            else if ((a < 0.3) && (b >= 0.35)) {
                // DiDonato & Morris Eq 22:
                var t = Math.exp(-Math.E - b);
                var u = t * Math.exp(t);
                result = t * Math.exp(u);
            }
            else if ((b > 0.15) || (a >= 0.3)) {
                // DiDonato & Morris Eq 23:
                var y = -Math.log(b);
                var u = y - (1 - a) * Math.log(y);
                result = y - (1 - a) * Math.log(u) - Math.log(1 + (1 - a) / (1 + u));
            }
            else if (b > 0.1) {
                // DiDonato & Morris Eq 24:
                var y = -Math.log(b);
                var u = y - (1 - a) * Math.log(y);
                result = y - (1 - a) * Math.log(u) -
                    Math.log((u * u + 2 * (3 - a) * u + (2 - a) * (3 - a)) / (u * u + (5 - a) * u + 2));
            }
            else {
                // DiDonato & Morris Eq 25:
                var y = -Math.log(b);
                var c1 = (a - 1) * Math.log(y);
                var c1_2 = c1 * c1;
                var c1_3 = c1_2 * c1;
                var c1_4 = c1_2 * c1_2;
                var a_2 = a * a;
                var a_3 = a_2 * a;
                var c2 = (a - 1) * (1 + c1);
                var c3 = (a - 1) * (-(c1_2 / 2) + (a - 2) * c1 + (3 * a - 5) / 2);
                var c4 = (a - 1) * ((c1_3 / 3) - (3 * a - 5) * c1_2 / 2 + (a_2 - 6 * a + 7) * c1 +
                    (11 * a_2 - 46 * a + 47) / 6);
                var c5 = (a - 1) * (-(c1_4 / 4)
                    + (11 * a - 17) * c1_3 / 6
                    + (-3 * a_2 + 13 * a - 13) * c1_2
                    + (2 * a_3 - 25 * a_2 + 72 * a - 61) * c1 / 2
                    + (25 * a_3 - 195 * a_2 + 477 * a - 379) / 12);
                var y_2 = y * y;
                var y_3 = y_2 * y;
                var y_4 = y_2 * y_2;
                result = y + c1 + (c2 / y) + (c3 / y_2) + (c4 / y_3) + (c5 / y_4);
                if (b < 1e-28) {
                    p_has_10_digits = true;
                }
            }
        }
        else {
            // DiDonato and Morris Eq 31:
            var s = IGammaInverse.find_inverse_s(p, q);
            var s_2 = s * s;
            var s_3 = s_2 * s;
            var s_4 = s_2 * s_2;
            var s_5 = s_4 * s;
            var ra = Math.sqrt(a);
            var w = a + s * ra + (s * s - 1) / 3;
            w += (s_3 - 7 * s) / (36 * ra);
            w -= (3 * s_4 + 7 * s_2 - 16) / (810 * a);
            w += (9 * s_5 + 256 * s_3 - 433 * s) / (38880 * a * ra);
            if ((a >= 500) && (Math.abs(1 - w / a) < 1e-6)) {
                result = w;
                p_has_10_digits = true;
            }
            else if (p > 0.5) {
                if (w < 3 * a) {
                    result = w;
                }
                else {
                    var D = Math.max(2, a * (a - 1));
                    var lg = Gamma.lgamma(a).result;
                    var lb = Math.log(q) + lg;
                    if (lb < -D * 2.3) {
                        // DiDonato and Morris Eq 25:
                        var y = -lb;
                        var c1 = (a - 1) * Math.log(y);
                        var c1_2 = c1 * c1;
                        var c1_3 = c1_2 * c1;
                        var c1_4 = c1_2 * c1_2;
                        var a_2 = a * a;
                        var a_3 = a_2 * a;
                        var c2 = (a - 1) * (1 + c1);
                        var c3 = (a - 1) * (-(c1_2 / 2) + (a - 2) * c1 + (3 * a - 5) / 2);
                        var c4 = (a - 1) * ((c1_3 / 3) - (3 * a - 5) * c1_2 / 2 + (a_2 - 6 * a + 7) *
                            c1 + (11 * a_2 - 46 * a + 47) / 6);
                        var c5 = (a - 1) * (-(c1_4 / 4)
                            + (11 * a - 17) * c1_3 / 6
                            + (-3 * a_2 + 13 * a - 13) * c1_2
                            + (2 * a_3 - 25 * a_2 + 72 * a - 61) * c1 / 2
                            + (25 * a_3 - 195 * a_2 + 477 * a - 379) / 12);
                        var y_2 = y * y;
                        var y_3 = y_2 * y;
                        var y_4 = y_2 * y_2;
                        result = y + c1 + (c2 / y) + (c3 / y_2) + (c4 / y_3) + (c5 / y_4);
                    }
                    else {
                        // DiDonato and Morris Eq 33:
                        var u = -lb + (a - 1) * Math.log(w) - Math.log(1 + (1 - a) / (1 + w));
                        result = -lb + (a - 1) * Math.log(u) - Math.log(1 + (1 - a) / (1 + u));
                    }
                }
            }
            else {
                var z = w;
                var ap1 = a + 1;
                var ap2 = a + 2;
                if (w < 0.15 * ap1) {
                    // DiDonato and Morris Eq 35:
                    var v = Math.log(p) + Gamma.lgamma(ap1).result;
                    z = Math.exp((v + w) / a);
                    s = Log1p.log1p(z / ap1 * (1 + z / ap2));
                    z = Math.exp((v + z - s) / a);
                    s = Log1p.log1p(z / ap1 * (1 + z / ap2));
                    z = Math.exp((v + z - s) / a);
                    s = Log1p.log1p(z / ap1 * (1 + z / ap2 * (1 + z / (a + 3))));
                    z = Math.exp((v + z - s) / a);
                }
                if ((z <= 0.01 * ap1) || (z > 0.7 * ap1)) {
                    result = z;
                    if (z <= 0.002 * ap1) {
                        p_has_10_digits = true;
                    }
                }
                else {
                    // DiDonato and Morris Eq 36:
                    var ls = Math.log(IGammaInverse.didonato_SN(a, z, 100, 1e-4));
                    var v = Math.log(p) + Gamma.lgamma(ap1).result;
                    z = Math.exp((v + z - ls) / a);
                    result = z * (1 - (a * Math.log(z) - z - v + ls) / (a - z));
                }
            }
        }
        return { result: result, has_10_digits: p_has_10_digits };
    };
    IGammaInverse.gamma_p_inverse_func = function (a, p, inv) {
        var invert = inv;
        if (p > 0.9) {
            p = 1 - p;
            invert = !invert;
        }
        return function (x) {
            var f0, f1;
            var ft;
            var fResult = Gamma.gamma_incomplete_imp(a, x, true, invert);
            f0 = fResult.result;
            ft = fResult.pderivative;
            f1 = ft;
            var f2;
            var div = (a - x - 1) / x;
            f2 = f1;
            if ((Math.abs(div) > 1) && (Number.MAX_VALUE / Math.abs(div) < f2)) {
                // overflow:
                f2 = -Number.MAX_VALUE / 2;
            }
            else {
                f2 *= div;
            }
            if (invert) {
                f1 = -f1;
                f2 = -f2;
            }
            return { f0: f0 - p, f1: f1, f2: f2 };
        };
    };
    IGammaInverse.gamma_p_inv_imp = function (a, p) {
        if (a <= 0) {
            throw new Error("Domain error: Argument a in the incomplete gamma function" + "" + " inverse must be >= 0 (got a=" + a + ")");
        }
        if ((p < 0) || (p > 1)) {
            throw new Error("Domain error: Probability must be in the range [0,1] in the" + "" + " incomplete gamma function inverse (got p=" + p + ").");
        }
        if (p === 1) {
            return Gamma.tgamma(a);
        }
        if (p === 0) {
            return 0;
        }
        var guessObj = IGammaInverse.find_inverse_gamma(a, p, 1 - p);
        var has_10_digits = guessObj.has_10_digits;
        var guess = guessObj.result;
        if (has_10_digits) {
            return guess;
        }
        var lower = Number.MIN_VALUE;
        if (guess <= lower) {
            guess = Number.MIN_VALUE;
        }
        //
        // Work out how many digits to converge to, normally this is
        // 2/3 of the digits in T, but if the first derivative is very
        // large convergence is slow, so we'll bump it up to full
        // precision to prevent premature termination of the root-finding routine.
        //
        var digits = 53;
        if (digits < 30) {
            digits *= 2;
            digits /= 3;
        }
        else {
            digits /= 2;
            digits -= 1;
        }
        if ((a < 0.125) &&
            (Math.abs(Gamma.gamma_p_derivative(a, guess)) >
                1 / Math.sqrt(Precision.epsilon()))) {
            digits = 51;
        }
        //
        // Go ahead and iterate:
        //
        var max_iter = 500;
        guess = Roots.halley_iterate(IGammaInverse.gamma_p_inverse_func(a, p, false), guess, lower, Number.MAX_VALUE, digits, max_iter).result;
        if (guess === lower) {
            throw new Error("Underflow error: Expected result known to be non-zero, but is" + "" + " smaller than the smallest available number.");
        }
        return guess;
    };
    IGammaInverse.gamma_q_inv_imp = function (a, q) {
        if (a <= 0) {
            throw new Error("Domain error: Argument a in the incomplete gamma function" + "" + " inverse must be >= 0 (got a=" + a + ")");
        }
        if ((q < 0) || (q > 1)) {
            throw new Error("Domain error: Probability must be in the range [0,1] in the" + "" + " incomplete gamma function inverse (got q=" + q + ").");
        }
        if (q === 0) {
            return Gamma.tgamma(a);
        }
        if (q === 1) {
            return 0;
        }
        var guessObj = IGammaInverse.find_inverse_gamma(a, 1 - q, q);
        var has_10_digits = guessObj.has_10_digits;
        var guess = guessObj.result;
        if (has_10_digits) {
            return guess;
        }
        var lower = Number.MIN_VALUE;
        if (guess <= lower) {
            guess = Number.MIN_VALUE;
        }
        //
        // Work out how many digits to converge to, normally this is
        // 2/3 of the digits in T, but if the first derivative is very
        // large convergence is slow, so we'll bump it up to full
        // precision to prevent premature termination of the root-finding routine.
        //
        var digits = 53;
        if (digits < 30) {
            digits *= 2;
            digits /= 3;
        }
        else {
            digits /= 2;
            digits -= 1;
        }
        if ((a < 0.125) &&
            (Math.abs(Gamma.gamma_p_derivative(a, guess)) >
                1 / Math.sqrt(Precision.epsilon()))) {
            digits = 53;
        }
        //
        // Go ahead and iterate:
        //
        var max_iter = 500;
        guess = Roots.halley_iterate(IGammaInverse.gamma_p_inverse_func(a, q, true), guess, lower, Number.MAX_VALUE, digits, max_iter).result;
        if (guess === lower) {
            throw new Error("Underflow error: Expected result known to be non-zero, but is" + "" + " smaller than the smallest available number.");
        }
        return guess;
    };
    IGammaInverse.gamma_p_inv = function (a, p) {
        return IGammaInverse.gamma_p_inv_imp(a, p);
    };
    IGammaInverse.gamma_q_inv = function (a, q) {
        return IGammaInverse.gamma_q_inv_imp(a, q);
    };
    return IGammaInverse;
}());
exports.IGammaInverse = IGammaInverse;
