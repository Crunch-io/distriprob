"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright John Maddock 2007.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var CosPI = require("../cos_pi").CosPI;
var SinPI = require("../sin_pi").SinPI;
var Precision = require("../../tools/precision").Precision;
var Gamma = require("../gamma").Gamma;
var UncheckedFactorial = require("./unchecked_factorial").UncheckedFactorial;
var BesselJYAsym = /** @class */ (function () {
    function BesselJYAsym() {
    }
    BesselJYAsym.asymptotic_bessel_amplitude = function (v, x) {
        // Calculate the amplitude of J(v, x) and Y(v, x) for large
        // x: see A&S 9.2.28.
        var s = 1;
        var mu = 4 * v * v;
        var txq = 2 * x;
        txq *= txq;
        s += (mu - 1) / (2 * txq);
        s += 3 * (mu - 1) * (mu - 9) / (txq * txq * 8);
        s += 15 * (mu - 1) * (mu - 9) * (mu - 25) / (txq * txq * txq * 8 * 6);
        return Math.sqrt(s * 2 / (Math.PI * x));
    };
    BesselJYAsym.asymptotic_bessel_phase_mx = function (v, x) {
        //
        // Calculate the phase of J(v, x) and Y(v, x) for large x.
        // See A&S 9.2.29.
        // Note that the result returned is the phase less (x - PI(v/2 + 1/4))
        // which we'll factor in later when we calculate the sines/cosines of the result:
        //
        var mu = 4 * v * v;
        var denom = 4 * x;
        var denom_mult = denom * denom;
        var s = 0;
        s += (mu - 1) / (2 * denom);
        denom *= denom_mult;
        s += (mu - 1) * (mu - 25) / (6 * denom);
        denom *= denom_mult;
        s += (mu - 1) * (mu * mu - 114 * mu + 1073) / (5 * denom);
        denom *= denom_mult;
        s += (mu - 1) * (5 * mu * mu * mu - 1535 * mu * mu + 54703 * mu - 375733) /
            (14 * denom);
        return s;
    };
    BesselJYAsym.asymptotic_bessel_y_large_x_2 = function (v, x) {
        // See A&S 9.2.19.
        // Get the phase and amplitude:
        var ampl = BesselJYAsym.asymptotic_bessel_amplitude(v, x);
        var phase = BesselJYAsym.asymptotic_bessel_phase_mx(v, x);
        //
        // Calculate the sine of the phase, using
        // sine/cosine addition rules to factor in
        // the x - PI(v/2 + 1/4) term not added to the
        // phase when we calculated it.
        //
        var cx = Math.cos(x);
        var sx = Math.sin(x);
        var ci = CosPI.cos_pi(v / 2 + 0.25);
        var si = SinPI.sin_pi(v / 2 + 0.25);
        var sin_phase = Math.sin(phase) * (cx * ci + sx * si) + Math.cos(phase) *
            (sx * ci - cx * si);
        return sin_phase * ampl;
    };
    BesselJYAsym.asymptotic_bessel_j_large_x_2 = function (v, x) {
        // See A&S 9.2.19.
        // Get the phase and amplitude:
        var ampl = BesselJYAsym.asymptotic_bessel_amplitude(v, x);
        var phase = BesselJYAsym.asymptotic_bessel_phase_mx(v, x);
        //
        // Calculate the sine of the phase, using
        // sine/cosine addition rules to factor in
        // the x - PI(v/2 + 1/4) term not added to the
        // phase when we calculated it.
        //
        var cx = Math.cos(x);
        var sx = Math.sin(x);
        var ci = CosPI.cos_pi(v / 2 + 0.25);
        var si = SinPI.sin_pi(v / 2 + 0.25);
        var sin_phase = Math.cos(phase) * (cx * ci + sx * si) - Math.sin(phase) *
            (sx * ci - cx * si);
        return sin_phase * ampl;
    };
    BesselJYAsym.asymptotic_bessel_large_x_limit_intv = function (v, x) {
        //
        // Determines if x is large enough compared to v to take the asymptotic
        // forms above.  From A&S 9.2.28 we require:
        //    v < x * eps^1/8
        // and from A&S 9.2.29 we require:
        //    v^12/10 < 1.5 * x * eps^1/10
        // using the former seems to work OK in practice with broadly similar
        // error rates either side of the divide for v < 10000.
        // At double precision eps^1/8 ~= 0.01.
        //
        return (v ? v : 1) < x * 0.004;
    };
    BesselJYAsym.asymptotic_bessel_large_x_limit_realv = function (v, x) {
        //
        // Determines if x is large enough compared to v to take the asymptotic
        // forms above.  From A&S 9.2.28 we require:
        //    v < x * eps^1/8
        // and from A&S 9.2.29 we require:
        //    v^12/10 < 1.5 * x * eps^1/10
        // using the former seems to work OK in practice with broadly similar
        // error rates either side of the divide for v < 10000.
        // At double precision eps^1/8 ~= 0.01.
        //
        return Math.max(Math.abs(v), 1) < x * Math.sqrt(Precision.forth_root_epsilon());
    };
    BesselJYAsym.temme_asyptotic_y_small_x = function (v, x) {
        var c = 1;
        var p = (v / SinPI.sin_pi(v)) * Math.pow(x / 2, -v) / Gamma.tgamma(1 - v);
        var q = (v / SinPI.sin_pi(v)) * Math.pow(x / 2, v) / Gamma.tgamma(1 + v);
        var f = (p - q) / v;
        var g_prefix = SinPI.sin_pi(v / 2);
        g_prefix *= g_prefix * 2 / v;
        var g = f + g_prefix * q;
        var h = p;
        var c_mult = -x * x / 4;
        var y = c * g;
        var y1 = c * h;
        var max_iter = UncheckedFactorial.max_factorial();
        for (var k = 1; k < max_iter; k++) {
            f = (k * f + p + q) / (k * k - v * v);
            p /= k - v;
            q /= k + v;
            c *= c_mult / k;
            var c1 = Math.pow(-x * x / 4, k) / UncheckedFactorial.unchecked_factorial(k);
            g = f + g_prefix * q;
            h = -k * g + p;
            y += c * g;
            y1 += c * h;
            if (c * g / Precision.epsilon() < y) {
                break;
            }
        }
        return {
            Y: -y,
            Y1: (-2 / x) * y1
        };
    };
    BesselJYAsym.asymptotic_bessel_i_large_x = function (v, x) {
        var s = 1;
        var mu = 4 * v * v;
        var ex = 8 * x;
        var num = mu - 1;
        var denom = ex;
        s -= num / denom;
        num *= mu - 9;
        denom *= ex * 2;
        s += num / denom;
        num *= mu - 25;
        denom *= ex * 3;
        s -= num / denom;
        // Try and avoid overflow to the last minute:
        var e = Math.exp(x / 2);
        s = e * (e * s / Math.sqrt(2 * x * Math.PI));
        if (s === Number.POSITIVE_INFINITY || s === Number.NEGATIVE_INFINITY) {
            throw new Error("Overflow error");
        }
        else {
            return s;
        }
    };
    return BesselJYAsym;
}());
exports.BesselJYAsym = BesselJYAsym;
