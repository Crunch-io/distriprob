"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var Toms748 = require("../../tools/toms748_solve").Toms748;
var Beta = require("../beta").Beta;
var ErfInv = require("./erf_inv").ErfInv;
var Constants = require("../../tools/constants").Constants;
var Precision = require("../../tools/precision").Precision;
var IBetaInvAB = /** @class */ (function () {
    function IBetaInvAB() {
    }
    IBetaInvAB.beta_inv_ab_t = function (b, z, p, invert, swap_ab) {
        return function (a) {
            return invert ?
                p - Beta.ibetac(swap_ab ? b : a, swap_ab ? a : b, z)
                :
                    Beta.ibeta(swap_ab ? b : a, swap_ab ? a : b, z) - p;
        };
    };
    IBetaInvAB.inverse_negative_binomial_cornish_fisher = function (n, sf, sfc, p, q) {
        // mean:
        var m = n * (sfc) / sf;
        var t = Math.sqrt(n * (sfc));
        // standard deviation:
        var sigma = t / sf;
        // skewness
        var sk = (1 + sfc) / t;
        // kurtosis:
        var k = (6 - sf * (5 + sfc)) / (n * (sfc));
        // Get the inverse of a std normal distribution:
        var x = ErfInv.erfc_inv(p > q ? 2 * q : 2 * p) * Constants.SQRT2();
        // Set the sign:
        if (p < 0.5) {
            x = -x;
        }
        var x2 = x * x;
        // w is correction term due to skewness
        var w = x + sk * (x2 - 1) / 6;
        //
        // Add on correction due to kurtosis.
        //
        if (n >= 10) {
            w += k * x * (x2 - 3) / 24 + sk * sk * x * (2 * x2 - 5) / -36;
        }
        w = m + sigma * w;
        if (w < Number.MIN_VALUE) {
            return Number.MIN_VALUE;
        }
        return w;
    };
    IBetaInvAB.ibeta_inv_ab_imp = function (b, z, p, q, swap_ab) {
        //
        // Special cases first:
        //
        if (p === 0) {
            return swap_ab ? Number.MIN_VALUE : Number.MAX_VALUE;
        }
        if (q === 0) {
            return swap_ab ? Number.MAX_VALUE : Number.MIN_VALUE;
        }
        //
        // Function object, this is the functor whose root
        // we have to solve:
        //
        var f = IBetaInvAB.beta_inv_ab_t(b, z, (p < q) ? p : q, (p < q) ? false : true, swap_ab);
        //
        // Tolerance: full precision.
        //
        var tol = Toms748.eps_tolerance(53);
        //
        // Now figure out a starting guess for what a may be,
        // we'll start out with a value that'll put p or q
        // right bang in the middle of their range, the functions
        // are quite sensitive so we should need too many steps
        // to bracket the root from there:
        //
        var guess = 0;
        var factor = 5;
        //
        // Convert variables to parameters of a negative binomial distribution:
        //
        var n = b;
        var sf = swap_ab ? z : 1 - z;
        var sfc = swap_ab ? 1 - z : z;
        var u = swap_ab ? p : q;
        var v = swap_ab ? q : p;
        if (u <= Math.pow(sf, n)) {
            //
            // Result is less than 1, negative binomial approximation
            // is useless....
            //
            if ((p < q) != swap_ab) {
                guess = Math.min(b * 2, 1);
            }
            else {
                guess = Math.min(b / 2, 1);
            }
        }
        if (n * n * n * u * sf > 0.005)
            guess = 1 + IBetaInvAB.inverse_negative_binomial_cornish_fisher(n, sf, sfc, u, v);
        if (guess < 10) {
            //
            // Negative binomial approximation not accurate in this area:
            //
            if ((p < q) != swap_ab) {
                guess = Math.min(b * 2, 10);
            }
            else {
                guess = Math.min(b / 2, 10);
            }
        }
        else {
            factor = (v < Math.sqrt(Precision.epsilon())) ? 2 : (guess < 20 ? 1.2 : 1.1);
        }
        //
        // Max iterations permitted:
        //
        var max_iter = 500;
        var r = Toms748.bracket_and_solve_root(f, guess, factor, swap_ab ? true : false, tol, max_iter);
        if (r.iterations >= max_iter) {
            throw new Error("Evaluation error: Unable to locate the root within a reasonable" + "" + " number of iterations, closest approximation so far was " + r.a + "\"");
        }
        return (r.a + r.b) / 2;
    };
    IBetaInvAB.ibeta_inva = function (b, x, p) {
        if (p === 0) {
            throw new Error("Overflow error");
        }
        if (p === 1) {
            return Number.MIN_VALUE;
        }
        return IBetaInvAB.ibeta_inv_ab_imp(b, x, p, 1 - p, false);
    };
    IBetaInvAB.ibetac_inva = function (b, x, q) {
        if (q === 1) {
            throw new Error("Overflow error");
        }
        if (q === 0) {
            return Number.MIN_VALUE;
        }
        return IBetaInvAB.ibeta_inv_ab_imp(b, x, 1 - q, q, false);
    };
    IBetaInvAB.ibeta_invb = function (a, x, p) {
        if (p === 0) {
            return Number.MIN_VALUE;
        }
        if (p === 1) {
            throw new Error("Overflow error");
        }
        return IBetaInvAB.ibeta_inv_ab_imp(a, x, p, 1 - p, true);
    };
    IBetaInvAB.ibetac_invb = function (a, x, q) {
        if (q === 1) {
            return Number.MIN_VALUE;
        }
        if (q === 0) {
            throw new Error("Overflow error");
        }
        return IBetaInvAB.ibeta_inv_ab_imp(a, x, 1 - q, q, true);
    };
    return IBetaInvAB;
}());
exports.IBetaInvAB = IBetaInvAB;
