"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright Xiaogang Zhang 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var Gamma = require("../gamma").Gamma;
var SinPI = require("../sin_pi").SinPI;
var Precision = require("../../tools/precision").Precision;
var CosPI = require("../cos_pi").CosPI;
var BesselJYSeries = require("./bessel_jy_series").BesselJYSeries;
var BesselJYAsym = require("./bessel_jy_asym").BesselJYAsym;
var Constants = require("../../tools/constants").Constants;
var UncheckedFactorial = require("./unchecked_factorial").UncheckedFactorial;
var Sign = require("../sign").Sign;
var BesselJY = /** @class */ (function () {
    function BesselJY() {
    }
    /**
     * Simultaneous calculation of A&S 9.2.9 and 9.2.10
     * for use in A&S 9.2.5 and 9.2.6.
     * This series is quick to evaluate, but divergent unless
     * x is very large, in fact it's pretty hard to figure out
     * with any degree of precision when this series actually
     * *will* converge!!  Consequently, we may just have to
     * try it and see...
     */
    BesselJY.hankel_PQ = function (v, x) {
        var tolerance = 2 * Precision.epsilon();
        var p = 1;
        var q = 0;
        var k = 1;
        var z8 = 8 * x;
        var sq = 1;
        var mu = 4 * v * v;
        var term = 1;
        var ok = true;
        do {
            term *= (mu - sq * sq) / (k * z8);
            q += term;
            k += 1;
            sq += 2;
            var mult = (sq * sq - mu) / (k * z8);
            ok = Math.abs(mult) < 0.5;
            term *= mult;
            p += term;
            k += 1;
            sq += 2;
        } while ((Math.abs(term) > tolerance * p) && ok);
        return { ok: ok, p: p, q: q };
    };
    /**
     * Calculate Y(v, x) and Y(v+1, x) by Temme's method, see
     * Temme, Journal of Computational Physics, vol 21, 343 (1976)
     */
    BesselJY.temme_jy = function (v, x) {
        var g, h, p, q, f, coef, sum, sum1, tolerance;
        var a, d, e, sigma;
        var k;
        // BOOST_ASSERT(fabs(v) <= 0.5f);  // precondition for using this routine
        var gp = Gamma.tgamma1pm1(v);
        var gm = Gamma.tgamma1pm1(-v);
        var spv = SinPI.sin_pi(v);
        var spv2 = SinPI.sin_pi(v / 2);
        var xp = Math.pow(x / 2, v);
        a = Math.log(x / 2);
        sigma = -a * v;
        d = Math.abs(sigma) < Precision.epsilon() ? 1 : Math.sinh(sigma) / sigma;
        e = Math.abs(v) < Precision.epsilon() ? (v * Math.PI * Math.PI / 2) : (2 * spv2 * spv2 / v);
        var g1 = (v === 0) ? (-Math.E) : ((gp - gm) / ((1 + gp) * (1 + gm) * 2 * v));
        var g2 = (2 + gp + gm) / ((1 + gp) * (1 + gm) * 2);
        var vspv = (Math.abs(v) < Precision.epsilon()) ? (1 / Math.PI) : (v / spv);
        f = (g1 * Math.cosh(sigma) - g2 * a * d) * 2 * vspv;
        p = vspv / (xp * (1 + gm));
        q = vspv * xp / (1 + gp);
        g = f + e * q;
        h = p;
        coef = 1;
        sum = coef * g;
        sum1 = coef * h;
        var v2 = v * v;
        var coef_mult = -x * x / 4;
        // series summation
        tolerance = Precision.epsilon();
        var max_iter = 500;
        for (k = 1; k < max_iter; k++) {
            f = (k * f + p + q) / (k * k - v2);
            p /= k - v;
            q /= k + v;
            g = f + e * q;
            h = p - k * g;
            coef *= coef_mult / k;
            sum += coef * g;
            sum1 += coef * h;
            if (Math.abs(coef * g) < Math.abs(sum) * tolerance) {
                break;
            }
        }
        return { Y: -sum, Y1: -2 * sum1 / x };
    };
    /**
     * Evaluate continued fraction fv = J_(v+1) / J_v, see
     * Abramowitz and Stegun, Handbook of Mathematical Functions, 1972, 9.1.73
     */
    BesselJY.CF1_jy = function (v, x) {
        var C, D, f, a, b, delta, tiny, tolerance;
        var k;
        var s = 1;
        // |x| <= |v|, CF1_jy converges rapidly
        // |x| > |v|, CF1_jy needs O(|x|) iterations to converge
        // modified Lentz's method, see
        // Lentz, Applied Optics, vol 15, 668 (1976)
        // TODO: see if we can use /tools/fraction for this continued fraction
        tolerance = 2 * Precision.epsilon();
        tiny = Math.sqrt(Number.MIN_VALUE);
        C = f = tiny; // b0 = 0, replace with tiny
        D = 0;
        var max_iter = 500;
        for (k = 1; k < max_iter * 100; k++) {
            a = -1;
            b = 2 * (v + k) / x;
            C = b + a / C;
            D = b + a * D;
            if (C == 0) {
                C = tiny;
            }
            if (D == 0) {
                D = tiny;
            }
            D = 1 / D;
            delta = C * D;
            f *= delta;
            if (D < 0) {
                s = -s;
            }
            if (Math.abs(delta - 1) < tolerance) {
                break;
            }
        }
        return {
            fv: -f,
            sign: s // sign of denominator
        };
    };
    /**
     * This algorithm was originally written by Xiaogang Zhang
     * using std::complex to perform the complex arithmetic.
     * However, that turns out to 10x or more slower than using
     * all real-valued arithmetic, so it's been rewritten using
     * real values only.
     */
    BesselJY.CF2_jy = function (v, x) {
        var Cr, Ci, Dr, Di, fr, fi, a, br, bi, delta_r, delta_i, temp;
        var tiny;
        var k;
        // |x| >= |v|, CF2_jy converges rapidly
        // |x| -> 0, CF2_jy fails to converge
        // BOOST_ASSERT(Math.abs(x) > 1);
        // modified Lentz's method, complex numbers involved, see
        // Lentz, Applied Optics, vol 15, 668 (1976)
        // TODO: see if we can use /tools/fraction for this continued fraction
        var tolerance = 2 * Precision.epsilon();
        tiny = Math.sqrt(Number.MIN_VALUE);
        Cr = fr = -0.5 / x;
        Ci = fi = 1;
        //Dr = Di = 0;
        var v2 = v * v;
        a = (0.25 - v2) / x; // Note complex this one time only!
        br = 2 * x;
        bi = 2;
        temp = Cr * Cr + 1;
        Ci = bi + a * Cr / temp;
        Cr = br + a / temp;
        Dr = br;
        Di = bi;
        if (Math.abs(Cr) + Math.abs(Ci) < tiny) {
            Cr = tiny;
        }
        if (Math.abs(Dr) + Math.abs(Di) < tiny) {
            Dr = tiny;
        }
        temp = Dr * Dr + Di * Di;
        Dr = Dr / temp;
        Di = -Di / temp;
        delta_r = Cr * Dr - Ci * Di;
        delta_i = Ci * Dr + Cr * Di;
        temp = fr;
        fr = temp * delta_r - fi * delta_i;
        fi = temp * delta_i + fi * delta_r;
        var max_iter = 500;
        for (k = 2; k < max_iter; k++) {
            a = k - 0.5;
            a *= a;
            a -= v2;
            bi += 2;
            temp = Cr * Cr + Ci * Ci;
            Cr = br + a * Cr / temp;
            Ci = bi - a * Ci / temp;
            Dr = br + a * Dr;
            Di = bi + a * Di;
            if (Math.abs(Cr) + Math.abs(Ci) < tiny) {
                Cr = tiny;
            }
            if (Math.abs(Dr) + Math.abs(Di) < tiny) {
                Dr = tiny;
            }
            temp = Dr * Dr + Di * Di;
            Dr = Dr / temp;
            Di = -Di / temp;
            delta_r = Cr * Dr - Ci * Di;
            delta_i = Ci * Dr + Cr * Di;
            temp = fr;
            fr = temp * delta_r - fi * delta_i;
            fi = temp * delta_i + fi * delta_r;
            if (Math.abs(delta_r - 1) + Math.abs(delta_i) < tolerance) {
                break;
            }
        }
        return { p: fr, q: fi };
    };
    BesselJY.bessel_jy = function (v, x, kind) {
        var need_j = 1;
        var need_y = 2;
        var _kind = kind === "need_j" ? need_j : need_y;
        var J, Y;
        // BOOST_ASSERT(x >= 0);
        var u, Jv, Ju, Yv, Yv1, Yu, Yu1 = 0, fv, fu;
        var W, p, q, gamma, current, prev, next;
        var reflect = false;
        var n, k;
        var s;
        var org_kind = _kind;
        var cp = 0;
        var sp = 0;
        if (v < 0) {
            reflect = true;
            v = -v; // v is non-negative from here
        }
        if (v > Number.MAX_SAFE_INTEGER) {
            throw new Error("Evaluation error: Order of Bessel function is too large to" + "" + " evaluate: got " + v);
        }
        n = Math.round(v);
        u = v - n; // -1/2 <= u < 1/2
        if (reflect) {
            var z = (u + n % 2);
            cp = CosPI.cos_pi(z);
            sp = SinPI.sin_pi(z);
            if (u !== 0) {
                _kind = need_j | need_y; // need both for reflection formula
            }
        }
        if (x === 0) {
            if (v === 0) {
                J = 1;
            }
            else if ((u === 0) || !reflect) {
                J = 0;
            }
            else if (_kind & need_j) {
                throw new Error("Domain error: Value of Bessel J_v(x) is complex-infinity" + "" + " at " + x);
            }
            else {
                J = NaN; // any value will do, not using J.
            }
            if ((_kind & need_y) === 0) {
                Y = NaN; // any value will do, not using Y.
            }
            else if (v === 0) {
                throw new Error("Overflow error");
            }
            else {
                throw new Error("Domain error: Value of Bessel Y_v(x) is complex-infinity" + "" + " at " + x);
            }
            return { J: J, Y: Y };
        }
        // x is positive until reflection
        W = 2 / (x * Math.PI); // Wronskian
        var Yv_scale = 1;
        if (((_kind & need_y) === 0) && ((x < 1) || (v > x * x / 4) || (x < 5))) {
            //
            // This series will actually converge rapidly for all small
            // x - say up to x < 20 - but the first few terms are large
            // and divergent which leads to large errors :-(
            //
            Jv = BesselJYSeries.bessel_j_small_z_series(v, x);
            Yv = NaN;
        }
        else if ((x < 1) && (u != 0) &&
            (Math.log(Precision.epsilon() / 2) > v * Math.log((x / 2) * (x / 2) / v))) {
            // Evaluate using series representations.
            // This is particularly important for x << v as in this
            // area temme_jy may be slow to converge, if it converges at all.
            // Requires x is not an integer.
            if (_kind & need_j) {
                Jv = BesselJYSeries.bessel_j_small_z_series(v, x);
            }
            else {
                Jv = NaN;
            }
            if ((org_kind & need_y && (!reflect || (cp !== 0))) ||
                (org_kind & need_j && (reflect && (sp !== 0)))) {
                // Only calculate if we need it, and if the reflection formula will actually use
                // it:
                var resultObj = BesselJYSeries.bessel_y_small_z_series(v, x);
                Yv = resultObj.result;
                Yv_scale = resultObj.pscale;
            }
            else {
                Yv = NaN;
            }
        }
        else if ((u === 0) && (x < Precision.epsilon())) {
            // Truncated series evaluation for small x and v an integer,
            // much quicker in this area than temme_jy below.
            if (_kind & need_j) {
                Jv = BesselJYSeries.bessel_j_small_z_series(v, x);
            }
            else {
                Jv = NaN;
            }
            if ((org_kind & need_y && (!reflect || (cp !== 0))) ||
                (org_kind & need_j && (reflect && (sp !== 0)))) {
                // Only calculate if we need it, and if the reflection formula will actually use it:
                var resultObj = BesselJYSeries.bessel_yn_small_z(n, x, Yv_scale);
                Yv = resultObj.result;
                Yv_scale = resultObj.scale;
            }
            else {
                Yv = NaN;
            }
        }
        else if (BesselJYAsym.asymptotic_bessel_large_x_limit_realv(v, x)) {
            if (_kind & need_y) {
                Yv = BesselJYAsym.asymptotic_bessel_y_large_x_2(v, x);
            }
            else {
                Yv = NaN; // any value will do, we're not using it.
            }
            if (_kind & need_j) {
                Jv = BesselJYAsym.asymptotic_bessel_j_large_x_2(v, x);
            }
            else {
                Jv = NaN; // any value will do, we're not using it.
            }
        }
        else if ((x > 8) && BesselJY.hankel_PQ(v, x).ok) {
            var resultObj = BesselJY.hankel_PQ(v, x);
            p = resultObj.p;
            q = resultObj.q;
            //
            // Hankel approximation: note that this method works best when x
            // is large, but in that case we end up calculating sines and cosines
            // of large values, with horrendous resulting accuracy.  It is fast though
            // when it works....
            //
            // Normally we calculate sin/cos(chi) where:
            //
            // chi = x - fmod(T(v / 2 + 0.25f), T(2)) * boost::math::constants::pi<T>();
            //
            // But this introduces large errors, so use sin/cos addition formulae to
            // improve accuracy:
            //
            var mod_v = (v / 2 + 0.25) % 2; // originally: fmod(v / 2 + 0.25, 2);
            var sx = Math.sin(x);
            var cx = Math.cos(x);
            var sv = SinPI.sin_pi(mod_v);
            var cv = CosPI.cos_pi(mod_v);
            var sc = sx * cv - sv * cx; // == sin(chi);
            var cc = cx * cv + sx * sv; // == cos(chi);
            var chi = Constants.SQRT2() / (Constants.SQRTPI() * Math.sqrt(x));
            Yv = chi * (p * sc + q * cc);
            Jv = chi * (p * cc - q * sc);
        }
        else if (x <= 2) {
            var resultObj = BesselJY.temme_jy(u, x); // Temme series
            Yu = resultObj.Y;
            Yu1 = resultObj.Y1;
            prev = Yu;
            current = Yu1;
            var scale = 1;
            for (k = 1; k <= n; k++) {
                var fact = 2 * (u + k) / x;
                if ((Number.MAX_VALUE - Math.abs(prev)) / fact < Math.abs(current)) {
                    scale /= current;
                    prev /= current;
                    current = 1;
                }
                next = fact * current - prev;
                prev = current;
                current = next;
            }
            Yv = prev;
            Yv1 = current;
            if (_kind & need_j) {
                var resultObj2 = BesselJY.CF1_jy(v, x); // continued fraction CF1_jy
                fv = resultObj2.fv;
                s = resultObj2.sign;
                Jv = scale * W / (Yv * fv - Yv1); // Wronskian relation
            }
            else {
                Jv = NaN; // any value will do, we're not using it.
            }
            Yv_scale = scale;
        }
        else {
            // Get Y(u, x):
            var ratio = void 0;
            var resultObj = BesselJY.CF1_jy(v, x);
            fv = resultObj.fv;
            s = resultObj.sign;
            // tiny initial value to prevent overflow
            var init = Math.sqrt(Number.MIN_VALUE);
            prev = fv * s * init;
            current = s * init;
            if (v < UncheckedFactorial.max_factorial()) {
                for (k = n; k > 0; k--) {
                    next = 2 * (u + k) * current / x - prev;
                    prev = current;
                    current = next;
                }
                ratio = (s * init) / current; // scaling ratio
                // can also call CF1_jy() to get fu, not much difference in precision
                fu = prev / current;
            }
            else {
                //
                // When v is large we may get overflow in this calculation
                // leading to NaN's and other nasty surprises:
                //
                var over = false;
                for (k = n; k > 0; k--) {
                    var t_1 = 2 * (u + k) / x;
                    if ((t_1 > 1) && (Number.MAX_VALUE / t_1 < current)) {
                        over = true;
                        break;
                    }
                    next = t_1 * current - prev;
                    prev = current;
                    current = next;
                }
                if (!over) {
                    ratio = (s * init) / current; // scaling ratio
                    // can also call CF1_jy() to get fu, not much difference in precision
                    fu = prev / current;
                }
                else {
                    ratio = 0;
                    fu = 1;
                }
            }
            var resultObj2 = BesselJY.CF2_jy(u, x); // continued fraction CF2_jy
            p = resultObj2.p;
            q = resultObj2.q;
            var t = u / x - fu; // t = J'/J
            gamma = (p - t) / q;
            //
            // We can't allow gamma to cancel out to zero competely as it messes up
            // the subsequent logic.  So pretend that one bit didn't cancel out
            // and set to a suitably small value.  The only test case we've been able to
            // find for this, is when v = 8.5 and x = 4*PI.
            //
            if (gamma === 0) {
                gamma = u * Precision.epsilon() / x;
            }
            Ju = Sign.sign(current) * Math.sqrt(W / (q + gamma * (p - t)));
            Jv = Ju * ratio; // normalization
            Yu = gamma * Ju;
            Yu1 = Yu * (u / x - p - q / gamma);
            if (_kind & need_y) {
                // compute Y:
                prev = Yu;
                current = Yu1;
                for (k = 1; k <= n; k++) {
                    var fact = 2 * (u + k) / x;
                    if ((Number.MAX_VALUE - Math.abs(prev)) / fact < Math.abs(current)) {
                        prev /= current;
                        Yv_scale /= current;
                        current = 1;
                    }
                    next = fact * current - prev;
                    prev = current;
                    current = next;
                }
                Yv = prev;
            }
            else {
                Yv = NaN; // any value will do, we're not using it.
            }
        }
        if (reflect) {
            if ((sp != 0) && (Number.MAX_VALUE * Math.abs(Yv_scale) < Math.abs(sp * Yv))) {
                if (org_kind & need_j) {
                    throw new Error("Overflow error");
                }
                else {
                    J = 0;
                }
            }
            else {
                J = cp * Jv - (sp === 0 ? 0 : (sp * Yv) / Yv_scale); // reflection formula
            }
            if ((cp !== 0) && (Number.MAX_VALUE * Math.abs(Yv_scale) < Math.abs(cp * Yv))) {
                if (org_kind & need_y) {
                    throw new Error("Overflow error");
                }
                else {
                    Y = 0;
                }
            }
            else {
                Y = (sp !== 0 ? sp * Jv : 0) + (cp === 0 ? 0 : (cp * Yv) / Yv_scale);
            }
        }
        else {
            J = Jv;
            if (Number.MAX_VALUE * Math.abs(Yv_scale) < Math.abs(Yv)) {
                if (org_kind & need_y) {
                    throw new Error("Overflow error");
                }
                else {
                    Y = 0;
                }
            }
            else {
                Y = Yv / Yv_scale;
            }
        }
        return { J: J, Y: Y };
    };
    return BesselJY;
}());
exports.BesselJY = BesselJY;
