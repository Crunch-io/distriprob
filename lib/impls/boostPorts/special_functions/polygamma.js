"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright 2013 Nikhar Agrawal
 * (C) Copyright 2013 Christopher Kormanyos
 * (C) Copyright 2014 John Maddock
 * (C) Copyright 2013 Paul Bristow
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var SinPI = require("./sin_pi").SinPI;
var UncheckedFactorial = require("./detail/unchecked_factorial").UncheckedFactorial;
var Gamma = require("./gamma").Gamma;
var Precision = require("../tools/precision").Precision;
var Constants = require("../tools/constants").Constants;
var Bernoulli = require("./bernoulli").Bernoulli;
var Zeta = require("./zeta").Zeta;
var CosPI = require("./cos_pi").CosPI;
var Rational = require("../tools/rational").Rational;
var Sign = require("./sign").Sign;
var Digamma = require("./digamma").Digamma;
var Polygamma = /** @class */ (function () {
    function Polygamma() {
    }
    /**
     * for large values of x such as for x > 400
     */
    Polygamma.polygamma_atinfinityplus = function (n, x) {
        // See http://functions.wolfram.com/GammaBetaErf/PolyGamma2/06/02/0001/
        //
        // sum       == current value of accumulated sum.
        // term      == value of current term to be added to sum.
        // part_term == value of current term excluding the Bernoulli number part
        //
        if (n + x === x) {
            // x is crazy large, just concentrate on the first part of the expression and use
            // logs:
            if (n === 1) {
                return 1 / x;
            }
            var nlx = n * Math.log(x);
            if ((nlx < UncheckedFactorial.max_factorial()) &&
                (n < UncheckedFactorial.max_factorial())) {
                return ((n & 1) ? 1 : -1) *
                    UncheckedFactorial.unchecked_factorial(n - 1) *
                    Math.pow(x, -n);
            }
            else {
                return ((n & 1) ? 1 : -1) * Math.exp(Gamma.lgamma(n).result - n * Math.log(x));
            }
        }
        var term, sum, part_term;
        var x_squared = x * x;
        //
        // Start by setting part_term to:
        //
        // (n-1)! / x^(n+1)
        //
        // which is common to both the first term of the series (with k = 1)
        // and to the leading part.
        // We can then get to the leading term by:
        //
        // part_term * (n + 2 * x) / 2
        //
        // and to the first term in the series
        // (excluding the Bernoulli number) by:
        //
        // part_term n * (n + 1) / (2x)
        //
        // If either the factorial would overflow,
        // or the power term underflows, this just gets set to 0 and then we
        // know that we have to use logs for the initial terms:
        //
        part_term = ((n > UncheckedFactorial.max_factorial()) &&
            (n * n > Precision.log_max_value())) ?
            0
            :
                UncheckedFactorial.unchecked_factorial(n - 1) * Math.pow(x, -n - 1);
        if (part_term === 0) {
            // Either n is very large, or the power term underflows,
            // set the initial values of part_term, term and sum via logs:
            part_term = Gamma.lgamma(n).result - (n + 1) * Math.log(x);
            sum = Math.exp(part_term + Math.log(n + 2 * x) - Constants.LN2());
            part_term += Math.log(n * (n + 1)) - Constants.LN2() - Math.log(x);
            part_term = Math.exp(part_term);
        }
        else {
            sum = part_term * (n + 2 * x) / 2;
            part_term *= (n * (n + 1)) / 2;
            part_term /= x;
        }
        //
        // If the leading term is 0, so is the result:
        //
        if (sum === 0) {
            return sum;
        }
        var max_iter = 500;
        var k = 1;
        while (true) {
            term = part_term * Bernoulli.bernoulli_b2n(k);
            sum += term;
            //
            // NormalDist termination condition:
            //
            if (Math.abs(term / sum) < Precision.epsilon()) {
                break;
            }
            //
            // Increment our counter, and move part_term on to the next value:
            //
            k++;
            part_term *= (n + 2 * k - 2) * (n - 1 + 2 * k);
            part_term /= (2 * k - 1) * 2 * k;
            part_term /= x_squared;
            //
            // Emergency get out termination condition:
            //
            if (k > max_iter) {
                throw new Error("Evaluation error: Series did not converge, closest value was " + sum);
            }
        }
        if ((n - 1) & 1) {
            sum = -sum;
        }
        return sum;
    };
    Polygamma.polygamma_attransitionplus = function (n, x) {
        // See: http://functions.wolfram.com/GammaBetaErf/PolyGamma2/16/01/01/0017/
        // Use N = (0.4 * digits) + (4 * n) for target value for x:
        var d4d = 6; // 0.4F * policies::digits_base10<T, Policy>();
        var N = d4d + (4 * n);
        var m = n;
        var iter = N - Math.trunc(x);
        var max_iter = 50000;
        if (iter > max_iter) {
            throw new Error("Evaluation error: Exceeded maximum series evaluations" + "" + " evaluating at n = " + n + " and x = " + x);
        }
        var minus_m_minus_one = -m - 1;
        var z = x;
        var sum0 = 0;
        var z_plus_k_pow_minus_m_minus_one = 0;
        // Forward recursion to larger x, need to check for overflow first though:
        if (Math.log(z + iter) * minus_m_minus_one > -Precision.log_max_value()) {
            for (var k = 1; k <= iter; k++) {
                z_plus_k_pow_minus_m_minus_one = Math.pow(z, minus_m_minus_one);
                sum0 += z_plus_k_pow_minus_m_minus_one;
                z += 1;
            }
            sum0 *= UncheckedFactorial.unchecked_factorial(n);
        }
        else {
            for (var k = 1; k <= iter; k++) {
                var log_term = Math.log(z) * minus_m_minus_one + Gamma.lgamma(n + 1).result;
                sum0 += Math.exp(log_term);
                z += 1;
            }
        }
        if ((n - 1) & 1) {
            sum0 = -sum0;
        }
        return sum0 + Polygamma.polygamma_atinfinityplus(n, z);
    };
    Polygamma.polygamma_nearzero = function (n, x) {
        //
        // If we take this expansion for polygamma:
        //    http://functions.wolfram.com/06.15.06.0003.02
        // and substitute in this expression for polygamma(n, 1):
        //    http://functions.wolfram.com/06.15.03.0009.01
        // we get an alternating series for polygamma when x is small in terms of zeta
        // functions of integer arguments (which are easy to evaluate, at least when the
        // integer is even).
        //
        // In order to avoid spurious overflow, save the n! term for later, and rescale at the
        // end:
        //
        var scale = UncheckedFactorial.unchecked_factorial(n);
        //
        // "factorial_part" contains everything except the zeta function
        // evaluations in each term:
        //
        var factorial_part = 1;
        //
        // "prefix" is what we'll be adding the accumulated sum to, it will
        // be n! / z^(n+1), but since we're scaling by n! it's just
        // 1 / z^(n+1) for now:
        //
        var prefix = Math.pow(x, n + 1);
        if (prefix === 0) {
            throw new Error("Overflow error");
        }
        prefix = 1 / prefix;
        //
        // First term in the series is necessarily < zeta(2) < 2, so
        // ignore the sum if it will have no effect on the result anyway:
        //
        if (prefix > 2 / Precision.epsilon()) {
            if (Number.MAX_VALUE / prefix < scale) {
                throw new Error("Overflow error");
            }
            else {
                return ((n & 1) ? 1 : -1) * prefix * scale;
            }
        }
        //
        // As this is an alternating series we could accelerate it using
        // "Convergence Acceleration of Alternating Series",
        // Henri Cohen, Fernando Rodriguez Villegas, and Don Zagier, Experimental Mathematics, 1999.
        // In practice however, it appears not to make any difference to the number of terms
        // required except in some edge cases which are filtered out anyway before we get here.
        //
        var max_iter = 500;
        var sum = prefix;
        var k = 0;
        while (true) {
            // Get the k'th term:
            var term = factorial_part * Zeta.zeta(k + n + 1);
            sum += term;
            // Termination condition:
            if (Math.abs(term) < Math.abs(sum * Precision.epsilon())) {
                break;
            }
            //
            // Move on k and factorial_part:
            //
            k++;
            factorial_part *= (-x * (n + k)) / k;
            //
            // Last chance exit:
            //
            if (k > max_iter) {
                throw new Error("Evaluation error: Series did not converge, best value is " + sum);
            }
        }
        //
        // We need to multiply by the scale, at each stage checking for oveflow:
        //
        if (Number.MAX_VALUE / scale < sum) {
            throw new Error("Overflow error");
        }
        sum *= scale;
        return n & 1 ? sum : -sum;
    };
    Polygamma.poly_cot_pi = function (n, x, xc) {
        // Return n'th derivative of cot(pi*x) at x, these are simply
        // tabulated for up to n = 9, beyond that it is possible to
        // calculate coefficients as follows:
        //
        // The general form of each derivative is:
        //
        // pi^n * SUM{k=0, n} C[k,n] * cos^k(pi * x) * csc^(n+1)(pi * x)
        //
        // With constant C[0,1] = -1 and all other C[k,n] = 0;
        // Then for each k < n+1:
        // C[k-1, n+1]  -= k * C[k, n];
        // C[k+1, n+1]  += (k-n-1) * C[k, n];
        //
        // Note that there are many different ways of representing this derivative thanks to
        // the many trigomonetric identies available.  In particular, the sum of powers of
        // cosines could be replaced by a sum of cosine multiple angles, and indeed if you
        // plug the derivative into Mathematica this is the form it will give.  The two
        // forms are related via the Chebeshev polynomials of the first kind and
        // T_n(cos(x)) = cos(n x).  The polynomial form has the great advantage that
        // all the cosine terms are zero at half integer arguments - right where this
        // function has it's minumum - thus avoiding cancellation error in this region.
        //
        // And finally, since every other term in the polynomials is zero, we can save
        // space by only storing the non-zero terms.  This greatly complexifies
        // subscripting the tables in the calculation, but halves the storage space
        // (and complexity for that matter).
        //
        var LOGS_CUTOFF = 171;
        var MAX_N = 5000;
        var useLogs = n > LOGS_CUTOFF;
        var s = Math.abs(x) < Math.abs(xc) ? SinPI.sin_pi(x) : SinPI.sin_pi(xc);
        var c = CosPI.cos_pi(x);
        var P = Polygamma.coefs(n, useLogs);
        if (!useLogs) {
            var result = Math.pow(Math.PI, n) * (n % 2 === 0 ? c : 1) *
                Rational.evaluate_even_polynomial(P, c) / Math.pow(s, n + 1);
            if (isFinite(result)) {
                return result;
            }
        }
        //
        // We'll have to compute the coefficients up to n,
        // complexity is O(n^2) which we don't worry about for now
        // as the values are computed once and then cached.
        // However, if the final evaluation would have too many
        // terms just bail out right away:
        //
        if (n > MAX_N) {
            throw new Error("Evaluation error: The value of n is so large that we're" + "" + " unable to compute the result in reasonable time, best guess is " + 0);
        }
        var sum = Rational.evaluate_even_polynomial(P, c);
        if (n % 2 === 0) {
            sum *= c; // First coefficient is order 1, and really an odd polynomial.
        }
        if (sum === 0) {
            return sum;
        }
        //
        // The remaining terms are computed using logs since the powers and factorials
        // get real large real quick:
        //
        var power_terms = n * Constants.LNPI();
        if (s === 0) {
            throw new Error("Overflow error");
        }
        power_terms -= Math.log(Math.abs(s)) * (n + 1);
        power_terms += Gamma.lgamma(n).result;
        power_terms += Math.log(Math.abs(sum));
        if (power_terms > Precision.log_max_value()) {
            throw new Error("Overflow error");
        }
        return Math.exp(power_terms) * ((s < 0) && ((n + 1) & 1) ? -1 : 1) * Sign.sign(sum);
    };
    Polygamma.coefs = function (n, scaled) {
        var table = [[-1]];
        var index = n - 1;
        if (index >= table.length) {
            for (var i = table.length - 1; i < index; ++i) {
                var offset = i & 1; // 1 if the first cos power is 0, otherwise 0.
                var sin_order = i + 2; // order of the sin term
                var max_cos_order = sin_order - 1; // largest order of the polynomial of cos
                // terms
                var max_columns = Math.trunc((max_cos_order - offset) / 2); // How many entries
                // there are in the
                // current row.
                var next_offset = offset ? 0 : 1;
                // How many entries there will be in the next row
                var next_max_columns = Math.trunc((max_cos_order + 1 - next_offset) / 2);
                // add array of next_max_columns+1 0's to table
                table.push(Array.apply(null, Array(next_max_columns + 1)).map(Number.prototype.valueOf, 0));
                for (var column = 0; column <= max_columns; ++column) {
                    var cos_order = 2 * column + offset; // order of the cosine term in entry
                    // "column"
                    table[i + 1][Math.trunc((cos_order + 1) / 2)] +=
                        (((cos_order - sin_order) * table[i][column]) / (scaled ? sin_order - 1 : 1));
                    if (cos_order) {
                        table[i + 1][Math.trunc((cos_order - 1) / 2)] +=
                            ((-cos_order * table[i][column]) / (scaled ? sin_order - 1 : 1));
                    }
                }
            }
        }
        return table[index];
    };
    Polygamma.polygamma_imp = function (n, x) {
        if (n < 0) {
            throw new Error("Domain error: Order must be >= 0, but got " + n);
        }
        if (x < 0) {
            if (Math.floor(x) === x) {
                //
                // Result is infinity if x is odd, and a pole error if x is even.
                //
                if (Math.trunc(x) & 1) {
                    throw new Error("Overflow error");
                }
                else {
                    throw new Error("Pole error: Evaluation at negative even integer " + x);
                }
            }
            var z = 1 - x;
            var result = Polygamma.polygamma_imp(n, z) +
                Math.PI * Polygamma.poly_cot_pi(n, z, x);
            return n & 1 ? -result : result;
        }
        //
        // Limit for use of small-x-series is chosen
        // so that the series doesn't go too divergent
        // in the first few terms.  Ordinarily this
        // would mean setting the limit to ~ 1 / n,
        // but we can tolerate a small amount of divergence:
        //
        var small_x_limit = Math.min(5 / n, 0.25);
        if (x < small_x_limit) {
            return Polygamma.polygamma_nearzero(n, x);
        }
        else if (x > 0.4 * 17 + 4.0 * n) {
            return Polygamma.polygamma_atinfinityplus(n, x);
        }
        else if (x === 1) {
            return (n & 1 ? 1 : -1) * UncheckedFactorial.unchecked_factorial(n) *
                Zeta.zeta(n + 1);
        }
        else if (x === 0.5) {
            var result = (n & 1 ? 1 : -1) * UncheckedFactorial.unchecked_factorial(n) *
                Zeta.zeta(n + 1);
            if (Math.abs(result) >= Number.MAX_VALUE * Math.pow(2, -n - 1)) {
                throw new Error("Overflow error");
            }
            result *= Math.pow(2, n + 1) - 1;
            return result;
        }
        else {
            return Polygamma.polygamma_attransitionplus(n, x);
        }
    };
    Polygamma.polygamma = function (n, x) {
        //
        // Filter off digamma case right at the start:
        //
        if (n === 0) {
            return Digamma.digamma(x);
        }
        return Polygamma.polygamma_imp(n, x);
    };
    return Polygamma;
}());
exports.Polygamma = Polygamma;
