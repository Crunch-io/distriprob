"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright John Maddock 2006, 2010.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var UncheckedFactorial = require("./detail/unchecked_factorial").UncheckedFactorial;
var check = require("../../errorHandling").check;
var Gamma = require("./gamma").Gamma;
var Constants = require("../tools/constants").Constants;
var Factorial = /** @class */ (function () {
    function Factorial() {
    }
    Factorial.factorial = function (n) {
        check(n, "n", "factorial", "nonnegative_integer");
        if (n > UncheckedFactorial.max_factorial()) {
            throw new Error("Overflow error");
        }
        return UncheckedFactorial.unchecked_factorial(n);
    };
    Factorial.double_factorial = function (n) {
        check(n, "n", "double factorial", "nonnegative_integer");
        if (n & 1) {
            // odd i:
            if (n < UncheckedFactorial.max_factorial()) {
                var i = (n - 1) / 2;
                return Math.ceil(UncheckedFactorial.unchecked_factorial(n) / (Math.pow(2, i)
                    * UncheckedFactorial.unchecked_factorial(i)) - 0.5);
            }
            //
            // Fallthrough: i is too large to use table lookup, try the
            // gamma function instead.
            //
            var result = Gamma.tgamma(n / 2 + 1) / Constants.SQRTPI();
            if (Number.MAX_VALUE * Math.pow(2, -(n + 1) / 2) > result) {
                return Math.ceil(result * Math.pow(2, (n + 1) / 2) - 0.5);
            }
        }
        else {
            // even i:
            var i = n / 2;
            if (i < UncheckedFactorial.max_factorial()) {
                var result = UncheckedFactorial.unchecked_factorial(i);
                if (Number.MAX_VALUE * Math.pow(2, -i) > result) {
                    return result * Math.pow(2, i);
                }
            }
        }
        //
        // If we fall through to here then the result is an overflow error:
        //
        throw new Error("Overflow error");
    };
    Factorial.rising_factorial = function (x, n) {
        check(n, "n", "rising factorial", "integer");
        if (x < 0) {
            //
            // For x less than zero, we really have a falling
            // factorial, modulo a possible change of sign.
            //
            // Note that the falling factorial isn't defined
            // for negative n, so we'll get rid of that case
            // first:
            //
            var inv = false;
            if (n < 0) {
                x += n;
                n = -n;
                inv = true;
            }
            var result = ((n & 1) ? -1 : 1) * Factorial.falling_factorial(-x, n);
            if (inv) {
                result = 1 / result;
            }
            return result;
        }
        if (n === 0) {
            return 1;
        }
        if (x === 0) {
            if (n < 0) {
                return -Gamma.tgamma_delta_ratio(x + 1, -n);
            }
            else {
                return 0;
            }
        }
        if ((x < 1) && (x + n < 0)) {
            var val = Gamma.tgamma_delta_ratio(1 - x, -n);
            return (n & 1) ? -val : val;
        }
        //
        // We don't optimise this for small n, because
        // tgamma_delta_ratio is alreay optimised for that
        // use case:
        //
        return 1 / Gamma.tgamma_delta_ratio(x, n);
    };
    Factorial.falling_factorial = function (x, n) {
        check(n, "n", "falling factorial", "integer");
        if ((x === 0) && (n >= 0)) {
            return 0;
        }
        if (x < 0) {
            //
            // For x < 0 we really have a rising factorial
            // modulo a possible change of sign:
            //
            return (n & 1 ? -1 : 1) * Factorial.rising_factorial(-x, n);
        }
        if (n === 0) {
            return 1;
        }
        if (x < 0.5) {
            //
            // 1 + x below will throw away digits, so split up calculation:
            //
            if (n > UncheckedFactorial.max_factorial() - 2) {
                // If the two end of the range are far apart we have a ratio of two very large
                // numbers, split the calculation up into two blocks:
                var t1 = x * Factorial.falling_factorial(x - 1, UncheckedFactorial.max_factorial() - 2);
                var t2 = Factorial.falling_factorial(x - UncheckedFactorial.max_factorial() + 1, n - UncheckedFactorial.max_factorial() + 1);
                if (Number.MAX_VALUE / Math.abs(t1) < Math.abs(t2)) {
                    throw new Error("Overflow error");
                }
                return t1 * t2;
            }
            return x * Factorial.falling_factorial(x - 1, n - 1);
        }
        if (x <= n - 1) {
            //
            // x+1-n will be negative and tgamma_delta_ratio won't
            // handle it, split the product up into three parts:
            //
            var xp1 = x + 1;
            var n2 = Math.trunc(Math.floor(xp1));
            if (n2 === xp1) {
                return 0;
            }
            var result = Gamma.tgamma_delta_ratio(xp1, -n2);
            x -= n2;
            result *= x;
            ++n2;
            if (n2 < n) {
                result *= Factorial.falling_factorial(x - 1, n - n2);
            }
            return result;
        }
        //
        // Simple case: just the ratio of two
        // (positive argument) gamma functions.
        // Note that we don't optimise this for small n,
        // because tgamma_delta_ratio is alreay optimised
        // for that use case:
        //
        return Gamma.tgamma_delta_ratio(x + 1, -n);
    };
    return Factorial;
}());
exports.Factorial = Factorial;
