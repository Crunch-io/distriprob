"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright Benjamin Sobotta 2012.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var OwensT = require("./boostPorts/special_functions/owens_t").OwensT;
var NormalDist = require("./normalDist").NormalDist;
var ErfInv = require("./boostPorts/special_functions/detail/erf_inv").ErfInv;
var Constants = require("./boostPorts/tools/constants").Constants;
var Roots = require("./boostPorts/tools/roots").Roots;
var Random = require("./random").Random;
var check = require("./errorHandling").check;
var SkewNormalDist = /** @class */ (function () {
    function SkewNormalDist() {
    }
    SkewNormalDist.checkParameters = function (functionName, location, scale, shape, x, lowerTail, p, n, seed) {
        var params = {
            location: NaN,
            scale: NaN,
            shape: NaN,
            lowerTail: undefined
        };
        check(location, "location", "skew normal distribution " + functionName, "real");
        if (typeof location !== "undefined" && location !== null) {
            check(location, "location", "skew normal distribution " + functionName, "real");
            params.location = location;
        }
        else {
            params.location = 0;
        }
        if (typeof scale !== "undefined" && scale !== null) {
            check(scale, "scale", "skew normal distribution " + functionName, "positive-real");
            params.scale = scale;
        }
        else {
            params.scale = 1;
        }
        if (typeof shape !== "undefined" && shape !== null) {
            check(shape, "shape", "skew normal distribution " + functionName, "real");
            params.shape = shape;
        }
        else {
            params.shape = 0;
        }
        if (typeof x !== "undefined") {
            check(x, "x", "skew normal distribution " + functionName, "real");
        }
        if (typeof lowerTail !== "undefined" && lowerTail !== null) {
            check(lowerTail, "lowerTail", "skew normal distribution " + functionName, "boolean");
            params.lowerTail = lowerTail;
        }
        else {
            params.lowerTail = true;
        }
        if (typeof p !== "undefined") {
            check(p, "p", "skew normal distribution " + functionName, "probability");
        }
        if (typeof n !== "undefined") {
            check(n, "n", "skew normal distribution " + functionName, "nonnegative_integer");
        }
        if (typeof seed !== "undefined" && seed !== null) {
            check(seed, "seed", "skew normal distribution " + functionName, "seed");
        }
        return params;
    };
    SkewNormalDist.pdf = function (x, location, scale, shape) {
        // first error checking
        var params = SkewNormalDist.checkParameters("pdf", location, scale, shape, x);
        if (x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
            return 0; // pdf + and - infinity is zero.
        }
        var transformed_x = (x - params.location) / params.scale;
        return NormalDist.pdf(transformed_x) * NormalDist.cdf(params.shape * transformed_x) *
            2 / params.scale;
    };
    SkewNormalDist.cdf = function (x, location, scale, shape, lowerTail) {
        // first error checking
        var params = SkewNormalDist.checkParameters("cdf", location, scale, shape, x, lowerTail);
        if (x === Number.NEGATIVE_INFINITY) {
            if (params.lowerTail) {
                return 0;
            }
            else {
                return 1;
            }
        }
        if (x === Number.POSITIVE_INFINITY) {
            if (params.lowerTail) {
                return 1;
            }
            else {
                return 0;
            }
        }
        var transformed_x = (x - params.location) / params.scale;
        if (params.lowerTail) {
            return NormalDist.cdf(transformed_x) -
                OwensT.owens_t(transformed_x, params.shape) * 2;
        }
        else {
            return NormalDist.cdf(transformed_x, 0, 1, false) +
                OwensT.owens_t(transformed_x, params.shape) * 2;
        }
    };
    SkewNormalDist.mean = function (location, scale, shape) {
        return location + scale * shape / Math.sqrt(Math.PI + Math.PI * shape * shape) *
            Constants.SQRT2();
    };
    SkewNormalDist.variance = function (scale, shape) {
        var delta2 = 1 / (1 + 1 / (shape * shape));
        return scale * scale * (1 - Constants.TWODIVPI() * delta2);
    };
    SkewNormalDist.standard_deviation = function (scale, shape) {
        return Math.sqrt(SkewNormalDist.variance(scale, shape));
    };
    SkewNormalDist.skewness = function (shape) {
        var factor = (4 - Math.PI) / 2;
        var delta = shape / Math.sqrt(1 + shape * shape);
        return factor * Math.pow(Constants.SQRTTWODIVPI() * delta, 3) /
            Math.pow(1 - Constants.TWODIVPI() * delta * delta, 1.5);
    };
    SkewNormalDist.kurtosis_excess = function (shape) {
        var factor = (Math.PI - 3) * 2;
        var delta2 = 1 / (1 + 1 / (shape * shape));
        var x = 1 - Constants.TWODIVPI() * delta2;
        var y = Constants.TWODIVPI() * delta2;
        return factor * y * y / (x * x);
    };
    SkewNormalDist.skew_normal_quantile_functor = function (location, scale, shape, p) {
        return function (x) {
            var c = SkewNormalDist.cdf(x, location, scale, shape, true);
            var fx = c - p;
            var dx = SkewNormalDist.pdf(x, location, scale, shape);
            return { f0: fx, f1: dx };
        };
    };
    SkewNormalDist.quantile = function (p, location, scale, shape, lowerTail) {
        // first error checking
        var params = SkewNormalDist.checkParameters("quantile", location, scale, shape, undefined, lowerTail, p);
        if (p === 0) {
            if (params.lowerTail) {
                return Number.NEGATIVE_INFINITY;
            }
            else {
                return Number.POSITIVE_INFINITY;
            }
        }
        else if (p === 1) {
            if (params.lowerTail) {
                return Number.POSITIVE_INFINITY;
            }
            else {
                return Number.NEGATIVE_INFINITY;
            }
        }
        else {
            if (!params.lowerTail) {
                return SkewNormalDist.quantile(p, -params.location, params.scale, -params.shape, true);
            }
            var result = void 0;
            // Compute initial guess via Cornish-Fisher expansion.
            var x = -ErfInv.erfc_inv(2 * p) * Constants.SQRT2();
            // Avoid unnecessary computations if there is no skew.
            if (params.shape !== 0) {
                var skew = SkewNormalDist.skewness(params.shape);
                var exk = SkewNormalDist.kurtosis_excess(params.shape);
                x = x + (x * x - 1) * skew / 6 + x * (x * x - 3) * exk / 24 - x * (2 * x * x - 5) * skew * skew / 36;
            }
            result = SkewNormalDist.standard_deviation(params.scale, params.shape) * x +
                SkewNormalDist.mean(params.location, params.scale, params.shape);
            // handle special case of non-skew normal distribution.
            if (params.shape === 0) {
                return result;
            }
            // refine the result by numerically searching the root of (p-cdf)
            var search_min = Number.NEGATIVE_INFINITY;
            var search_max = Number.POSITIVE_INFINITY;
            var get_digits = 53;
            var max_iter = 50;
            var functor = SkewNormalDist.skew_normal_quantile_functor(params.location, params.scale, params.shape, p);
            result = Roots.newton_raphson_iterate(functor, result, search_min, search_max, get_digits, max_iter);
            return result.result;
        }
    };
    SkewNormalDist.random = function (n, location, scale, shape, seed) {
        // first error checking
        var params = SkewNormalDist.checkParameters("random", location, scale, shape, undefined, undefined, undefined, n, seed);
        return Random.numbers(n, SkewNormalDist.quantile, [params.location, params.scale, params.shape, true], seed);
    };
    SkewNormalDist.randomIterator = function (n, location, scale, shape, seed) {
        if (typeof n === "undefined" || n === null) {
            n = Number.POSITIVE_INFINITY;
        }
        // first error checking
        var params = SkewNormalDist.checkParameters("random", location, scale, shape, undefined, undefined, undefined, n, seed);
        return Random.numberIterator(n, SkewNormalDist.quantile, [params.location, params.scale, params.shape, true], seed);
    };
    return SkewNormalDist;
}());
exports.SkewNormalDist = SkewNormalDist;
