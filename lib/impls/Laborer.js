"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * (C) Copyright Zachary Martin 2016.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
var spawn = require("threads").spawn;
var Laborer = /** @class */ (function () {
    function Laborer() {
        var _this = this;
        this.resolutionQueue = [];
        this.thread = spawn(Laborer.createScriptFunction(Laborer.DEPENDENCIES));
        this.thread.on("message", function (response) {
            _this.resolve(response);
        });
        this.dead = false;
    }
    Laborer.prototype.sendMessageToThread = function (msg) {
        var _this = this;
        if (this.dead) {
            return Promise.reject(new Error("Worker thread is dead, cannot assign work"));
        }
        this.thread.send(msg);
        return new Promise(function (resolve, reject) {
            _this.resolutionQueue.push({ resolve: resolve, reject: reject });
        });
    };
    Laborer.prototype.resolve = function (value) {
        var resolution = this.resolutionQueue.shift();
        if (this.dead && this.resolutionQueue.length === 0) {
            this.thread.kill();
        }
        if (resolution) {
            if (value === "ready") {
                resolution.resolve();
            }
            else if (value && value.error) {
                resolution.reject(new Error(value.message));
            }
            else {
                resolution.resolve(value);
            }
        }
    };
    Laborer.prototype.terminate = function () {
        this.dead = true;
        if (this.resolutionQueue.length === 0) {
            this.thread.kill();
        }
    };
    Laborer.createScriptFunction = function (dependencies) {
        var body = "";
        for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
            var dependency = dependencies_1[_i];
            if (typeof dependency === "function") {
                body += dependency.toString() + "\n";
            }
            else if (typeof dependency === "object") {
                for (var prop in dependency) {
                    body += "const " + prop + " = " + JSON.stringify(dependency[prop]) + ";\n";
                }
            }
        }
        body += "\n      if (typeof cache === \"undefined\") {\n        cache = new Cache();\n      }\n      if (typeof hypergeometricDist === \"undefined\") {\n        hypergeometricDist = new HypergeometricDist(cache); \n      }\n    ";
        body += "\n      let result; \n      try{\n        result = eval(input)\n      } catch(e) {\n        result = {\n          error: true,\n          message: e.message,\n          stack: e.stack\n        };\n      }\n      done(result);\n    ";
        return new Function("input", "done", body);
    };
    Object.defineProperty(Laborer.prototype, "ready", {
        get: function () {
            return this.sendMessageToThread("\"ready\"");
        },
        enumerable: true,
        configurable: true
    });
    Laborer.prototype.getThreadPromise = function (className, functionName, args) {
        var msg = className + "." + functionName + "(";
        for (var i = 0; i < args.length; i++) {
            var argStr = void 0;
            if (typeof args[i] === "number") {
                argStr = args[i] + "";
            }
            else if (typeof args[i] === "string") {
                argStr = "\"" + args[i] + "\"";
            }
            else {
                argStr = JSON.stringify(args[i]);
            }
            if (i !== args.length - 1) {
                msg += argStr + ", ";
            }
            else {
                msg += argStr + ")";
            }
        }
        return this.sendMessageToThread(msg);
    };
    Object.defineProperty(Laborer.prototype, "beta", {
        get: function () {
            var that = this;
            var betaDistClassName = "BetaDist";
            return {
                pdf: function (x, alpha, beta, ncp) {
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(betaDistClassName, "pdf", arguments);
                },
                cdf: function (x, alpha, beta, lowerTail, ncp) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(betaDistClassName, "cdf", arguments);
                },
                quantile: function (x, alpha, beta, lowerTail, ncp) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(betaDistClassName, "quantile", arguments);
                },
                random: function (n, alpha, beta, ncp, seed) {
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(betaDistClassName, "random", arguments);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Laborer.prototype, "binomial", {
        get: function () {
            var that = this;
            var binomialDistClassName = "BinomialDist";
            return {
                pdf: function (k, trials, probSuccess) {
                    return that.getThreadPromise(binomialDistClassName, "pdf", arguments);
                },
                cdf: function (k, trials, probSuccess, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(binomialDistClassName, "cdf", arguments);
                },
                quantile: function (p, trials, probSuccess, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(binomialDistClassName, "quantile", arguments);
                },
                random: function (n, trials, probSuccess, seed) {
                    return that.getThreadPromise(binomialDistClassName, "random", arguments);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Laborer.prototype, "chi2", {
        get: function () {
            var that = this;
            var chi2DistClassName = "ChiSquaredDist";
            return {
                pdf: function (x, degreesOfFreedom, ncp) {
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(chi2DistClassName, "pdf", arguments);
                },
                cdf: function (x, degreesOfFreedom, lowerTail, ncp) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(chi2DistClassName, "cdf", arguments);
                },
                quantile: function (p, degreesOfFreedom, lowerTail, ncp) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(chi2DistClassName, "quantile", arguments);
                },
                random: function (n, degreesOfFreedom, ncp, seed) {
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(chi2DistClassName, "random", arguments);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Laborer.prototype, "exponential", {
        get: function () {
            var that = this;
            var expDistClassName = "ExponentialDist";
            return {
                pdf: function (x, lambda) {
                    return that.getThreadPromise(expDistClassName, "pdf", arguments);
                },
                cdf: function (x, lambda, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(expDistClassName, "cdf", arguments);
                },
                quantile: function (p, lambda, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(expDistClassName, "quantile", arguments);
                },
                random: function (n, lambda, seed) {
                    return that.getThreadPromise(expDistClassName, "random", arguments);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Laborer.prototype, "F", {
        get: function () {
            var that = this;
            var fDistClassName = "FDist";
            return {
                pdf: function (x, dof1, dof2, ncp) {
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(fDistClassName, "pdf", arguments);
                },
                cdf: function (x, dof1, dof2, lowerTail, ncp) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(fDistClassName, "cdf", arguments);
                },
                quantile: function (p, dof1, dof2, lowerTail, ncp) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(fDistClassName, "quantile", arguments);
                },
                random: function (n, dof1, dof2, ncp, seed) {
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(fDistClassName, "random", arguments);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Laborer.prototype, "gamma", {
        get: function () {
            var that = this;
            var gammaDistClassName = "GammaDist";
            return {
                pdf: function (x, shape, scale) {
                    return that.getThreadPromise(gammaDistClassName, "pdf", arguments);
                },
                cdf: function (x, shape, scale, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(gammaDistClassName, "cdf", arguments);
                },
                quantile: function (p, shape, scale, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(gammaDistClassName, "quantile", arguments);
                },
                random: function (n, shape, scale, seed) {
                    return that.getThreadPromise(gammaDistClassName, "random", arguments);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Laborer.prototype, "hypergeometric", {
        get: function () {
            var that = this;
            var hypergeoClass = "hypergeometricDist";
            return {
                pdf: function (sampleSuccesses, draws, successPop, totalPop) {
                    return that.getThreadPromise(hypergeoClass, "pdf", arguments);
                },
                cdf: function (sampleSuccesses, draws, successPop, totalPop, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(hypergeoClass, "cdf", arguments);
                },
                quantile: function (p, draws, successPop, totalPop, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(hypergeoClass, "quantile", arguments);
                },
                random: function (n, draws, successPop, totalPop, seed) {
                    return that.getThreadPromise(hypergeoClass, "random", arguments);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Laborer.prototype, "negativeBinomial", {
        get: function () {
            var that = this;
            var negativeBinomialClass = "NegativeBinomialDist";
            return {
                pdf: function (numFailures, numSuccesses, probSuccess) {
                    return that.getThreadPromise(negativeBinomialClass, "pdf", arguments);
                },
                cdf: function (numFailures, numSuccesses, probSuccess, lowerTail) {
                    return that.getThreadPromise(negativeBinomialClass, "cdf", arguments);
                },
                quantile: function (p, numSuccesses, probSuccess, lowerTail) {
                    return that.getThreadPromise(negativeBinomialClass, "quantile", arguments);
                },
                random: function (n, numSuccesses, probSuccess, seed) {
                    return that.getThreadPromise(negativeBinomialClass, "random", arguments);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Laborer.prototype, "normal", {
        get: function () {
            var that = this;
            var normalDistClassName = "NormalDist";
            return {
                pdf: function (x, mu, sigma) {
                    return that.getThreadPromise(normalDistClassName, "pdf", arguments);
                },
                cdf: function (x, mu, sigma, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(normalDistClassName, "cdf", arguments);
                },
                quantile: function (p, mu, sigma, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(normalDistClassName, "quantile", arguments);
                },
                random: function (n, mu, sigma, seed) {
                    return that.getThreadPromise(normalDistClassName, "random", arguments);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Laborer.prototype, "poisson", {
        get: function () {
            var that = this;
            var poissonDistClassName = "PoissonDist";
            return {
                pdf: function (k, lambda) {
                    return that.getThreadPromise(poissonDistClassName, "pdf", arguments);
                },
                cdf: function (k, lambda, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(poissonDistClassName, "cdf", arguments);
                },
                quantile: function (p, lambda, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(poissonDistClassName, "quantile", arguments);
                },
                random: function (n, lambda, seed) {
                    return that.getThreadPromise(poissonDistClassName, "random", arguments);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Laborer.prototype, "skewNormal", {
        get: function () {
            var that = this;
            var skewNormalDistClass = "SkewNormalDist";
            return {
                pdf: function (x, location, scale, shape) {
                    return that.getThreadPromise(skewNormalDistClass, "pdf", arguments);
                },
                cdf: function (x, location, scale, shape, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(skewNormalDistClass, "cdf", arguments);
                },
                quantile: function (p, location, scale, shape, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(skewNormalDistClass, "quantile", arguments);
                },
                random: function (n, location, scale, shape, seed) {
                    return that.getThreadPromise(skewNormalDistClass, "random", arguments);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Laborer.prototype, "t", {
        get: function () {
            var that = this;
            var tDistClass = "StudentsTDist";
            return {
                pdf: function (x, degreesOfFreedom, ncp) {
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(tDistClass, "pdf", arguments);
                },
                cdf: function (x, degreesOfFreedom, lowerTail, ncp) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(tDistClass, "cdf", arguments);
                },
                quantile: function (p, degreesOfFreedom, lowerTail, ncp) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(tDistClass, "quantile", arguments);
                },
                random: function (n, degreesOfFreedom, ncp, seed) {
                    if (ncp === void 0) { ncp = 0; }
                    return that.getThreadPromise(tDistClass, "random", arguments);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Laborer.prototype, "uniform", {
        get: function () {
            var that = this;
            var uniformDistClassName = "UniformDist";
            return {
                pdf: function (x, lowerSupportBound, upperSupportBound) {
                    return that.getThreadPromise(uniformDistClassName, "pdf", arguments);
                },
                cdf: function (x, lowerSupportBound, upperSupportBound, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(uniformDistClassName, "cdf", arguments);
                },
                quantile: function (x, lowerSupportBound, upperSupportBound, lowerTail) {
                    if (lowerTail === void 0) { lowerTail = true; }
                    return that.getThreadPromise(uniformDistClassName, "quantile", arguments);
                },
                random: function (n, lowerSupportBound, upperSupportBound, seed) {
                    return that.getThreadPromise(uniformDistClassName, "random", arguments);
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    Laborer.DEPENDENCIES = [
        // boostPorts/distributions
        require("./boostPorts/distributions/detail/generic_quantile").GenericQuantile,
        require("./boostPorts/distributions/detail/hypergeometric_cdf").HypergeometricCDF,
        require("./boostPorts/distributions/detail/hypergeometric_pdf").HypergeometricPDF,
        require("./boostPorts/distributions/detail/hypergeometric_quantile").HypergeometricQuantile,
        require("./boostPorts/distributions/detail/inv_discrete_quantile").InvDiscreteQuantile,
        require("./boostPorts/distributions/non_central_beta").NonCentralBeta,
        require("./boostPorts/distributions/non_central_chi_squared").NonCentralChiSquared,
        require("./boostPorts/distributions/non_central_t").NonCentralT,
        // boostPorts/special_functions
        require("./boostPorts/special_functions/airy").Airy,
        require("./boostPorts/special_functions/bernoulli").Bernoulli,
        require("./boostPorts/special_functions/bessel").Bessel,
        require("./boostPorts/special_functions/bessel_prime").BoostBesselPrime,
        require("./boostPorts/special_functions/beta").Beta,
        require("./boostPorts/special_functions/cos_pi").CosPI,
        require("./boostPorts/special_functions/detail/bessel_derivatives_linear").BesselDerivativesLinear,
        require("./boostPorts/special_functions/detail/bessel_i0").BesselI0,
        require("./boostPorts/special_functions/detail/bessel_i1").BesselI1,
        require("./boostPorts/special_functions/detail/bessel_ik").BesselIK,
        require("./boostPorts/special_functions/detail/bessel_j0").BesselJ0,
        require("./boostPorts/special_functions/detail/bessel_j1").BesselJ1,
        require("./boostPorts/special_functions/detail/bessel_jn").BesselJN,
        require("./boostPorts/special_functions/detail/bessel_jy").BesselJY,
        require("./boostPorts/special_functions/detail/bessel_jy_asym").BesselJYAsym,
        require("./boostPorts/special_functions/detail/bessel_jy_derivatives_asym").BesselJYDerivativesAsym,
        require("./boostPorts/special_functions/detail/bessel_jy_derivatives_series").BesselJYDerivativesSeries,
        require("./boostPorts/special_functions/detail/bessel_jy_series").BesselJYSeries,
        require("./boostPorts/special_functions/detail/bessel_jy_zero").BesselJYZero,
        require("./boostPorts/special_functions/detail/bessel_k0").BesselK0,
        require("./boostPorts/special_functions/detail/bessel_k1").BesselK1,
        require("./boostPorts/special_functions/detail/bessel_kn").BesselKN,
        require("./boostPorts/special_functions/detail/bessel_y0").BesselY0,
        require("./boostPorts/special_functions/detail/bessel_y1").BesselY1,
        require("./boostPorts/special_functions/detail/bessel_yn").BesselYN,
        require("./boostPorts/special_functions/detail/erf_inv").ErfInv,
        require("./boostPorts/special_functions/detail/gamma_inva").GammaInvA,
        require("./boostPorts/special_functions/detail/ibeta_inv_ab").IBetaInvAB,
        require("./boostPorts/special_functions/detail/ibeta_inverse").IBetaInverse,
        require("./boostPorts/special_functions/detail/igamma_inverse").IGammaInverse,
        require("./boostPorts/special_functions/detail/igamma_large").IGammaLarge,
        require("./boostPorts/special_functions/detail/lgamma_small").LGammaSmall,
        require("./boostPorts/special_functions/detail/t_distribution_inv").InverseStudentsT,
        require("./boostPorts/special_functions/detail/unchecked_bernoulli").UncheckedBernoulli,
        require("./boostPorts/special_functions/detail/unchecked_factorial").UncheckedFactorial,
        require("./boostPorts/special_functions/digamma").Digamma,
        require("./boostPorts/special_functions/erf").Erf,
        require("./boostPorts/special_functions/expm1").Expm1,
        require("./boostPorts/special_functions/factorial").Factorial,
        require("./boostPorts/special_functions/gamma").Gamma,
        require("./boostPorts/special_functions/hypot").Hypot,
        require("./boostPorts/special_functions/lanczos").Lanczos,
        require("./boostPorts/special_functions/log1p").Log1p,
        require("./boostPorts/special_functions/owens_t").OwensT,
        require("./boostPorts/special_functions/polygamma").Polygamma,
        require("./boostPorts/special_functions/powm1").Powm1,
        require("./boostPorts/special_functions/sign").Sign,
        require("./boostPorts/special_functions/sin_pi").SinPI,
        require("./boostPorts/special_functions/sinc").Sinc,
        require("./boostPorts/special_functions/zeta").Zeta,
        // boostPorts/tools
        require("./boostPorts/tools/constants").Constants,
        require("./boostPorts/tools/fraction").Fraction,
        require("./boostPorts/tools/precision").Precision,
        require("./boostPorts/tools/rational").Rational,
        require("./boostPorts/tools/roots").Roots,
        require("./boostPorts/tools/series").Series,
        require("./boostPorts/tools/toms748_solve").Toms748,
        // ./
        require("./betaDist").BetaDist,
        require("./binomialDist").BinomialDist,
        require("./cache").Cache,
        require("./chiSquaredDist").ChiSquaredDist,
        require("./errorHandling").check,
        require("./exponentialDist").ExponentialDist,
        require("./fDist").FDist,
        require("./gammaDist").GammaDist,
        require("./hypergeometricDist").HypergeometricDist,
        require("./negativeBinomialDist").NegativeBinomialDist,
        require("./normalDist").NormalDist,
        require("./poissonDist").PoissonDist,
        require("./primeFactors").Primes,
        require("./random").Random,
        require("./skewNormalDist").SkewNormalDist,
        require("./studentsTDist").StudentsTDist,
        require("./uniformDist").UniformDist,
        require("./utility").Utility,
    ];
    return Laborer;
}());
exports.Laborer = Laborer;
