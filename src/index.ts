"use strict";

/**
 * (C) Copyright Zachary Martin 2016.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

import {Cache} from "./impls/cache";
const cache = new Cache();

import {BetaDist} from "./impls/betaDist";
import {BinomialDist} from "./impls/binomialDist";
import {ChiSquaredDist} from "./impls/chiSquaredDist";
import {ExponentialDist} from "./impls/exponentialDist";
import {FDist} from "./impls/fDist";
import {GammaDist} from "./impls/gammaDist";
import {HypergeometricDist} from "./impls/hypergeometricDist";
import {NormalDist} from "./impls/normalDist";
import {PoissonDist} from "./impls/poissonDist";
import {StudentsTDist} from "./impls/studentsTDist";
import {UniformDist} from "./impls/uniformDist";

import {Airy} from "./impls/boostPorts/special_functions/airy";
import {Bessel} from "./impls/boostPorts/special_functions/bessel";
import {BoostBesselPrime} from "./impls/boostPorts/special_functions/bessel_prime";
import {Beta} from "./impls/boostPorts/special_functions/beta";
import {IBetaInverse}
  from "./impls/boostPorts/special_functions/detail/ibeta_inverse";
import {IBetaInvAB} from "./impls/boostPorts/special_functions/detail/ibeta_inv_ab"
import {Factorial} from "./impls/boostPorts/special_functions/factorial";
import {Gamma} from "./impls/boostPorts/special_functions/gamma";
import {GammaInvA} from "./impls/boostPorts/special_functions/detail/gamma_inva";
import {IGammaInverse}
  from "./impls/boostPorts/special_functions/detail/igamma_inverse";
import {OwensT} from "./impls/boostPorts/special_functions/owens_t";
import {Polygamma} from "./impls/boostPorts/special_functions/polygamma";
import {Zeta} from "./impls/boostPorts/special_functions/zeta";
import {Erf} from "./impls/boostPorts/special_functions/erf";
import {ErfInv} from "./impls/boostPorts/special_functions/detail/erf_inv";

const hypergeometricDist = new HypergeometricDist(cache);

export const airy = {
  ai: function(x: number): number {
    return Airy.airy_ai(x);
  },
  aiPrime: function(x: number): number {
    return Airy.airy_ai_prime(x);
  },
  aiRoot: function(m: number): number {
    return Airy.airy_ai_zero(m);
  },
  aiRootIter: function(startIndex: number = 1, numRoots?: number):
    IterableIterator<number> {
    return Airy.airy_ai_zeros_iter(startIndex, numRoots);
  },
  bi: function(x: number): number {
    return Airy.airy_bi(x);
  },
  biPrime: function(x: number): number {
    return Airy.airy_bi_prime(x);
  },
  biRoot: function(m: number): number {
    return Airy.airy_bi_zero(m);
  },
  biRootIter: function(startIndex: number = 1, numRoots?: number):
    IterableIterator<number> {
    return Airy.airy_bi_zeros_iter(startIndex, numRoots);
  },
};

export const bessel = {
  i: function(v: number, x: number): number {
    return Bessel.cyl_bessel_i(v, x);
  },
  iPrime: function(v: number, x: number): number {
    return BoostBesselPrime.cyl_bessel_i_prime(v, x);
  },
  j: function(v: number, x: number): number {
    return Bessel.cyl_bessel_j(v, x);
  },
  jPrime: function(v: number, x: number): number {
    return BoostBesselPrime.cyl_bessel_j_prime(v, x);
  },
  jRoot: function(v: number, m: number): number {
    return Bessel.cyl_bessel_j_zero(v, m);
  },
  jRootIter: function(v: number, startIndex: number = 1, numRoots?: number):
    IterableIterator<number> {
    return Bessel.cyl_bessel_j_zeros_iter(v, startIndex, numRoots);
  },
  k: function(v: number, x: number): number {
    return Bessel.cyl_bessel_k(v, x);
  },
  kPrime: function(v: number, x: number): number {
    return BoostBesselPrime.cyl_bessel_k_prime(v, x);
  },
  y: function(v: number, x: number): number {
    return Bessel.cyl_neumann(v, x);
  },
  yPrime: function(v: number, x: number): number {
    return BoostBesselPrime.cyl_neumann_prime(v, x);
  },
  yRoot: function(v: number, m: number): number {
    return Bessel.cyl_neumann_zero(v, m);
  },
  yRootIter: function(v: number, startIndex: number = 1, numRoots?: number):
    IterableIterator<number> {
    return Bessel.cyl_neumann_zeros_iter(v, startIndex, numRoots);
  },
  sphJ: function(v: number, x: number): number {
    return Bessel.sph_bessel(v, x);
  },
  sphJPrime: function(v: number, x: number): number {
    return BoostBesselPrime.sph_bessel_j_prime(v, x);
  },
  sphY: function(v: number, x: number): number {
    return Bessel.sph_neumann(v, x);
  },
  sphYPrime: function (v: number, x: number): number {
    return BoostBesselPrime.sph_neumann_prime(v, x);
  }
};

export const beta = {
  "function": function(a: number, b: number): number {
    return Beta.beta(a, b);
  },
  incomplete: function(a: number,
                       b: number,
                       x: number,
                       lower: boolean = true,
                       regularized: boolean = true):
    number {
      if (regularized) {
        if (lower) {
          return Beta.ibeta(a, b, x);
        } else {
          return Beta.ibetac(a, b, x);
        }
      } else {
        if (lower) {
          return Beta.beta(a, b, x);
        } else {
          return Beta.betac(a, b, x);
        }
      }
  },
  incompleteInverse: function(a: number,
                              b: number,
                              p: number,
                              lower: boolean = true):
    number {
      if (lower) {
        return IBetaInverse.ibeta_inv(a, b, p).result;
      } else {
        return IBetaInverse.ibetac_inv(a, b, p).result;
      }
  },
  incompleteInverseParameter: function(otherParamVal: number,
                                       x: number,
                                       p: number,
                                       parameterToFind: "A" | "B" = "A",
                                       lower: boolean = true):
    number{
      if (parameterToFind === "A") {
        if (lower) {
          return IBetaInvAB.ibeta_inva(otherParamVal, x, p);
        } else {
          return IBetaInvAB.ibetac_inva(otherParamVal, x, p);
        }
      } else if (parameterToFind === "B") {
        if (lower) {
          return IBetaInvAB.ibeta_invb(otherParamVal, x, p);
        } else {
          return IBetaInvAB.ibetac_invb(otherParamVal, x, p);
        }
      } else {
        throw Error(`The argument parameterToFind must be "A" or "B", got: ${
          parameterToFind}`);
      }
  },
  incompleteDerivative: function(a: number, b: number, x: number): number {
    return Beta.ibeta_derivative(a, b, x);
  },
  pdf: function(x: number,
                alpha: number,
                beta: number,
                ncp: number = 0): number {
    return BetaDist.pdf(x, alpha, beta, ncp);
  },
  cdf: function(x: number,
                alpha: number,
                beta: number,
                lowerTail: boolean = true,
                ncp: number = 0): number {
    return BetaDist.cdf(x, alpha, beta, lowerTail, ncp);
  },
  quantile: function(x: number,
                     alpha: number,
                     beta: number,
                     lowerTail: boolean = true,
                     ncp: number = 0): number {
    return BetaDist.quantile(x, alpha, beta, lowerTail, ncp);
  },
  random: function(n: number,
                   alpha: number,
                   beta: number,
                   ncp: number = 0,
                   seed?: number | string): number[] {
    return BetaDist.random(n, alpha, beta, ncp, seed);
  }
};

export const binomial = {
  coefficient: function(n: number, k: number): number {
    return Beta.binomial_coefficient(n, k);
  },
  pdf: function(k: number,
                trials: number,
                probSuccess: number): number {
    return BinomialDist.pdf(k, trials, probSuccess);
  },
  cdf: function(k: number,
                trials: number,
                probSuccess: number,
                lowerTail: boolean = true): number {
    return BinomialDist.cdf(k, trials, probSuccess, lowerTail);
  },
  quantile: function(p: number,
                     trials: number,
                     probSuccess: number,
                     lowerTail: boolean = true): number {
    return BinomialDist.quantile(p, trials, probSuccess, lowerTail);
  },
  random: function(n: number,
                   trials: number,
                   probSuccess: number,
                   seed?: number | string): number[] {
    return BinomialDist.random(n, trials, probSuccess, seed);
  }
};

export const chi2 = {
  pdf: function(x: number,
                degreesOfFreedom: number,
                ncp: number = 0): number {
    return ChiSquaredDist.pdf(x, degreesOfFreedom, ncp);
  },
  cdf: function(x: number,
                degreesOfFreedom: number,
                lowerTail: boolean = true,
                ncp: number = 0): number {
    return ChiSquaredDist.cdf(x, degreesOfFreedom, lowerTail, ncp);
  },
  quantile: function(p: number,
                     degreesOfFreedom: number,
                     lowerTail: boolean = true,
                     ncp: number = 0): number {
    return ChiSquaredDist.quantile(p, degreesOfFreedom, lowerTail, ncp);
  },
  random: function(n: number,
                   degreesOfFreedom: number,
                   ncp: number = 0,
                   seed?: number | string): number[] {
    return ChiSquaredDist.random(n, degreesOfFreedom, ncp, seed);
  }
};

export const error = {
  "function": function(z: number, complement: boolean = false) {
    if (complement) {
      return Erf.erfc(z);
    } else {
      return Erf.erf(z);
    }
  },
  functionInverse: function(p: number, complement: boolean = false) {
    if (complement) {
      return ErfInv.erfc_inv(p);
    } else {
      return ErfInv.erf_inv(p);
    }
  }
};

export const exponential = {
  pdf: function(x: number,
                lambda: number): number {
    return ExponentialDist.pdf(x, lambda);
  },
  cdf: function(x: number,
                lambda: number,
                lowerTail: boolean = true): number {
    return ExponentialDist.cdf(x, lambda, lowerTail);
  },
  quantile: function(p: number,
                     lambda: number,
                     lowerTail: boolean = true): number {
    return ExponentialDist.quantile(p, lambda, lowerTail);
  },
  random: function(n: number,
                   lambda: number,
                   seed?: number | string): number[] {
    return ExponentialDist.random(n, lambda, seed);
  }
};

export const F = {
  pdf: function(x: number,
                dof1: number,
                dof2: number,
                ncp: number = 0): number {
    return FDist.pdf(x, dof1, dof2, ncp);
  },
  cdf: function(x: number,
                dof1: number,
                dof2: number,
                lowerTail: boolean = true,
                ncp: number = 0): number {
    return FDist.cdf(x, dof1, dof2, lowerTail, ncp);
  },
  quantile: function(p: number,
                     dof1: number,
                     dof2: number,
                     lowerTail: boolean = true,
                     ncp: number = 0): number {
    return FDist.quantile(p, dof1, dof2, lowerTail, ncp);
  },
  random: function(n: number,
                   dof1: number,
                   dof2: number,
                   ncp: number,
                   seed?: number | string): number[] {
    return FDist.random(n, dof1, dof2, ncp, seed);
  }
};

export const factorial = {
  value: function(n: number): number {
    return Factorial.factorial(n);
  },
  double: function(n: number): number {
    return Factorial.double_factorial(n);
  },
  rising: function(x: number, n: number): number {
    return Factorial.rising_factorial(x, n);
  },
  falling: function(x: number, n: number): number {
    return Factorial.falling_factorial(x, n);
  }
};

export const gamma = {
  "function": function(z: number): number {
    return Gamma.tgamma(z);
  },
  function1pm1: function(dz: number): number {
    return Gamma.tgamma1pm1(dz);
  },
  functionRatio: function(a: number, b: number): number {
    return Gamma.tgamma_ratio(a, b);
  },
  functionDeltaRatio: function(a: number, delta: number): number {
    return Gamma.tgamma_delta_ratio(a, delta);
  },
  functionLog: function(z: number): number {
    return Gamma.lgamma(z).result;
  },
  di: function(z: number): number {
    return Polygamma.polygamma(0, z);
  },
  tri: function(z: number): number {
    return Polygamma.polygamma(1, z);
  },
  poly: function(n: number, z: number): number {
    return Polygamma.polygamma(n, z);
  },
  incomplete: function(a: number,
                       z: number,
                       lower: boolean = true,
                       regularized: boolean = true):
    number {
    if (regularized) {
      if (lower) {
        return Gamma.gamma_p(a, z);
      } else {
        return Gamma.gamma_q(a, z);
      }
    } else {
      if (lower) {
        return Gamma.tgamma_lower(a, z);
      } else {
        return Gamma.tgamma(a, z);
      }
    }
  },
  incompletePrime: function(a: number,
                            z: number,
                            lower: boolean = true,
                            regularized: boolean = true):
    number {
    return Gamma.igamma_derivative(a, z, lower, regularized);
  },
  incompleteInverse: function(a: number, p: number, lower: boolean = true): number {
    if (lower) {
      return IGammaInverse.gamma_p_inv(a, p);
    } else {
      return IGammaInverse.gamma_q_inv(a, p);
    }
  },
  incompleteInverseParameter: function(z: number, p: number, lower: boolean = true):
    number {
    if (lower) {
      return GammaInvA.gamma_p_inva(z, p);
    } else {
      return GammaInvA.gamma_q_inva(z, p);
    }
  },
  pdf: function(x: number,
                shape: number,
                scale: number): number {
    return GammaDist.pdf(x, shape, scale);
  },
  cdf: function(x: number,
                shape: number,
                scale: number,
                lowerTail: boolean = true): number {
    return GammaDist.cdf(x, shape, scale, lowerTail);
  },
  quantile: function(p: number,
                     shape: number,
                     scale: number,
                     lowerTail: boolean = true): number {
    return GammaDist.quantile(p, shape, scale, lowerTail);
  },
  random: function(n: number,
                   shape: number,
                   scale: number,
                   seed?: number | string): number[] {
    return GammaDist.random(n, shape, scale, seed);
  }
};

export const hypergeometric = {
  pdf: function(sampleSuccesses: number,
                draws: number,
                successPop: number,
                totalPop: number): number {
    return hypergeometricDist.pdf(sampleSuccesses, draws, successPop, totalPop);
  },
  cdf: function(sampleSuccesses: number,
                draws: number,
                successPop: number,
                totalPop: number,
                lowerTail: boolean = true): number {
    return hypergeometricDist.cdf(sampleSuccesses, draws, successPop, totalPop, lowerTail);
  },
  quantile: function(p: number,
                     draws: number,
                     successPop: number,
                     totalPop: number,
                     lowerTail: boolean = true): number {
    return hypergeometricDist.quantile(p, draws, successPop, totalPop, lowerTail);
  },
  random: function(n: number,
                   draws: number,
                   successPop: number,
                   totalPop: number,
                   seed?: string | number): number[] {
    return hypergeometricDist.random(n, draws, successPop, totalPop, seed);
  }
};

export const normal = {
  pdf: function(x: number,
                mu?: number,
                sigma?: number): number {
    return NormalDist.pdf(x, mu, sigma);
  },
  cdf: function(x: number,
                mu?: number,
                sigma?: number,
                lowerTail: boolean = true): number {
    return NormalDist.cdf(x, mu, sigma, lowerTail);
  },
  quantile: function(p: number,
                     mu?: number,
                     sigma?: number,
                     lowerTail: boolean = true): number {
    return NormalDist.quantile(p, mu, sigma, lowerTail);
  },
  random: function(n: number,
                   mu?: number,
                   sigma?: number,
                   seed?: number | string): number[] {
    return NormalDist.random(n, mu, sigma, seed);
  },
};

export const owensT = function(h: number, a: number): number {
  return OwensT.owens_t(h, a);
};

export const poisson = {
  pdf: function(k: number,
                lambda: number): number {
    return PoissonDist.pdf(k, lambda);
  },
  cdf: function(k: number,
                lambda: number,
                lowerTail: boolean = true): number {
    return PoissonDist.cdf(k, lambda, lowerTail);
  },
  quantile: function(p: number,
                     lambda: number,
                     lowerTail: boolean = true): number {
    return PoissonDist.quantile(p, lambda, lowerTail);
  },
  random: function(n: number,
                   lambda: number,
                   seed?: number | string): number[] {
    return PoissonDist.random(n, lambda, seed);
  }
};

export const t = {
  pdf: function(x: number,
                degreesOfFreedom: number,
                ncp: number = 0): number {
    return StudentsTDist.pdf(x, degreesOfFreedom, ncp);
  },
  cdf: function(x: number,
                degreesOfFreedom: number,
                lowerTail: boolean = true,
                ncp: number = 0): number {
    return StudentsTDist.cdf(x, degreesOfFreedom, lowerTail, ncp);
  },
  quantile: function(p: number,
                     degreesOfFreedom: number,
                     lowerTail: boolean = true,
                     ncp: number = 0): number {
    return StudentsTDist.quantile(p, degreesOfFreedom, lowerTail, ncp);
  },
  random: function(n: number,
                   degreesOfFreedom: number,
                   ncp: number = 0,
                   seed?: number | string): number[] {
    return StudentsTDist.random(n, degreesOfFreedom, ncp, seed);
  }
};

export const uniform = {
  pdf: function(x: number,
                lowerSupportBound: number,
                upperSupportBound: number): number {
    return UniformDist.pdf(x, lowerSupportBound, upperSupportBound);
  },
  cdf: function(x: number,
                lowerSupportBound: number,
                upperSupportBound: number,
                lowerTail: boolean = true): number {
    return UniformDist.cdf(x, lowerSupportBound, upperSupportBound, lowerTail);
  },
  quantile: function(x: number,
                     lowerSupportBound: number,
                     upperSupportBound: number,
                     lowerTail: boolean = true): number {
    return UniformDist.quantile(x, lowerSupportBound, upperSupportBound, lowerTail);
  },
  random: function(n: number,
                   lowerSupportBound: number,
                   upperSupportBound: number,
                   seed?: number | string): number[] {
    return UniformDist.random(n, lowerSupportBound, upperSupportBound, seed);
  }
};

export const zeta = function(s: number): number {
  return Zeta.zeta(s);
};


