"use strict";

/**
 * (C) Copyright Gautam Sewani 2008.
 * (C) Copyright John Maddock 2008.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const HypergeometricPDF =
  require("./boostPorts/distributions/detail/hypergeometric_pdf").HypergeometricPDF;
const HypergeometricCDF =
  require("./boostPorts/distributions/detail/hypergeometric_cdf").HypergeometricCDF;
const HypergeometricQuantile =
  require("./boostPorts/distributions/detail/hypergeometric_quantile")
    .HypergeometricQuantile;
const check = require("./errorHandling").check;
const Random = require("./random").Random;

import {IRandomState, IRandomIterableIterator} from "./random";
import {Cache} from "./cache";

export class HypergeometricDist {

  private cache: Cache;

  constructor(cache: Cache) {
    this.cache = cache;
  }

  private static checkParameters(functionName: string,
                                 draws,
                                 successPop,
                                 totalPop,
                                 sampleSuccesses?,
                                 lowerTail?,
                                 p?,
                                 n?,
                                 seed?):
  {lowerTail?: boolean} {
    const params: {lowerTail?: boolean} = {
      lowerTail: undefined
    };

    check(
      draws,
      "draws",
      `hypergeometric distribution ${functionName}`,
      "nonnegative_integer"
    );

    check(
      successPop,
      "success population",
      `hypergeometric distribution ${functionName}`,
      "nonnegative_integer"
    );

    check(
      totalPop,
      "total population",
      `hypergeometric distribution ${functionName}`,
      "nonnegative_integer"
    );

    if (typeof sampleSuccesses !== "undefined") {
      check(
        sampleSuccesses,
        "sample successes",
        `hypergeometric distribution ${functionName}`,
        "nonnegative_integer"
      );
    }

    if (typeof lowerTail !== "undefined" && lowerTail !== null) {
      check(
        lowerTail,
        "lowerTail",
        `hypergeometric distribution ${functionName}`,
        "boolean"
      );
      params.lowerTail = lowerTail;
    } else {
      params.lowerTail = true;
    }

    if (typeof p !== "undefined") {
      check(p, "p", `hypergeometric distribution ${functionName}`, "probability");
    }

    if (typeof n !== "undefined") {
      check(n, "n", `hypergeometric distribution ${functionName}`, "nonnegative_integer");
    }

    if (typeof seed !== "undefined" && seed !== null) {
      check(seed, "seed", `hypergeometric distribution ${functionName}`, "seed");
    }

    return params;
  }

  public pdf(sampleSuccesses: number,
             draws: number,
             successPop: number,
             totalPop: number):
  number {
    const params = HypergeometricDist.checkParameters(
      "pdf",
      draws,
      successPop,
      totalPop,
      sampleSuccesses
    );

    return HypergeometricPDF.imp(
      sampleSuccesses,
      successPop,
      draws,
      totalPop,
      this.cache
    );
  }

  public cdf(sampleSuccesses: number,
             draws: number,
             successPop: number,
             totalPop: number,
             lowerTail?: boolean,
             primes?: number[]):
  number{
    const params = HypergeometricDist.checkParameters(
      "cdf",
      draws,
      successPop,
      totalPop,
      sampleSuccesses,
      lowerTail
    );

    if (sampleSuccesses < Math.max(0, draws + successPop - totalPop)) {
      return params.lowerTail ? 0 : 1;
    } else if (sampleSuccesses > Math.min(draws, successPop)) {
      return params.lowerTail ? 1 : 0
    } else {
      return HypergeometricCDF.imp(
        sampleSuccesses,
        successPop,
        draws,
        totalPop,
        !params.lowerTail,
        this.cache
      );
    }
  }

  public quantile(p: number,
                  draws: number,
                  successPop: number,
                  totalPop: number,
                  lowerTail?: boolean,
                  primes?: number[]): number {
    const params = HypergeometricDist.checkParameters(
      "quantile",
      draws,
      successPop,
      totalPop,
      undefined,
      lowerTail,
      p
    );

    if (p === 0) {
      return params.lowerTail ?
        Math.max(0, draws + successPop - totalPop)
        :
        Math.min(draws, successPop);
    } else if (p === 1) {
      return params.lowerTail ?
        Math.min(draws, successPop)
        :
        Math.max(0, draws + successPop - totalPop);
    } else {
      let p0 = params.lowerTail ? p : 1-p;
      let q0 = params.lowerTail ? 1-p : p;

      return HypergeometricQuantile.imp(
        p0,
        q0,
        draws,
        successPop,
        totalPop,
        "up",
        this.cache);
    }
  }

  public random(n: number,
                draws: number,
                successPop: number,
                totalPop: number,
                seed?: number | string | IRandomState):
  number[] {
    const params = HypergeometricDist.checkParameters(
      "random",
      draws,
      successPop,
      totalPop,
      undefined,
      undefined,
      undefined,
      n,
      seed
    );

    return Random.numbers(
      n,
      this.quantile,
      [draws, successPop, totalPop, true, this.cache],
      seed,
      this
    );
  }

  public randomIterator(n: number,
                        draws: number,
                        successPop: number,
                        totalPop: number,
                        seed?: number | string | IRandomState,
                        primes?: number[]):
  IRandomIterableIterator {
    if (typeof n === "undefined" || n === null) {
      n = Number.POSITIVE_INFINITY;
    }

    const params = HypergeometricDist.checkParameters(
      "randomIterator",
      draws,
      successPop,
      totalPop,
      undefined,
      undefined,
      undefined,
      n,
      seed
    );

    return Random.numberIterator(
      n,
      this.quantile,
      [draws, successPop, totalPop, true, this.cache],
      seed,
      this
    );
  }

} // end of class HypergeometricDist

// const sampleSuccesses = 10;
// const draws = 1000;
// const successPop = 100;
// const totalPop = 10000;
// const lowerTail = false;
// const p = 1.3153940887312682e-53;
// const n = 20;
//
// const cache = new Cache();
// const hypergeo = new HypergeometricDist(cache);
//
// console.log(`r params: ${sampleSuccesses}, ${successPop}, ${totalPop - successPop}, ${draws}, lower.tail=${lowerTail ? "TRUE" : "FALSE"}`);
//
// console.log("pmf:", hypergeo.pdf(sampleSuccesses, draws, successPop, totalPop));
// console.log("cdf:", hypergeo.cdf(sampleSuccesses, draws, successPop, totalPop, lowerTail));
// console.log("quantile:", hypergeo.quantile(p, draws, successPop, totalPop, lowerTail));
// console.log("random:", hypergeo.random(n, draws, successPop, totalPop, "seed seed"));
//
//
// //console.log("cdf:", HypergeometricDist.cdf(11, 1000, 100, 10000, false));