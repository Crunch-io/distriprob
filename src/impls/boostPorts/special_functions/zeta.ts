"use strict";

/**
 * (C) Copyright John Maddock 2007, 2014.
 * (C) Copyright Zachary Martin 2016 (port to JavaScript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const Precision = require("../tools/precision").Precision;
const Powm1 = require("./powm1").Powm1;
const Rational = require("../tools/rational").Rational;
const UncheckedBernoulli = require("./detail/unchecked_bernoulli").UncheckedBernoulli;
const UncheckedFactorial = require("./detail/unchecked_factorial").UncheckedFactorial;
const Constants = require("../tools/constants").Constants;
const SinPI = require("./sin_pi").SinPI;
const Gamma = require("./gamma").Gamma;


export class Zeta {

  private static zeta_polynomial_series(s: number, sc: number): number {
    //
    // This is algorithm 3 from:
    //
    // "An Efficient Algorithm for the Riemann Zeta Function", P. Borwein,
    // Canadian Mathematical Society, Conference Proceedings.
    // See: http://www.cecm.sfu.ca/personal/pborwein/PAPERS/P155.pdf
    //
    let n = Math.trunc(Math.log(Precision.epsilon()) / -2);
    let sum = 0;
    let two_n = Math.pow(2, n);
    let ej_sign = 1;
    for(let j = 0; j < n; j++){
      sum += ej_sign * -two_n / Math.pow(j + 1, s);
      ej_sign = -ej_sign;
    }
    let ej_sum = 1;
    let ej_term = 1;
    for(let j = n; j <= 2 * n - 1; j++) {
      sum += ej_sign * (ej_sum - two_n) / Math.pow(j + 1, s);
      ej_sign = -ej_sign;
      ej_term *= 2 * n - j;
      ej_term /= j - n + 1;
      ej_sum += ej_term;
    }
    return -sum / (two_n * (-Powm1.powm1(2, sc)));
  }

  /**
   * 53 bit mantissa implementation
   */
  private static zeta_imp_prec(s: number, sc: number): number {
    let result;
    if(s < 1) {
      // Rational Approximation
      // Maximum Deviation Found:                     2.020e-18
      // Expected Error Term:                         -2.020e-18
      // Max error found at double precision:         3.994987e-17
      const P: number[] = [
        0.24339294433593750202,
        -0.49092470516353571651,
        0.0557616214776046784287,
        -0.00320912498879085894856,
        0.000451534528645796438704,
        -0.933241270357061460782e-5,
      ];
      const Q: number[] = [
        1,
        -0.279960334310344432495,
        0.0419676223309986037706,
        -0.00413421406552171059003,
        0.00024978985622317935355,
        -0.101855788418564031874e-4,
      ];
      result = Rational.evaluate_polynomial(P, sc) /
        Rational.evaluate_polynomial(Q, sc);
      result -= 1.2433929443359375;
      result += (sc);
      result /= (sc);

    } else if(s <= 2) {
      // Maximum Deviation Found:        9.007e-20
      // Expected Error Term:            9.007e-20
      const P: number[] = [
        0.577215664901532860516,
        0.243210646940107164097,
        0.0417364673988216497593,
        0.00390252087072843288378,
        0.000249606367151877175456,
        0.110108440976732897969e-4,
      ];
      const Q: number[] = [
      1.0,
      0.295201277126631761737,
      0.043460910607305495864,
      0.00434930582085826330659,
      0.000255784226140488490982,
      0.10991819782396112081e-4,
      ];
      result = Rational.evaluate_polynomial(P, -sc) /
        Rational.evaluate_polynomial(Q, -sc);
      result += 1 / (-sc);

    } else if(s <= 4) {
      // Maximum Deviation Found:          5.946e-22
      // Expected Error Term:              -5.946e-22
      const Y = 0.6986598968505859375;
      const P: number[] = [
        -0.0537258300023595030676,
        0.0445163473292365591906,
        0.0128677673534519952905,
        0.00097541770457391752726,
        0.769875101573654070925e-4,
        0.328032510000383084155e-5,
      ];
      const Q: number[] = [
        1.0,
        0.33383194553034051422,
        0.0487798431291407621462,
        0.00479039708573558490716,
        0.000270776703956336357707,
        0.106951867532057341359e-4,
        0.236276623974978646399e-7,
      ];
      result = Rational.evaluate_polynomial(P, s - 2) /
        Rational.evaluate_polynomial(Q, s - 2);
      result += Y + 1 / (-sc);
    } else if(s <= 7) {
      // Maximum Deviation Found:                     2.955e-17
      // Expected Error Term:                         2.955e-17
      // Max error found at double precision:         2.009135e-16
      const P: number[] = [
        -2.49710190602259410021,
        -2.60013301809475665334,
        -0.939260435377109939261,
        -0.138448617995741530935,
        -0.00701721240549802377623,
        -0.229257310594893932383e-4,
      ];
      const Q: number[] = [
        1.0,
        0.706039025937745133628,
        0.15739599649558626358,
        0.0106117950976845084417,
        -0.36910273311764618902e-4,
        0.493409563927590008943e-5,
        -0.234055487025287216506e-6,
        0.718833729365459760664e-8,
        -0.1129200113474947419e-9,
      ];
      result = Rational.evaluate_polynomial(P, s - 4) /
        Rational.evaluate_polynomial(Q, s - 4);
      result = 1 + Math.exp(result);

    } else if(s < 15) {
      // Maximum Deviation Found:                     7.117e-16
      // Expected Error Term:                         7.117e-16
      // Max error found at double precision:         9.387771e-16
      const P: number[] = [
        -4.78558028495135619286,
        -1.89197364881972536382,
        -0.211407134874412820099,
        -0.000189204758260076688518,
        0.00115140923889178742086,
        0.639949204213164496988e-4,
        0.139348932445324888343e-5,
      ];
      const Q: number[] = [
        1.0,
        0.244345337378188557777,
        0.00873370754492288653669,
        -0.00117592765334434471562,
        -0.743743682899933180415e-4,
        -0.21750464515767984778e-5,
        0.471001264003076486547e-8,
        -0.833378440625385520576e-10,
        0.699841545204845636531e-12,
      ];
      result = Rational.evaluate_polynomial(P, s - 7) /
        Rational.evaluate_polynomial(Q, s - 7);
      result = 1 + Math.exp(result);

    } else if(s < 36) {
      // Max error in interpolated form:             1.668e-17
      // Max error found at long double precision:   1.669714e-17
      const P: number[] = [
        -10.3948950573308896825,
      -2.85827219671106697179,
      -0.347728266539245787271,
      -0.0251156064655346341766,
      -0.00119459173416968685689,
      -0.382529323507967522614e-4,
      -0.785523633796723466968e-6,
      -0.821465709095465524192e-8,
      ];
      const Q: number[] = [
        1.0,
        0.208196333572671890965,
        0.0195687657317205033485,
        0.00111079638102485921877,
        0.408507746266039256231e-4,
        0.955561123065693483991e-6,
        0.118507153474022900583e-7,
        0.222609483627352615142e-14,
      ];
      result = Rational.evaluate_polynomial(P, s - 15) /
        Rational.evaluate_polynomial(Q, s - 15);
      result = 1 + Math.exp(result);

    } else if(s < 56) {
      result = 1 + Math.pow(2, -s);
    } else {
      result = 1;
    }
    return result;
  }

  private static zeta_imp_odd_integer(s: number): number {
    const results: number[] = [
      1.2020569031595942,
      1.03692775514337,
      1.008349277381923,
      1.0020083928260821,
      1.0004941886041194,
      1.0001227133475785,
      1.000030588236307,
      1.0000076371976379,
      1.0000019082127165,
      1.0000004769329869,
      1.000000119219926,
      1.0000000298035034,
      1.0000000074507118,
      1.0000000018626598,
      1.0000000004656628,
      1.0000000001164155,
      1.0000000000291038,
      1.000000000007276,
      1.000000000001819,
      1.0000000000004547,
      1.0000000000001137,
      1.0000000000000284,
      1.000000000000007,
      1.0000000000000018,
      1.0000000000000004,
      1.0000000000000002
    ];

    return s > 54 ? 1 : results[Math.floor((s - 3) / 2)];
  }

  private static zeta_imp(s: number, sc: number): number {
    if(sc === 0) {
      throw new Error(`Pole error: Evaluation of zeta function at pole ${s}`);
    }

    let result;
    //
    // Trivial case:
    //
    if(s > 53) {
      return 1;
    }

    //
    // Start by seeing if we have a simple closed form:
    //
    if(Math.floor(s) === s && s <= Number.MAX_SAFE_INTEGER) {
      // Without exceptions we expect itrunc to return INT_MAX on overflow
      // and we fall through anyway.
      let v = Math.trunc(s);
      if(v === s) {
        if(v < 0) {
          if(((-v) & 1) === 0) {
            return 0;
          }

          let n = Math.floor((-v + 1) / 2);
          if(n <= UncheckedBernoulli.max_bernoulli_b2n()) {
            return ((-v & 1) ? -1 : 1) *
              UncheckedBernoulli.unchecked_bernoulli_b2n(n) / (1 - v);
          }
        } else if((v & 1) === 0) {
          if ((Math.floor(v / 2) <= UncheckedBernoulli.max_bernoulli_b2n()) &&
              (v <= UncheckedFactorial.max_factorial())) {
            return ((Math.floor(v / 2 - 1) & 1) ? -1 : 1) * Math.pow(2, v - 1) *
              Math.pow(Math.PI, v) *
              UncheckedBernoulli.unchecked_bernoulli_b2n(Math.floor(v / 2)) /
              UncheckedFactorial.unchecked_factorial(v);
          }
        } else {
          return Zeta.zeta_imp_odd_integer(v);
        }
      }
    }

    if (Math.abs(s) < Precision.root_epsilon()) {
      result = -0.5 - Constants.LOGROOT2PI() * s;
    } else if(s < 0) {
      const temp = s;
      s = sc;
      sc = temp;

      if(Math.floor(sc/2) === sc/2) {
        result = 0;
      } else {
        if(s > UncheckedFactorial.max_factorial()){
          const mult = SinPI.sin_pi(0.5 * sc) * 2 * Zeta.zeta_imp(s, sc);
          result = Gamma.lgamma(s).result;
          result -= s * Math.log(2 * Math.PI);
          if (result > Precision.log_max_value()) {
            throw new Error(`Overflow error`);
          }
          result = Math.exp(result);
          if(Number.MAX_VALUE / Math.abs(mult) < result) {
            throw new Error(`Overflow error`);
          }
          result *= mult;
        } else {
          result = SinPI.sin_pi(0.5 * sc)
            * 2 * Math.pow(2 * Math.PI, -s)
            * Gamma.tgamma(s)
            * Zeta.zeta_imp(s, sc);
        }
      }
    } else {
      result = Zeta.zeta_imp_prec(s, sc);
    }
    return result;
  }

  public static zeta(s: number): number {
    return Zeta.zeta_imp(s, 1 - s);
  }

}
