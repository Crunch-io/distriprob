"use strict";

/**
 * (C) Copyright Benjamin Sobotta 2012.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const Erf = require("./erf").Erf;
const Constants = require("../tools/constants").Constants;
const Expm1 = require("./expm1").Expm1;
const Precision = require("../tools/precision").Precision;


// Reference:
// Mike Patefield, David Tandy
// FAST AND ACCURATE CALCULATION OF OWEN'S T-FUNCTION
// Journal of Statistical Software, 5 (5), 1-25

export class OwensT {

  /**
   * owens_t_znorm1(x) = P(-oo<Z<=x)-0.5 with Z being normally distributed.
   */
  private static owens_t_znorm1(x: number): number {
    return Erf.erf(x * Constants.ONEDIVROOTTWO()) * 0.5;
  }

  /**
   * owens_t_znorm2(x) = P(x<=Z<oo) with Z being normally distributed.
   */
  private static owens_t_znorm2(x: number): number {
    return Erf.erfc(x * Constants.ONEDIVROOTTWO()) * 0.5;
  }

  /**
   * Auxiliary function, it computes an array key that is used to determine
   * the specific computation method for Owen's T and the order thereof
   * used in owens_t_dispatch.
   */
  private static owens_t_compute_code(h: number, a: number): number {
    const hrange: number[] =
      [0.02, 0.06, 0.09, 0.125, 0.26, 0.4, 0.6, 1.6, 1.7, 2.33, 2.4, 3.36, 3.4, 4.8 ];

    const arange: number[] = [0.025, 0.09, 0.15, 0.36, 0.5, 0.9, 0.99999];
    /*
     original select array from paper:
     1, 1, 2,13,13,13,13,13,13,13,13,16,16,16, 9
     1, 2, 2, 3, 3, 5, 5,14,14,15,15,16,16,16, 9
     2, 2, 3, 3, 3, 5, 5,15,15,15,15,16,16,16,10
     2, 2, 3, 5, 5, 5, 5, 7, 7,16,16,16,16,16,10
     2, 3, 3, 5, 5, 6, 6, 8, 8,17,17,17,12,12,11
     2, 3, 5, 5, 5, 6, 6, 8, 8,17,17,17,12,12,12
     2, 3, 4, 4, 6, 6, 8, 8,17,17,17,17,17,12,12
     2, 3, 4, 4, 6, 6,18,18,18,18,17,17,17,12,12
     */
    // subtract one because the array is written in FORTRAN in mind - in C arrays start
    // @ zero
    const select: number[] = [
      0,  0,  1, 12, 12, 12, 12, 12, 12, 12, 12, 15, 15, 15,  8,
      0,  1,  1,  2,  2,  4,  4, 13, 13, 14, 14, 15, 15, 15,  8,
      1,  1,  2,  2,  2,  4,  4, 14, 14, 14, 14, 15, 15, 15,  9,
      1,  1,  2,  4,  4,  4,  4,  6,  6, 15, 15, 15, 15, 15,  9,
      1,  2,  2,  4,  4,  5,  5,  7,  7, 16, 16, 16, 11, 11,  10,
      1,  2,  4,  4,  4,  5,  5,  7,  7, 16, 16, 16, 11, 11,  11,
      1,  2,  3,  3,  5,  5,  7,  7, 16, 16, 16, 16, 16, 11,  11,
      1,  2,  3,  3,  5,  5, 17, 17, 17, 17, 16, 16, 16, 11,  11
    ];

    let ihint = 14, iaint = 7;
    for(let i = 0; i !== 14; i++) {
      if( h <= hrange[i] ) {
        ihint = i;
        break;
      }
    } // for(unsigned short i = 0; i != 14; i++)

    for(let i = 0; i !== 7; i++) {
      if( a <= arange[i] ) {
        iaint = i;
        break;
      }
    } // for(unsigned short i = 0; i != 7; i++)

    // interprete select array as 8x15 matrix
    return select[iaint * 15 + ihint];
  }

  private static owens_t_get_order(icode: number): number {
    // 18 entries, 53 bit mantissa implementation
    const ord: number[] = [2, 3, 4, 5, 7, 10, 12, 18, 10, 20, 30, 0, 4, 7, 8, 20, 0, 0];

    return ord[icode];
  }

  /**
   * compute the value of Owen's T function with method T1 from the reference paper
   */
  private static owens_t_T1(h: number, a: number, m: number): number {
    const hs = -h * h * 0.5;
    const dhs = Math.exp( hs );
    const as = a * a;

    let j=1;
    let jj = 1;
    let aj = a * Constants.ONEDIVTWOPI();
    let dj = Expm1.expm1(hs);
    let gj = hs*dhs;

    let val = Math.atan(a) * Constants.ONEDIVTWOPI();

    while(true) {
      val += dj*aj/jj;

      if(m <= j) {
        break;
      }

      j++;
      jj += 2;
      aj *= as;
      dj = gj - dj;
      gj *= hs / j;
    }

    return val;
  }

  /**
   * compute the value of Owen's T function with method T2 from the reference paper
   */
  private static owens_t_T2(h: number, a: number, m: number, ah: number): number {

    const maxii = m+m+1;
    const hs = h*h;
    const as = -a*a;
    const y = 1 / hs;

    let ii = 1;
    let val = 0;
    let vi = a * Math.exp(-ah * ah * 0.5) * Constants.ONEDIVROOTTWOPI();
    let z = OwensT.owens_t_znorm1(ah)/h;

    while(true) {
      val += z;
      if( maxii <= ii ) {
        val *= Math.exp(-hs*0.5) * Constants.ONEDIVROOTTWOPI();
        break;
      } // if( maxii <= ii )
      z = y * (vi - ii * z);
      vi *= as;
      ii += 2;
    }

    return val;
  }

  /**
   * compute the value of Owen's T function with method T3 from the reference paper
   *
   * 53 bit mantissa implementation
   */
  private static owens_t_T3(h: number, a: number, ah: number): number {
    const m = 20;

    const c2: number[] = [
      0.99999999999999987510,
      -0.99999999999988796462,
      0.99999999998290743652,
      -0.99999999896282500134,
      0.99999996660459362918,
      -0.99999933986272476760,
      0.99999125611136965852,
      -0.99991777624463387686,
      0.99942835555870132569,
      -0.99697311720723000295,
      0.98751448037275303682,
      -0.95915857980572882813,
      0.89246305511006708555,
      -0.76893425990463999675,
      0.58893528468484693250,
      -0.38380345160440256652,
      0.20317601701045299653,
      -0.82813631607004984866E-01,
      0.24167984735759576523E-01,
      -0.44676566663971825242E-02,
      0.39141169402373836468E-03
    ];

    const as = a*a;
    const hs = h*h;
    const y = 1/hs;

    let ii = 1;
    let i = 0;
    let vi = a * Math.exp(-ah * ah * 0.5) * Constants.ONEDIVROOTTWOPI();
    let zi = OwensT.owens_t_znorm1(ah)/h;
    let val = 0;

    while(true) {
      val += zi*c2[i];
      if(m <= i) { // if( m < i+1 )
        val *= Math.exp(-hs * 0.5) * Constants.ONEDIVROOTTWOPI();
        break;
      } // if( m < i )
      zi = y * (ii*zi - vi);
      vi *= as;
      ii += 2;
      i++;
    } // while( true )

    return val;
  }

  /**
   * compute the value of Owen's T function with method T4 from the reference paper
   */
  private static owens_t_T4(h: number, a: number, m: number): number {
    const maxii = m+m+1;
    const hs = h*h;
    const as = -a*a;

    let ii = 1;
    let ai = a * Math.exp(-hs*(1-as)*0.5) * Constants.ONEDIVTWOPI();
    let yi = 1;
    let val = 0;

    while(true) {
      val += ai*yi;
      if(maxii <= ii) {
        break;
      }
      ii += 2;
      yi = (1-hs*yi) / ii;
      ai *= as;
    }

    return val;
  }

  /**
   * compute the value of Owen's T function with method T5 from the reference paper
   *
   * 53 bit mantissa implementation
   */
  private static owens_t_T5(h: number, a: number): number {
    /*
     NOTICE:
     - The pts[] array contains the squares (!) of the abscissas, i.e. the roots of the
     Legendre polynomial P_n(x), instead of the plain roots as required in Gauss-Legendre
     quadrature, because T5(h,a,m) contains only x^2 terms.
     - The wts[] array contains the weights for Gauss-Legendre quadrature scaled with a
     factor of 1/(2*pi) according to T5(h,a,m).
     */

    const m = 13;
    const pts: number[] = [
      0.35082039676451715489E-02,
      0.31279042338030753740E-01,
      0.85266826283219451090E-01,
      0.16245071730812277011,
      0.25851196049125434828,
      0.36807553840697533536,
      0.48501092905604697475,
      0.60277514152618576821,
      0.71477884217753226516,
      0.81475510988760098605,
      0.89711029755948965867,
      0.95723808085944261843,
      0.99178832974629703586
    ];
    const wts: number[] = [
      0.18831438115323502887E-01,
      0.18567086243977649478E-01,
      0.18042093461223385584E-01,
      0.17263829606398753364E-01,
      0.16243219975989856730E-01,
      0.14994592034116704829E-01,
      0.13535474469662088392E-01,
      0.11886351605820165233E-01,
      0.10070377242777431897E-01,
      0.81130545742299586629E-02,
      0.60419009528470238773E-02,
      0.38862217010742057883E-02,
      0.16793031084546090448E-02
    ];

    const as = a*a;
    const hs = -h*h*0.5;

    let val = 0;
    for(let i = 0; i < m; i++){
      let r = 1 + as*pts[i];
      val += wts[i] * Math.exp(hs*r) / r;
    } // for(unsigned short i = 0; i < m; ++i)

    return val * a;
  }

  /**
   * compute the value of Owen's T function with method T6 from the reference paper
   */
  private static owens_t_T6(h: number, a: number): number {
    const normh = OwensT.owens_t_znorm2(h);
    const y = 1 - a;
    const r = Math.atan2(y, 1 + a); // Todo: make sure atan2 is ok

    let val = normh * (1 - normh) * 0.5;

    if( r != 0 ) {
      val -= r * Math.exp( -y*h*h*0.5/r ) * Constants.ONEDIVTWOPI();
    }

    return val;
  }

  private static owens_t_T1_accelerated(h: number, a: number):
  {result: number, error: number} {
    //
    // This is the same series as T1, but:
    // * The Taylor series for atan has been combined with that for T1,
    //   reducing but not eliminating cancellation error.
    // * The resulting alternating series is then accelerated using method 1
    //   from H. Cohen, F. Rodriguez Villegas, D. Zagier,
    //   "Convergence acceleration of alternating series", Bonn, (1991).
    //
    const half_h_h = h * h / 2;
    let a_pow = a;
    const aa = a * a;
    const exp_term = Math.exp(-h * h / 2);
    let one_minus_dj_sum = exp_term;
    let sum = a_pow * exp_term;
    let dj_pow = exp_term;
    let term = sum;
    let abs_err;
    let j = 1;

    //
    // Normally with this form of series acceleration we can calculate
    // up front how many terms will be required - based on the assumption
    // that each term decreases in size by a factor of 3.  However,
    // that assumption does not apply here, as the underlying T1 series can
    // go quite strongly divergent in the early terms, before strongly
    // converging later.  Various "guestimates" have been tried to take account
    // of this, but they don't always work.... so instead set "n" to the
    // largest value that won't cause overflow later, and abort iteration
    // when the last accelerated term was small enough...
    //
    let n = Math.trunc(Precision.log_max_value() / 6);
    let d = Math.pow(3 + Math.sqrt(8), n);
    d = (d + 1 / d) / 2;
    let b = -1;
    let c = -d;
    c = b - c;
    sum *= c;
    b = -n * n * b * 2;
    abs_err = Math.abs(sum) * Math.pow(2, -53);

    while(j < n) {
      a_pow *= aa;
      dj_pow *= half_h_h / j;
      one_minus_dj_sum += dj_pow;
      term = one_minus_dj_sum * a_pow / (2 * j + 1);
      c = b - c;
      sum += c * term;
      abs_err += Math.max(Math.abs(sum), Math.abs(c*term)) * Math.pow(2, -53);
      b = (j + n) * (j - n) * b / ((j + 0.5) * (j + 1));
      j++;
      //
      // Include an escape route to prevent calculating too many terms:
      //
      if((j > 10) && (Math.abs(sum * Precision.epsilon()) > Math.abs(c * term))) {
        break;
      }
    }
    abs_err += Math.abs(c * term);
    if(sum < 0) {
      // sum must always be positive, if it's negative something really bad has happend:
      throw new Error(`Evaluation error`);
    }

    return {result: (sum / d) / Constants.TWOPI(), error: abs_err / sum};
  }

  private static owens_t_T2_mlp_true(h: number, a: number, m: number, ah: number):
  number {

    const maxii = m+m+1;
    const hs = h*h;
    const as = -a*a;
    const y = 1 / hs;

    let ii = 1;
    let val = 0;
    let vi = a * Math.exp(-ah * ah * 0.5) / Constants.SQRTTWOPI();
    let z = OwensT.owens_t_znorm1(ah)/h;
    let last_z = Math.abs(z);
    const lim = Precision.epsilon();

    while(true) {
      val += z;
      //
      // This series stops converging after a while, so put a limit
      // on how far we go before returning our best guess:
      //
      if ((Math.abs(lim * val) > Math.abs(z)) ||
          ((ii > maxii) && (Math.abs(z) > last_z)) ||
          (z === 0)) {
        val *= Math.exp(-hs * 0.5) / Constants.SQRTTWOPI();
        break;
      } // if( maxii <= ii )
      last_z = Math.abs(z);
      z = y * (vi - ii * z );
      vi *= as;
      ii += 2;
    }

    return val;
  }

  private static owens_t_T2_accelerated(h: number, a: number, ah: number):
  {result: number, error: number} {
    //
    // This is the same series as T2, but with acceleration applied.
    // Note that we have to be *very* careful to check that nothing bad
    // has happened during evaluation - this series will go divergent
    // and/or fail to alternate at a drop of a hat! :-(
    //
    const hs = h*h;
    const as = -a*a;
    const y = 1 / hs;

    let ii = 1;
    let val = 0;
    let vi = a * Math.exp(-ah * ah * 0.5) / Constants.SQRTTWOPI();
    let z = OwensT.owens_t_znorm1(ah)/h;
    let last_z = Math.abs(z);

    //
    // Normally with this form of series acceleration we can calculate
    // up front how many terms will be required - based on the assumption
    // that each term decreases in size by a factor of 3.  However,
    // that assumption does not apply here, as the underlying T1 series can
    // go quite strongly divergent in the early terms, before strongly
    // converging later.  Various "guestimates" have been tried to take account
    // of this, but they don't always work.... so instead set "n" to the
    // largest value that won't cause overflow later, and abort iteration
    // when the last accelerated term was small enough...
    //
    let n = Math.trunc(Precision.log_max_value() / 6);
    let d = Math.pow(3 + Math.sqrt(8), n);
    d = (d + 1 / d) / 2;
    let b = -1;
    let c = -d;
    let s = 1;

    for(let k = 0; k < n; k++){
      //
      // Check for both convergence and whether the series has gone bad:
      //
      if((Math.abs(z) > last_z) ||    // Series has gone divergent, abort
         (Math.abs(val) * Precision.epsilon() > Math.abs(c * s * z))  // Convergence!
         || (z * s < 0)) {   // Series has stopped alternating - all bets are off - abort.
        break;
      }
      c = b - c;
      val += c * s * z;
      b = (k + n) * (k - n) * b / ((k + 0.5) * (k + 1));
      last_z = Math.abs(z);
      s = -s;
      z = y * ( vi - ii * z );
      vi *= as;
      ii += 2;
    }

    return {
      result: val * Math.exp(-hs * 0.5) / (d * Constants.SQRTTWOPI()),
      error: Math.abs(c * z) / val
    };
  }

  private static T4_mp(h: number, a: number): number {
    const hs = h*h;
    const as = -a*a;

    let ii = 1;
    let ai =  Constants.ONEDIVTWOPI() * a * Math.exp(-0.5 * hs * (1.0 - as));
    let yi = 1.0;
    let val = 0.0;

    const lim = Precision.epsilon();
    const max_iter = 1500; // set explicitly

    while(true) {
      let term = ai*yi;
      val += term;
      if((yi !== 0) && (Math.abs(val * lim) > Math.abs(term))) {
        break;
      }
      ii += 2;
      yi = (1.0 - hs * yi) / ii;
      ai *= as;
      if(ii > max_iter) {
        throw new Error(`Evaluation error`);
      }
    }

    return val;
  }

  /**
   * This routine dispatches the call to one of six subroutines, depending on the values
   * of h and a.
   * preconditions: h >= 0, 0<=a<=1, ah=a*h
   *
   * Note there are different versions for different precisions in the original c++ source
   *
   * - this is the simple main case for 64-bit precision or less, this is as per the
   * Patefield-Tandy paper:
   */
  private static owens_t_dispatch(h: number, a: number, ah: number): number {
    //
    // Handle some special cases first, these are from
    // page 1077 of Owen's original paper:
    //
    if(h === 0) {
      return Math.atan(a) * Constants.ONEDIVTWOPI();
    }
    if(a === 0) {
      return 0;
    }
    if(a === 1) {
      return OwensT.owens_t_znorm2(-h) * OwensT.owens_t_znorm2(h) / 2;
    }
    if(a >= Number.MAX_VALUE){
      return OwensT.owens_t_znorm2(Math.abs(h));
    }

    let val;
    const icode = OwensT.owens_t_compute_code(h, a);
    const m = OwensT.owens_t_get_order(icode);
    const meth = [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 4, 4, 4, 4, 5, 6]; // 18 entries

    // determine the appropriate method, T1 ... T6
    switch( meth[icode] ) {
      case 1: // T1
        val = OwensT.owens_t_T1(h,a,m);
        break;
      case 2: // T2
        val = OwensT.owens_t_T2(h, a, m, ah);
        break;
      case 3: // T3
        val = OwensT.owens_t_T3(h,a,ah);
        break;
      case 4: // T4
        val = OwensT.owens_t_T4(h,a,m);
        break;
      case 5: // T5
        val = OwensT.owens_t_T5(h,a);
        break;
      case 6: // T6
        val = OwensT.owens_t_T6(h,a);
        break;
      default:
        throw new Error(`Logic error: selection routine in Owen's T function failed`);
    }
    return val;
  }

  /**
   * compute Owen's T function, T(h,a), for arbitrary values of h and a
   */
  public static owens_t(h: number, a: number): number {
    // exploit that T(-h,a) == T(h,a)
    h = Math.abs(h);

    // Use equation (2) in the paper to remap the arguments
    // such that h>=0 and 0<=a<=1 for the call of the actual
    // computation routine.

    const fabs_a = Math.abs(a);
    const fabs_ah = fabs_a * h;

    let val;

    if(fabs_a <= 1) {
      val = OwensT.owens_t_dispatch(h, fabs_a, fabs_ah);
    } else {
      if (h <= 0.67) {
        const normh = OwensT.owens_t_znorm1(h);
        const normah = OwensT.owens_t_znorm1(fabs_ah);
        val = 0.25 - normh * normah - OwensT.owens_t_dispatch(fabs_ah, 1 / fabs_a, h);
      } else {
        const normh = OwensT.owens_t_znorm2(h);
        const normah = OwensT.owens_t_znorm2(fabs_ah);
        val = 0.5 * (normh + normah) - normh * normah -
          OwensT.owens_t_dispatch(fabs_ah, 1 / fabs_a, h);
      }
    }

    // exploit that T(h,-a) == -T(h,a)
    if(a < 0) {
      return -val;
    }

    return val;
  }

}
