"use strict";

/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const Toms748 = require("../../tools/toms748_solve").Toms748;
const Beta = require("../beta").Beta;
const ErfInv = require("./erf_inv").ErfInv;
const Constants = require("../../tools/constants").Constants;
const Precision = require("../../tools/precision").Precision;


export class IBetaInvAB {

  private  static beta_inv_ab_t(b: number, z: number, p: number, invert: boolean, swap_ab: boolean):
  (a: number) => number {
    return (a: number) => {
      return invert ?
      p - Beta.ibetac(swap_ab ? b : a, swap_ab ? a : b, z)
      :
      Beta.ibeta(swap_ab ? b : a, swap_ab ? a : b, z) - p;
    }
  }

  public static inverse_negative_binomial_cornish_fisher(n: number,
                                                         sf: number,
                                                         sfc: number,
                                                         p: number,
                                                         q: number):
  number {
    // mean:
    const m = n * (sfc) / sf;
    const t = Math.sqrt(n * (sfc));
    // standard deviation:
    const sigma = t / sf;
    // skewness
    const sk = (1 + sfc) / t;
    // kurtosis:
    const k = (6 - sf * (5+sfc)) / (n * (sfc));
    // Get the inverse of a std normal distribution:
    let x = ErfInv.erfc_inv(p > q ? 2 * q : 2 * p) * Constants.SQRT2();
    // Set the sign:
    if(p < 0.5) {
      x = -x;
    }

    const x2 = x * x;
    // w is correction term due to skewness
    let w = x + sk * (x2 - 1) / 6;
    //
    // Add on correction due to kurtosis.
    //
    if(n >= 10) {
      w += k * x * (x2 - 3) / 24 + sk * sk * x * (2 * x2 - 5) / -36;
    }

    w = m + sigma * w;
    if(w < Number.MIN_VALUE) {
      return Number.MIN_VALUE;
    }

    return w;
  }

  private static ibeta_inv_ab_imp(b: number,
                                  z: number,
                                  p: number,
                                  q: number,
                                  swap_ab: boolean):
  number {
    //
    // Special cases first:
    //
    if(p === 0) {
      return swap_ab ? Number.MIN_VALUE : Number.MAX_VALUE;
    }
    if(q === 0) {
      return swap_ab ? Number.MAX_VALUE : Number.MIN_VALUE;
    }
    //
    // Function object, this is the functor whose root
    // we have to solve:
    //
    const f = IBetaInvAB.beta_inv_ab_t(
      b,
      z,
      (p < q) ? p : q,
      (p < q) ? false : true,
      swap_ab
    );

    //
    // Tolerance: full precision.
    //
    const tol = Toms748.eps_tolerance(53);

    //
    // Now figure out a starting guess for what a may be,
    // we'll start out with a value that'll put p or q
    // right bang in the middle of their range, the functions
    // are quite sensitive so we should need too many steps
    // to bracket the root from there:
    //
    let guess = 0;
    let factor = 5;
    //
    // Convert variables to parameters of a negative binomial distribution:
    //
    const n = b;
    const sf = swap_ab ? z : 1-z;
    const sfc = swap_ab ? 1-z : z;
    const u = swap_ab ? p : q;
    const v = swap_ab ? q : p;

    if(u <= Math.pow(sf, n)) {
      //
      // Result is less than 1, negative binomial approximation
      // is useless....
      //
      if((p < q) != swap_ab) {
        guess = Math.min(b * 2, 1);
      } else {
        guess = Math.min(b / 2, 1);
      }
    }
    if(n * n * n * u * sf > 0.005)
      guess = 1+IBetaInvAB.inverse_negative_binomial_cornish_fisher(n, sf, sfc, u, v);

    if(guess < 10) {
      //
      // Negative binomial approximation not accurate in this area:
      //
      if((p < q) != swap_ab) {
        guess = Math.min(b * 2, 10);
      } else {
        guess = Math.min(b / 2, 10);
      }
    } else {
      factor = (v < Math.sqrt(Precision.epsilon())) ? 2 : (guess < 20 ? 1.2 : 1.1);
    }

    //
    // Max iterations permitted:
    //
    const max_iter = 500;
    const r = Toms748.bracket_and_solve_root(
      f,
      guess,
      factor,
      swap_ab ? true : false,
      tol,
      max_iter
    );
    if(r.iterations >= max_iter) {
      throw new Error(`Evaluation error: Unable to locate the root within a reasonable${""
      } number of iterations, closest approximation so far was ${r.a}"`);
    }

    return (r.a + r.b) / 2;
  }

  public static ibeta_inva(b: number, x: number, p: number): number {
    if(p === 0) {
      throw new Error(`Overflow error`);
    }

    if(p === 1) {
      return Number.MIN_VALUE;
    }

    return IBetaInvAB.ibeta_inv_ab_imp(b, x, p, 1-p, false);
  }

  public static ibetac_inva(b: number, x: number, q: number): number {
    if(q === 1){
      throw new Error(`Overflow error`);
    }

    if(q === 0) {
      return Number.MIN_VALUE;
    }

    return IBetaInvAB.ibeta_inv_ab_imp(b, x, 1-q, q, false);
  }

  public static ibeta_invb(a: number, x: number, p: number): number {
    if(p === 0) {
      return Number.MIN_VALUE;
    }

    if(p === 1) {
      throw new Error(`Overflow error`);
    }

    return IBetaInvAB.ibeta_inv_ab_imp(a, x, p, 1-p, true);
  }

  public static ibetac_invb(a: number, x: number, q: number): number {
    if(q === 1){
      return Number.MIN_VALUE;
    }

    if(q === 0) {
      throw new Error(`Overflow error`);
    }

    return IBetaInvAB.ibeta_inv_ab_imp(a, x, 1-q, q, true);
  }

}

