"use strict";

/**
 * (C) Copyright Anton Bikineev 2013.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const CosPI = require("../cos_pi").CosPI;
const SinPI = require("../sin_pi").SinPI;
const Precision = require("../../tools/precision").Precision;


export class BesselJYDerivativesAsym {

  public static asymptotic_bessel_derivative_amplitude(v: number, x: number): number {
    // Calculate the amplitude for J'(v,x) and I'(v,x)
    // for large x: see A&S 9.2.30.
    let s = 1;
    const mu = 4 * v * v;
    let txq = 2 * x;
    txq *= txq;

    s -= (mu - 3) / (2 * txq);
    s -= ((mu - 1) * (mu - 45)) / (txq * txq * 8);

    return Math.sqrt(s * 2 / (Math.PI * x));
  }

  public static asymptotic_bessel_derivative_phase_mx(v: number, x: number): number {
    // Calculate the phase of J'(v, x) and Y'(v, x) for large x.
    // See A&S 9.2.31.
    // Note that the result returned is the phase less (x - PI(v/2 - 1/4))
    // which we'll factor in later when we calculate the sines/cosines of the result:
    const mu = 4 * v * v;
    const mu2 = mu * mu;
    const mu3 = mu2 * mu;
    let denom = 4 * x;
    let denom_mult = denom * denom;

    let s = 0;
    s += (mu + 3) / (2 * denom);
    denom *= denom_mult;
    s += (mu2 + (46 * mu) - 63) / (6 * denom);
    denom *= denom_mult;
    s += (mu3 + (185 * mu2) - (2053 * mu) + 1899) / (5 * denom);

    return s;
  }

  public static asymptotic_bessel_y_derivative_large_x_2(v: number, x: number): number {
    // See A&S 9.2.20.

    // Get the phase and amplitude:
    const ampl = BesselJYDerivativesAsym.asymptotic_bessel_derivative_amplitude(
      v,
      x
    );
    const phase = BesselJYDerivativesAsym.asymptotic_bessel_derivative_phase_mx(
      v,
      x
    );
    //
    // Calculate the sine of the phase, using
    // sine/cosine addition rules to factor in
    // the x - PI(v/2 - 1/4) term not added to the
    // phase when we calculated it.
    //
    const cx = Math.cos(x);
    const sx = Math.sin(x);
    const vd2shifted = (v / 2) - 0.25;
    const ci = CosPI.cos_pi(vd2shifted);
    const si = SinPI.sin_pi(vd2shifted);
    const sin_phase = Math.sin(phase) * (cx*ci+sx*si) + Math.cos(phase) * (sx*ci-cx*si);

    return sin_phase * ampl;
  }

  public static asymptotic_bessel_j_derivative_large_x_2(v: number, x: number): number {
    // See A&S 9.2.20.

    // Get the phase and amplitude:
    const ampl = BesselJYDerivativesAsym.asymptotic_bessel_derivative_amplitude(
      v,
      x
    );
    const phase = BesselJYDerivativesAsym.asymptotic_bessel_derivative_phase_mx(
      v,
      x
    );
    //
    // Calculate the sine of the phase, using
    // sine/cosine addition rules to factor in
    // the x - PI(v/2 - 1/4) term not added to the
    // phase when we calculated it.
    //
    const cx = Math.cos(x);
    const sx = Math.sin(x);
    const vd2shifted = (v / 2) - 0.25;
    const ci = CosPI.cos_pi(vd2shifted);
    const si = SinPI.sin_pi(vd2shifted);
    const sin_phase = Math.cos(phase) * (cx*ci+sx*si) - Math.sin(phase) * (sx*ci-cx*si);

    return sin_phase * ampl;
  }

  public static asymptotic_bessel_derivative_large_x_limit(v: number, x: number):
  boolean {
    //
    // This function is the copy of math::asymptotic_bessel_large_x_limit
    // It means that we use the same rules for determining how x is large
    // compared to v.
    //
    // Determines if x is large enough compared to v to take the asymptotic
    // forms above.  From A&S 9.2.28 we require:
    //    v < x * eps^1/8
    // and from A&S 9.2.29 we require:
    //    v^12/10 < 1.5 * x * eps^1/10
    // using the former seems to work OK in practice with broadly similar
    // error rates either side of the divide for v < 10000.
    // At double precision eps^1/8 ~= 0.01.
    //
    return Math.max(Math.abs(v), 1) < x * Math.sqrt(Precision.forth_root_epsilon());
  }

}