"use strict";

/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/**
 * This file implements the asymptotic expansions of the incomplete
 * gamma functions P(a, x) and Q(a, x), used when a is large and
 * x ~ a.
 *
 * The primary reference is:
 *
 * "The Asymptotic Expansion of the Incomplete Gamma Functions"
 * N. M. Temme.
 * Siam J. Math Anal. Vol 10 No 4, July 1979, p757.
 *
 * A different way of evaluating these expansions,
 * plus a lot of very useful background information is in:
 *
 * "A Set of Algorithms For the Incomplete Gamma Functions."
 * N. M. Temme.
 * Probability in the Engineering and Informational Sciences,
 * 8, 1994, 291.
 *
 * An alternative implementation is in:
 *
 * "Computation of the Incomplete Gamma Function Ratios and their Inverse."
 * A. R. Didonato and A. H. Morris.
 * ACM TOMS, Vol 12, No 4, Dec 1986, p377.
 *
 * There are various versions of the same code below, each accurate
 * to a different precision.  To understand the code, refer to Didonato
 * and Morris, from Eq 17 and 18 onwards.
 *
 * The coefficients used here are not taken from Didonato and Morris:
 * the domain over which these expansions are used is slightly different
 * to theirs, and their constants are not quite accurate enough for
 * 128-bit long double's.  Instead the coefficients were calculated
 * using the methods described by Temme p762 from Eq 3.8 onwards.
 * The values obtained agree with those obtained by Didonato and Morris
 * (at least to the first 30 digits that they provide).
 * At double precision the degrees of polynomial required for full
 * machine precision are close to those recomended to Didonato and Morris,
 * but of course many more terms are needed for larger types.
 */

const Log1p = require("../log1p").Log1p;
const Rational = require("../../tools/rational").Rational;
const Erf = require("../erf").Erf;


export class IGammaLarge {

  public static igamma_temme_large(a: number, x: number): number {
    let sigma = (x - a) / a;
    let phi = -Log1p.log1pmx(sigma);
    let y = a * phi;
    let z = Math.sqrt(2 * phi);
    if(x < a) {
      z = -z;
    }


    let workspace: number[] = [];

    const C0 = [
      -0.33333333333333333,
      0.083333333333333333,
      -0.014814814814814815,
      0.0011574074074074074,
      0.0003527336860670194,
      -0.00017875514403292181,
      0.39192631785224378e-4,
      -0.21854485106799922e-5,
      -0.185406221071516e-5,
      0.8296711340953086e-6,
      -0.17665952736826079e-6,
      0.67078535434014986e-8,
      0.10261809784240308e-7,
      -0.43820360184533532e-8,
      0.91476995822367902e-9,
    ];
    workspace.push(Rational.evaluate_polynomial(C0, z));

    const C1 = [
      -0.0018518518518518519,
      -0.0034722222222222222,
      0.0026455026455026455,
      -0.00099022633744855967,
      0.00020576131687242798,
      -0.40187757201646091e-6,
      -0.18098550334489978e-4,
      0.76491609160811101e-5,
      -0.16120900894563446e-5,
      0.46471278028074343e-8,
      0.1378633446915721e-6,
      -0.5752545603517705e-7,
      0.11951628599778147e-7,
    ];
    workspace.push(Rational.evaluate_polynomial(C1, z));

    const C2 = [
      0.0041335978835978836,
      -0.0026813271604938272,
      0.00077160493827160494,
      0.20093878600823045e-5,
      -0.00010736653226365161,
      0.52923448829120125e-4,
      -0.12760635188618728e-4,
      0.34235787340961381e-7,
      0.13721957309062933e-5,
      -0.6298992138380055e-6,
      0.14280614206064242e-6,
    ];
    workspace.push(Rational.evaluate_polynomial(C2, z));

    const C3 = [
      0.00064943415637860082,
      0.00022947209362139918,
      -0.00046918949439525571,
      0.00026772063206283885,
      -0.75618016718839764e-4,
      -0.23965051138672967e-6,
      0.11082654115347302e-4,
      -0.56749528269915966e-5,
      0.14230900732435884e-5,
    ];
    workspace.push(Rational.evaluate_polynomial(C3, z));

    const C4 = [
      -0.0008618882909167117,
      0.00078403922172006663,
      -0.00029907248030319018,
      -0.14638452578843418e-5,
      0.66414982154651222e-4,
      -0.39683650471794347e-4,
      0.11375726970678419e-4,
    ];
    workspace.push(Rational.evaluate_polynomial(C4, z));

    const C5 = [
      -0.00033679855336635815,
      -0.69728137583658578e-4,
      0.00027727532449593921,
      -0.00019932570516188848,
      0.67977804779372078e-4,
      0.1419062920643967e-6,
      -0.13594048189768693e-4,
      0.80184702563342015e-5,
      -0.22914811765080952e-5,
    ];
    workspace.push(Rational.evaluate_polynomial(C5, z));

    const C6 = [
      0.00053130793646399222,
      -0.00059216643735369388,
      0.00027087820967180448,
      0.79023532326603279e-6,
      -0.81539693675619688e-4,
      0.56116827531062497e-4,
      -0.18329116582843376e-4,
    ];
    workspace.push(Rational.evaluate_polynomial(C6, z));

    const C7 = [
      0.00034436760689237767,
      0.51717909082605922e-4,
      -0.00033493161081142236,
      0.0002812695154763237,
      -0.00010976582244684731,
    ];
    workspace.push(Rational.evaluate_polynomial(C7, z));

    const C8 = [
      -0.00065262391859530942,
      0.00083949872067208728,
      -0.00043829709854172101,
    ];
    workspace.push(Rational.evaluate_polynomial(C8, z));
    workspace.push(-0.00059676129019274625);

    let result = Rational.evaluate_polynomial(workspace, 1/a);
    result *= Math.exp(-y) / Math.sqrt(2 * Math.PI * a);
    if(x < a){
      result = -result;
    }

    result += Erf.erfc(Math.sqrt(y)) / 2;

    return result;
  }

}