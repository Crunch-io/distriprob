"use strict";

/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const Rational = require("../../tools/rational").Rational;
const Gamma = require("../gamma").Gamma;
const Log1p = require("../log1p").Log1p;
const Precision = require("../../tools/precision").Precision;
const Roots = require("../../tools/roots").Roots;


export class IGammaInverse {

  private static find_inverse_s(p: number, q: number): number {
    //
    // Computation of the Incomplete Gamma Function Ratios and their Inverse
    // ARMIDO R. DIDONATO and ALFRED H. MORRIS, JR.
    // ACM Transactions on Mathematical Software, Vol. 12, No. 4,
    // December 1986, Pages 377-393.
    //
    // See equation 32.
    //
    let t;
    if(p < 0.5) {
      t = Math.sqrt(-2 * Math.log(p));
    } else {
      t = Math.sqrt(-2 * Math.log(q));
    }
    const a: number[] = [
      3.31125922108741,
      11.6616720288968,
      4.28342155967104,
      0.213623493715853
    ];
    const b: number[] = [
      1,
      6.61053765625462,
      6.40691597760039,
      1.27364489782223,
      0.3611708101884203e-1
    ];
    let s = t - Rational.evaluate_polynomial(a, t) /
      Rational.evaluate_polynomial(b, t);
    if(p < 0.5) {
      s = -s;
    }

    return s;
  }

  private static didonato_SN(a: number, x: number, N: number, tolerance: number = 0):
  number {
    //
    // Computation of the Incomplete Gamma Function Ratios and their Inverse
    // ARMIDO R. DIDONATO and ALFRED H. MORRIS, JR.
    // ACM Transactions on Mathematical Software, Vol. 12, No. 4,
    // December 1986, Pages 377-393.
    //
    // See equation 34.
    //
    let sum = 1;
    if(N >= 1) {
      let partial = x / (a + 1);
      sum += partial;
      for(let i = 2; i <= N; i++) {
        partial *= x / (a + i);
        sum += partial;
        if(partial < tolerance) {
          break;
        }
      }
    }
    return sum;
  }

  private static didonato_FN(p: number,
                             a: number,
                             x: number,
                             N: number,
                             tolerance: number): number {
    //
    // Computation of the Incomplete Gamma Function Ratios and their Inverse
    // ARMIDO R. DIDONATO and ALFRED H. MORRIS, JR.
    // ACM Transactions on Mathematical Software, Vol. 12, No. 4,
    // December 1986, Pages 377-393.
    //
    // See equation 34.
    //
    let u = Math.log(p) + Gamma.lgamma(a + 1).result;
    return Math.exp((u+x-Math.log(IGammaInverse.didonato_SN(a, x, N, tolerance)))/a);
  }

  private static find_inverse_gamma(a: number, p: number, q: number):
  {result: number, has_10_digits: boolean} {
    //
    // In order to understand what's going on here, you will
    // need to refer to:
    //
    // Computation of the Incomplete Gamma Function Ratios and their Inverse
    // ARMIDO R. DIDONATO and ALFRED H. MORRIS, JR.
    // ACM Transactions on Mathematical Software, Vol. 12, No. 4,
    // December 1986, Pages 377-393.
    //

    let result;
    let p_has_10_digits = false;

    if(a === 1) {
      result = -Math.log(q);
    } else if(a < 1) {
      let g = Gamma.tgamma(a);
      let b = q * g;
      if((b > 0.6) || ((b >= 0.45) && (a >= 0.3))) {
        // DiDonato & Morris Eq 21:
        //
        // There is a slight variation from DiDonato and Morris here:
        // the first form given here is unstable when p is close to 1,
        // making it impossible to compute the inverse of Q(a,x) for small
        // q.  Fortunately the second form works perfectly well in this case.
        //
        let u;
        if((b * q > 1e-8) && (q > 1e-5)) {
          u = Math.pow(p * g * a, 1 / a);

        } else {
          u = Math.exp((-q / a) - Math.E);
        }
        result = u / (1 - (u / (a + 1)));
      } else if((a < 0.3) && (b >= 0.35)) {
        // DiDonato & Morris Eq 22:
        let t = Math.exp(-Math.E - b);
        let u = t * Math.exp(t);
        result = t * Math.exp(u);
      } else if((b > 0.15) || (a >= 0.3)) {
        // DiDonato & Morris Eq 23:
        let y = -Math.log(b);
        let u = y - (1 - a) * Math.log(y);
        result = y - (1 - a) * Math.log(u) - Math.log(1 + (1 - a) / (1 + u));
      } else if (b > 0.1) {
        // DiDonato & Morris Eq 24:
        let y = -Math.log(b);
        let u = y - (1 - a) * Math.log(y);
        result = y - (1 - a) * Math.log(u) -
          Math.log((u * u + 2 * (3 - a) * u + (2 - a) * (3 - a))/(u * u + (5 - a) * u+2));
      } else {
        // DiDonato & Morris Eq 25:
        let y = -Math.log(b);
        let c1 = (a - 1) * Math.log(y);
        let c1_2 = c1 * c1;
        let c1_3 = c1_2 * c1;
        let c1_4 = c1_2 * c1_2;
        let a_2 = a * a;
        let a_3 = a_2 * a;

        let c2 = (a - 1) * (1 + c1);
        let c3 = (a - 1) * (-(c1_2 / 2) + (a - 2) * c1 + (3 * a - 5) / 2);
        let c4 = (a - 1) * ((c1_3 / 3) - (3 * a - 5) * c1_2 / 2 + (a_2 - 6 * a + 7) * c1 +
          (11 * a_2 - 46 * a + 47) / 6);
        let c5 = (a - 1) * (-(c1_4 / 4)
        + (11 * a - 17) * c1_3 / 6
        + (-3 * a_2 + 13 * a -13) * c1_2
        + (2 * a_3 - 25 * a_2 + 72 * a - 61) * c1 / 2
        + (25 * a_3 - 195 * a_2 + 477 * a - 379) / 12);

        let y_2 = y * y;
        let y_3 = y_2 * y;
        let y_4 = y_2 * y_2;
        result = y + c1 + (c2 / y) + (c3 / y_2) + (c4 / y_3) + (c5 / y_4);
        if(b < 1e-28) {
          p_has_10_digits = true;
        }
      }
    } else {
      // DiDonato and Morris Eq 31:
      let s = IGammaInverse.find_inverse_s(p, q);

      let s_2 = s * s;
      let s_3 = s_2 * s;
      let s_4 = s_2 * s_2;
      let s_5 = s_4 * s;
      let ra = Math.sqrt(a);

      let w = a + s * ra + (s * s -1) / 3;
      w += (s_3 - 7 * s) / (36 * ra);
      w -= (3 * s_4 + 7 * s_2 - 16) / (810 * a);
      w += (9 * s_5 + 256 * s_3 - 433 * s) / (38880 * a * ra);

      if((a >= 500) && (Math.abs(1 - w / a) < 1e-6)) {
        result = w;
        p_has_10_digits = true;
      } else if (p > 0.5) {
        if(w < 3 * a) {
          result = w;
        } else {
          let D = Math.max(2, a * (a - 1));
          let lg = Gamma.lgamma(a).result;
          let lb = Math.log(q) + lg;
          if(lb < -D * 2.3) {
            // DiDonato and Morris Eq 25:
            let y = -lb;
            let c1 = (a - 1) * Math.log(y);
            let c1_2 = c1 * c1;
            let c1_3 = c1_2 * c1;
            let c1_4 = c1_2 * c1_2;
            let a_2 = a * a;
            let a_3 = a_2 * a;

            let c2 = (a - 1) * (1 + c1);
            let c3 = (a - 1) * (-(c1_2 / 2) + (a - 2) * c1 + (3 * a - 5) / 2);
            let c4 = (a - 1) * ((c1_3 / 3) - (3 * a - 5) * c1_2 / 2 + (a_2 - 6 * a + 7) *
              c1 + (11 * a_2 - 46 * a + 47) / 6);
            let c5 = (a - 1) * (-(c1_4 / 4)
            + (11 * a - 17) * c1_3 / 6
            + (-3 * a_2 + 13 * a -13) * c1_2
            + (2 * a_3 - 25 * a_2 + 72 * a - 61) * c1 / 2
            + (25 * a_3 - 195 * a_2 + 477 * a - 379) / 12);

            let y_2 = y * y;
            let y_3 = y_2 * y;
            let y_4 = y_2 * y_2;
            result = y + c1 + (c2 / y) + (c3 / y_2) + (c4 / y_3) + (c5 / y_4);
          } else {
            // DiDonato and Morris Eq 33:
            let u = -lb + (a - 1) * Math.log(w) - Math.log(1 + (1 - a) / (1 + w));
            result = -lb + (a - 1) * Math.log(u) - Math.log(1 + (1 - a) / (1 + u));
          }
        }
      } else {
        let z = w;
        let ap1 = a + 1;
        let ap2 = a + 2;
        if(w < 0.15 * ap1) {
          // DiDonato and Morris Eq 35:
          let v = Math.log(p) + Gamma.lgamma(ap1).result;
          z = Math.exp((v + w) / a);
          s = Log1p.log1p(z / ap1 * (1 + z / ap2));
          z = Math.exp((v + z - s) / a);
          s = Log1p.log1p(z / ap1 * (1 + z / ap2));
          z = Math.exp((v + z - s) / a);
          s = Log1p.log1p(z / ap1 * (1 + z / ap2 * (1 + z / (a + 3))));
          z = Math.exp((v + z - s) / a);
        }

        if((z <= 0.01 * ap1) || (z > 0.7 * ap1)) {
          result = z;
          if(z <= 0.002 * ap1) {
            p_has_10_digits = true;
          }

        } else {
          // DiDonato and Morris Eq 36:
          let ls = Math.log(IGammaInverse.didonato_SN(a, z, 100, 1e-4));
          let v = Math.log(p) + Gamma.lgamma(ap1).result;
          z = Math.exp((v + z - ls) / a);
          result = z * (1 - (a * Math.log(z) - z - v + ls) / (a - z));
        }
      }
    }
    return {result: result, has_10_digits: p_has_10_digits};
  }

  private static gamma_p_inverse_func(a: number, p: number, inv: boolean):
  (x: number) => {f0: number, f1: number, f2: number} {
    let invert = inv;

    if (p > 0.9) {
      p = 1-p;
      invert = !invert;
    }

    return (x: number): {f0: number, f1: number, f2: number} => {
      let f0, f1;
      let ft;
      let fResult = Gamma.gamma_incomplete_imp(
        a,
        x,
        true,
        invert
      );
      f0 = fResult.result;
      ft = fResult.pderivative;
      f1 = ft;
      let f2;
      let div = (a - x - 1) / x;
      f2 = f1;
      if((Math.abs(div) > 1) && (Number.MAX_VALUE / Math.abs(div) < f2)){
        // overflow:
        f2 = -Number.MAX_VALUE / 2;
      } else {
        f2 *= div;
      }

      if(invert) {
        f1 = -f1;
        f2 = -f2;
      }

      return {f0: f0-p, f1: f1, f2: f2}
    }
  }

  private static gamma_p_inv_imp(a: number, p: number): number {

    if(a <= 0) {
      throw new Error(`Domain error: Argument a in the incomplete gamma function${""
      } inverse must be >= 0 (got a=${a})`);
    }
    if((p < 0) || (p > 1)) {
      throw new Error(`Domain error: Probability must be in the range [0,1] in the${""
      } incomplete gamma function inverse (got p=${p}).`);
    }
    if(p === 1) {
      return Gamma.tgamma(a);
    }
    if(p === 0) {
      return 0;
    }

    let guessObj = IGammaInverse.find_inverse_gamma(a, p, 1 - p);
    let has_10_digits: boolean = guessObj.has_10_digits;
    let guess = guessObj.result;
    if( has_10_digits) {
      return guess;
    }

    let lower = Number.MIN_VALUE;
    if(guess <= lower) {
      guess = Number.MIN_VALUE;
    }

    //
    // Work out how many digits to converge to, normally this is
    // 2/3 of the digits in T, but if the first derivative is very
    // large convergence is slow, so we'll bump it up to full
    // precision to prevent premature termination of the root-finding routine.
    //
    let digits = 53;
    if(digits < 30) {
      digits *= 2;
      digits /= 3;
    } else {
      digits /= 2;
      digits -= 1;
    }
    if((a < 0.125) &&
      (Math.abs(Gamma.gamma_p_derivative(a, guess)) >
      1 / Math.sqrt(Precision.epsilon()))) {
      digits = 51;
    }

    //
    // Go ahead and iterate:
    //
    let max_iter = 500;
    guess = Roots.halley_iterate(
      IGammaInverse.gamma_p_inverse_func(a, p, false),
      guess,
      lower,
      Number.MAX_VALUE,
      digits,
      max_iter).result;
    if(guess === lower) {
      throw new Error(`Underflow error: Expected result known to be non-zero, but is${""
      } smaller than the smallest available number.`);
    }

    return guess;
  }

  private static gamma_q_inv_imp(a: number, q: number): number {
    if(a <= 0) {
      throw new Error(`Domain error: Argument a in the incomplete gamma function${""
        } inverse must be >= 0 (got a=${a})`);
    }
    if((q < 0) || (q > 1)) {
      throw new Error(`Domain error: Probability must be in the range [0,1] in the${""
        } incomplete gamma function inverse (got q=${q}).`);
    }
    if(q === 0) {
      return Gamma.tgamma(a);
    }
    if(q === 1) {
      return 0;
    }

    let guessObj = IGammaInverse.find_inverse_gamma(a, 1-q, q);
    let has_10_digits = guessObj.has_10_digits;
    let guess = guessObj.result;
    if(has_10_digits) {
      return guess;
    }
    let lower = Number.MIN_VALUE;
    if(guess <= lower) {
      guess = Number.MIN_VALUE;
    }

    //
    // Work out how many digits to converge to, normally this is
    // 2/3 of the digits in T, but if the first derivative is very
    // large convergence is slow, so we'll bump it up to full
    // precision to prevent premature termination of the root-finding routine.
    //
    let digits = 53;
    if(digits < 30) {
      digits *= 2;
      digits /= 3;
    } else {
      digits /= 2;
      digits -= 1;
    }
    if((a < 0.125) &&
      (Math.abs(Gamma.gamma_p_derivative(a, guess)) >
      1 / Math.sqrt(Precision.epsilon()))) {
      digits = 53;
    }
    //
    // Go ahead and iterate:
    //
    let max_iter = 500;
    guess = Roots.halley_iterate(
      IGammaInverse.gamma_p_inverse_func(a, q, true),
      guess,
      lower,
      Number.MAX_VALUE,
      digits,
      max_iter).result;

    if(guess === lower) {
      throw new Error(`Underflow error: Expected result known to be non-zero, but is${""
      } smaller than the smallest available number.`);
    }

    return guess;
  }

  public static gamma_p_inv(a: number, p: number): number {
    return IGammaInverse.gamma_p_inv_imp(a, p);
  }

  public static gamma_q_inv(a: number, q: number): number {
    return IGammaInverse.gamma_q_inv_imp(a, q);
  }

}
