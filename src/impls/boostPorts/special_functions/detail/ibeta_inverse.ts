"use strict";

/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Paul A. Bristow 2007.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const Constants = require("../../tools/constants").Constants;
const ErfInv = require("./erf_inv").ErfInv;
const Rational = require("../../tools/rational").Rational;
const Roots = require("../../tools/roots").Roots;
const IGammaInverse = require("./igamma_inverse").IGammaInverse;
const Beta = require("../beta").Beta;
const InverseStudentsT = require("./t_distribution_inv").InverseStudentsT;
const Expm1 = require("../expm1").Expm1;
const Log1p = require("../log1p").Log1p;
const Precision = require("../../tools/precision").Precision;


export class IBetaInverse {

  private static temme_root_finder(t: number, a: number):
  (x: number) => {f0: number, f1: number} {
    return (x: number): {f0: number, f1: number} => {
      let y = 1 - x;
      if(y === 0) {
        const big = Number.MAX_VALUE / 4;
        return {f0: -big, f1: -big};
      }
      if(x === 0) {
        const big = Number.MAX_VALUE / 4;
        return {f0: -big, f1: big};
      }
      const f0 = Math.log(x) + a * Math.log(y) + t;
      const f1 = (1 / x) - (a / (y));
      return {f0: f0, f1: f1};
    }
  }

  /**
   * See:
   * "Asymptotic Inversion of the Incomplete BetaDist Function"
   * N.M. Temme
   * Journal of Computation and Applied Mathematics 41 (1992) 145-157.
   * Section 2.
   */
  private static temme_method_1_ibeta_inverse(a: number, b: number, z: number): number {
    const r2 = Constants.SQRT2();
    //
    // get the first approximation for eta from the inverse
    // error function (Eq: 2.9 and 2.10).
    //
    let eta0 = ErfInv.erfc_inv(2 * z);
    eta0 /= -Math.sqrt(a / 2);

    const terms = [eta0];
    const workspace1: number[] = [];
    const workspace2: number[] = [];
    const workspace3: number[] = [];
    //
    // calculate powers:
    //
    let B = b - a;
    let B_2 = B * B;
    let B_3 = B_2 * B;
    //
    // Calculate correction terms:
    //

    // See eq following 2.15:
    workspace1.push(-B * r2 / 2);
    workspace1.push((1 - 2 * B) / 8);
    workspace1.push(-(B * r2 / 48));
    workspace1.push((-1) / 192);
    workspace1.push(-B * r2 / 3840);
    terms.push(Rational.evaluate_polynomial(workspace1, eta0));
    // Eq Following 2.17:
    workspace2.push(B * r2 * (3 * B - 2) / 12);
    workspace2.push((20 * B_2 - 12 * B + 1) / 128);
    workspace2.push(B * r2 * (20 * B - 1) / 960);
    workspace2.push((16 * B_2 + 30 * B - 15) / 4608);
    workspace2.push(B * r2 * (21 * B + 32) / 53760);
    workspace2.push((-32 * B_2 + 63) / 368640);
    workspace2.push(-B * r2 * (120 * B + 17) / 25804480);
    terms.push(Rational.evaluate_polynomial(workspace2, eta0));
    // Eq Following 2.17:
    workspace3.push(B * r2 * (-75 * B_2 + 80 * B - 16) / 480);
    workspace3.push((-1080 * B_3 + 868 * B_2 - 90 * B - 45) / 9216);
    workspace3.push(B * r2 * (-1190 * B_2 + 84 * B + 373) / 53760);
    workspace3.push((-2240 * B_3 - 2508 * B_2 + 2100 * B - 165) / 368640);
    terms.push(Rational.evaluate_polynomial(workspace3, eta0));
    //
    // Bring them together to get a final estimate for eta:
    //
    let eta = Rational.evaluate_polynomial(terms, 1/a);
    //
    // now we need to convert eta to x, by solving the appropriate
    // quadratic equation:
    //
    let eta_2 = eta * eta;
    let c = -Math.exp(-eta_2 / 2);
    let x;
    if(eta_2 === 0) {
      x = 0.5;
    } else {
      x = (1 + eta * Math.sqrt((1 + c) / eta_2)) / 2;
    }

    return x;
  }

  /**
   * See:
   * "Asymptotic Inversion of the Incomplete BetaDist Function"
   * N.M. Temme
   * Journal of Computation and Applied Mathematics 41 (1992) 145-157.
   * Section 3.
   */
  private static temme_method_2_ibeta_inverse(a: number,
                                              b: number,
                                              z: number,
                                              r: number,
                                              theta: number): number {
    //
    // Get first estimate for eta, see Eq 3.9 and 3.10,
    // but note there is a typo in Eq 3.10:
    //
    let eta0 = ErfInv.erfc_inv(2 * z);
    eta0 /= -Math.sqrt(r / 2);

    let s = Math.sin(theta);
    let c = Math.cos(theta);
    //
    // Now we need to purturb eta0 to get eta, which we do by
    // evaluating the polynomial in 1/r at the bottom of page 151,
    // to do this we first need the error terms e1, e2 e3
    // which we'll fill into the array "terms".  Since these
    // terms are themselves polynomials, we'll need another
    // array "workspace" to calculate those...
    //
    const terms: number[] = [eta0];
    const workspace1: number[] = [];
    const workspace2: number[] = [];
    const workspace3: number[] = [];
    const workspace4: number[] = [];
    const workspace5: number[] = [];
    //
    // some powers of sin(theta)cos(theta) that we'll need later:
    //
    let sc = s * c;
    let sc_2 = sc * sc;
    let sc_3 = sc_2 * sc;
    let sc_4 = sc_2 * sc_2;
    let sc_5 = sc_2 * sc_3;
    let sc_6 = sc_3 * sc_3;
    let sc_7 = sc_4 * sc_3;
    //
    // Calculate e1 and put it in terms[1], see the middle of page 151:
    //
    workspace1.push((2 * s * s - 1) / (3 * s * c));
    const co1: number[] = [-1, -5, 5];
    workspace1.push(-Rational.evaluate_even_polynomial(co1, s) / (36 * sc_2));
    const co2: number[] = [1, 21, -69, 46];
    workspace1.push(Rational.evaluate_even_polynomial(co2, s) / (1620 * sc_3));
    const co3: number[] = [7, -2, 33, -62, 31];
    workspace1.push(-Rational.evaluate_even_polynomial(co3, s) / (6480 * sc_4));
    const co4: number[] = [25, -52, -17, 88, -115, 46];
    workspace1.push(Rational.evaluate_even_polynomial(co4, s) / (90720 * sc_5));
    terms.push(Rational.evaluate_polynomial(workspace1, eta0));
    //
    // Now evaluate e2 and put it in terms[2]:
    //
    const co5: number[] = [7, 12, -78, 52];
    workspace2.push(-Rational.evaluate_even_polynomial(co5, s) / (405 * sc_3));
    const co6: number[] = [-7, 2, 183, -370, 185];
    workspace2.push(Rational.evaluate_even_polynomial(co6, s) / (2592 * sc_4));
    const co7: number[] = [-533, 776, -1835, 10240, -13525, 5410];
    workspace2.push(-Rational.evaluate_even_polynomial(co7, s) / (204120 * sc_5));
    const co8: number[] = [-1579, 3747, -3372, -15821, 45588, -45213, 15071];
    workspace2.push(-Rational.evaluate_even_polynomial(co8, s) / (2099520 * sc_6));
    terms.push(Rational.evaluate_polynomial(workspace2, eta0));
    //
    // And e3, and put it in terms[3]:
    //
    const co9: number[] = [449, -1259, -769, 6686, -9260, 3704];
    workspace3.push(Rational.evaluate_even_polynomial(co9, s) / (102060 * sc_5));
    const co10: number[] = [63149, -151557, 140052, -727469, 2239932, -2251437, 750479];
    workspace3.push(-Rational.evaluate_even_polynomial(co10, s) / (20995200 * sc_6));
    const co11: number[] = [
      29233,
      -78755,
      105222,
      146879,
      -1602610,
      3195183,
      -2554139,
      729754
    ];
    workspace3.push(Rational.evaluate_even_polynomial(co11, s) / (36741600 * sc_7));
    terms.push(Rational.evaluate_polynomial(workspace3, eta0));
    //
    // Bring the correction terms together to evaluate eta,
    // this is the last equation on page 151:
    //
    let eta = Rational.evaluate_polynomial(terms, 1/r);
    //
    // Now that we have eta we need to back solve for x,
    // we seek the value of x that gives eta in Eq 3.2.
    // The two methods used are described in section 5.
    //
    // Begin by defining a few variables we'll need later:
    //
    let x;
    let s_2 = s * s;
    let c_2 = c * c;
    let alpha = c / s;
    alpha *= alpha;
    let lu = (-(eta * eta) / (2 * s_2) + Math.log(s_2) + c_2 * Math.log(c_2) / s_2);
    //
    // Temme doesn't specify what value to switch on here,
    // but this seems to work pretty well:
    //
    if(Math.abs(eta) < 0.7) {
      //
      // Small eta use the expansion Temme gives in the second equation
      // of section 5, it's a polynomial in eta:
      //
      workspace4.push(s * s);
      workspace4.push(s * c);
      workspace4.push((1 - 2 * workspace4[0]) / 3);
      const co12: number[] = [1, -13, 13];
      workspace4.push(Rational.evaluate_polynomial(co12, workspace4[0])/(36*s*c));
      const co13: number[] = [1, 21, -69, 46];
      workspace4.push(Rational.evaluate_polynomial(co13, workspace4[0]) /
        (270*workspace4[0]*c*c));
      x = Rational.evaluate_polynomial(workspace4, eta);
    } else {
      //
      // If eta is large we need to solve Eq 3.2 more directly,
      // begin by getting an initial approximation for x from
      // the last equation on page 155, this is a polynomial in u:
      //
      let u = Math.exp(lu);
      workspace5.push(u);
      workspace5.push(alpha);
      workspace5.push(0);
      workspace5.push(3 * alpha * (3 * alpha + 1) / 6);
      workspace5.push(4 * alpha * (4 * alpha + 1) * (4 * alpha + 2) / 24);
      workspace5.push(5 * alpha * (5 * alpha + 1) * (5 * alpha + 2) * (5 * alpha +3)/120);
      x = Rational.evaluate_polynomial(workspace5, u);
      //
      // At this point we may or may not have the right answer, Eq-3.2 has
      // two solutions for x for any given eta, however the mapping in 3.2
      // is 1:1 with the sign of eta and x-sin^2(theta) being the same.
      // So we can check if we have the right root of 3.2, and if not
      // switch x for 1-x.  This transformation is motivated by the fact
      // that the distribution is *almost* symetric so 1-x will be in the right
      // ball park for the solution:
      //
      if((x - s_2) * eta < 0) {
        x = 1 - x;
      }
    }
    //
    // The final step is a few Newton-Raphson iterations to
    // clean up our approximation for x, this is pretty cheap
    // in general, and very cheap compared to an incomplete beta
    // evaluation.  The limits set on x come from the observation
    // that the sign of eta and x-sin^2(theta) are the same.
    //
    let lower, upper;
    if(eta < 0) {
      lower = 0;
      upper = s_2;
    } else {
      lower = s_2;
      upper = 1;
    }
    //
    // If our initial approximation is out of bounds then bisect:
    //
    if((x < lower) || (x > upper)) {
      x = (lower+upper) / 2;
    }

    //
    // And iterate:
    //
    x = Roots.newton_raphson_iterate(
      IBetaInverse.temme_root_finder(-lu, alpha),
      x,
      lower,
      upper,
      53 / 2,  // <== Todo: make sure this is OK
      500
    );

    return x.result;
  }

  /**
   * See:
   * "Asymptotic Inversion of the Incomplete BetaDist Function"
   * N.M. Temme
   * Journal of Computation and Applied Mathematics 41 (1992) 145-157.
   * Section 4.
   */
  private static temme_method_3_ibeta_inverse(a: number, b: number, p: number, q: number):
  number {
    //
    // Begin by getting an initial approximation for the quantity
    // eta from the dominant part of the incomplete beta:
    //
    let eta0;
    if(p < q) {
      eta0 = IGammaInverse.gamma_q_inv(b, p);
    } else {
      eta0 = IGammaInverse.gamma_p_inv(b, q);
    }

    eta0 /= a;
    //
    // Define the variables and powers we'll need later on:
    //
    let mu = b / a;
    let w = Math.sqrt(1 + mu);
    let w_2 = w * w;
    let w_3 = w_2 * w;
    let w_4 = w_2 * w_2;
    let w_5 = w_3 * w_2;
    let w_6 = w_3 * w_3;
    let w_7 = w_4 * w_3;
    let w_8 = w_4 * w_4;
    let w_9 = w_5 * w_4;
    let w_10 = w_5 * w_5;
    let d = eta0 - mu;
    let d_2 = d * d;
    let d_3 = d_2 * d;
    let d_4 = d_2 * d_2;
    let w1 = w + 1;
    let w1_2 = w1 * w1;
    let w1_3 = w1 * w1_2;
    let w1_4 = w1_2 * w1_2;
    //
    // Now we need to compute the purturbation error terms that
    // convert eta0 to eta, these are all polynomials of polynomials.
    // Probably these should be re-written to use tabulated data
    // (see examples above), but it's less of a win in this case as we
    // need to calculate the individual powers for the denominator terms
    // anyway, so we might as well use them for the numerator-polynomials
    // as well....
    //
    // Refer to p154-p155 for the details of these expansions:
    //
    let e1 = (w + 2) * (w - 1) / (3 * w);
    e1 += (w_3 + 9 * w_2 + 21 * w + 5) * d / (36 * w_2 * w1);
    e1 -= (w_4 - 13 * w_3 + 69 * w_2 + 167 * w + 46) * d_2 / (1620 * w1_2 * w_3);
    e1 -= (7 * w_5 + 21 * w_4 + 70 * w_3 + 26 * w_2 - 93 * w - 31) * d_3 /
      (6480 * w1_3 * w_4);
    e1 -= (75 * w_6 + 202 * w_5 + 188 * w_4 - 888 * w_3 - 1345 * w_2 + 118 * w + 138) *
      d_4 / (272160 * w1_4 * w_5);

    let e2 = (28 * w_4 + 131 * w_3 + 402 * w_2 + 581 * w + 208) * (w - 1) /
      (1620 * w1 * w_3);
    e2 -= (35 * w_6 - 154 * w_5 - 623 * w_4 - 1636 * w_3 - 3983 * w_2 - 3514 * w - 925) *
      d / (12960 * w1_2 * w_4);
    e2 -= (2132 * w_7 + 7915 * w_6 + 16821 * w_5 + 35066 * w_4 + 87490 * w_3 + 141183 *
      w_2 + 95993 * w + 21640) * d_2  / (816480 * w_5 * w1_3);
    e2 -= (11053 * w_8 + 53308 * w_7 + 117010 * w_6 + 163924 * w_5 + 116188 * w_4 -
      258428 * w_3 - 677042 * w_2 - 481940 * w - 105497) * d_3 / (14696640 * w1_4 * w_6);

    let e3 = -((3592 * w_7 + 8375 * w_6 - 1323 * w_5 - 29198 * w_4 - 89578 * w_3 -
      154413 * w_2 - 116063 * w - 29632) * (w - 1)) / (816480 * w_5 * w1_2);
    e3 -= (442043 * w_9 + 2054169 * w_8 + 3803094 * w_7 + 3470754 * w_6 + 2141568 * w_5 -
      2393568 * w_4 - 19904934 * w_3 - 34714674 * w_2 - 23128299 * w - 5253353) * d /
      (146966400 * w_6 * w1_3);
    e3 -= (116932 * w_10 + 819281 * w_9 + 2378172 * w_8 + 4341330 * w_7 + 6806004 * w_6 +
      10622748 * w_5 + 18739500 * w_4 + 30651894 * w_3 + 30869976 * w_2 + 15431867 * w +
      2919016) * d_2 / (146966400 * w1_4 * w_7);
    //
    // Combine eta0 and the error terms to compute eta (Second eqaution p155):
    //
    let eta = eta0 + e1 / a + e2 / (a * a) + e3 / (a * a * a);
    //
    // Now we need to solve Eq 4.2 to obtain x.  For any given value of
    // eta there are two solutions to this equation, and since the distribtion
    // may be very skewed, these are not related by x ~ 1-x we used when
    // implementing section 3 above.  However we know that:
    //
    //  cross < x <= 1       ; iff eta < mu
    //          x == cross   ; iff eta == mu
    //     0 <= x < cross    ; iff eta > mu
    //
    // Where cross == 1 / (1 + mu)
    // Many thanks to Prof Temme for clarifying this point.
    //
    // Therefore we'll just jump straight into Newton iterations
    // to solve Eq 4.2 using these bounds, and simple bisection
    // as the first guess, in practice this converges pretty quickly
    // and we only need a few digits correct anyway:
    //
    if(eta <= 0) {
      eta = Number.MIN_VALUE;
    }

    const u = eta - mu * Math.log(eta) + (1 + mu) * Math.log(1 + mu) - mu;
    const cross = 1 / (1 + mu);
    const lower = eta < mu ? cross : 0;
    const upper = eta < mu ? 1 : cross;
    let x = (lower + upper) / 2;
    const nrResult = Roots.newton_raphson_iterate(
      IBetaInverse.temme_root_finder(u, mu),
      x,
      lower,
      upper,
      53 / 2,  // <== todo: make sure this is ok
      500
    );
    x = nrResult.result;

    return x;
  }

  private static ibeta_roots(a: number, b: number, t: number, inv: boolean = false):
  (x: number) => {f0: number, f1: number, f2: number} {
    let target = t;
    let invert = inv;

    return (x: number): {f0: number, f1: number, f2: number} => {
      let y = 1 - x;
      let iBetaEval = Beta.ibeta_imp(a, b, x, invert, true);
      let f1 = iBetaEval.pderivative;

      let f = iBetaEval.result - target;
      if(invert) {
        f1 = -f1;
      }
      if(y === 0) {
        y = Number.MIN_VALUE * 64;
      }

      if(x === 0) {
        x = Number.MIN_VALUE * 64;
      }


      let f2 = f1 * (-y * a + (b - 2) * x + 1);

      if(Math.abs(f2) < y * x * Number.MAX_VALUE) {
        f2 /= (y * x);
      }
      if(invert) {
        f2 = -f2;
      }
      // make sure we don't have a zero derivative:
      if(f1 === 0) {
        f1 = (invert ? -1 : 1) * Number.MIN_VALUE * 64;
      }

      return {f0: f, f1: f1, f2: f2};
    }
  }

  private static ibeta_inv_imp(a: number, b: number, p: number, q: number):
  {result: number, py: number} {
    //
    // The flag invert is set to true if we swap a for b and p for q,
    // in which case the result has to be subtracted from 1:
    //
    let invert: boolean = false;
    let py: number;
    //
    // Handle trivial cases first:
    //
    if(q === 0) {
      return {result: 1, py: 0};
    }
    else if(p == 0) {
      return {result: 0, py: 1};
    }
    else if(a === 1) {
      if(b === 1) {
        return {result: p, py: 1-p};
      }
      // Change things around so we can handle as b == 1 special case below:
      const temp1 = a;
      a = b;
      b = temp1;
      const temp2 = p;
      p = q;
      q = temp2;
      invert = true;
    }
    //
    // Depending upon which approximation method we use, we may end up
    // calculating either x or y initially (where y = 1-x):
    //
    let x = 0; // Set to a safe zero to avoid a
    // MSVC 2005 warning C4701: potentially uninitialized local variable 'x' used
    // But code inspection appears to ensure that x IS assigned whatever the code path.
    let y;

    // For some of the methods we can put tighter bounds
    // on the result than simply [0,1]:
    //
    let lower = 0;
    let upper = 1;
    //
    // Student's T with b = 0.5 gets handled as a special case, swap
    // around if the arguments are in the "wrong" order:
    //
    if(a === 0.5) {
      if(b === 0.5) {
        x = Math.sin(p * Constants.HALFPI());
        x *= x;
        py = Math.sin(q * Constants.HALFPI());
        py *= py;

        return {result: x, py: py};
      } else if(b > 0.5) {
        const temp1 = a;
        a = b;
        b = temp1;
        const temp2 = p;
        p = q;
        q = temp2;
        invert = !invert;
      }
    }
    //
    // Select calculation method for the initial estimate:
    //
    if((b === 0.5) && (a >= 0.5) && (p !== 1)) {
      //
      // We have a Student's T distribution:
      let resultObj = InverseStudentsT.find_ibeta_inv_from_t_dist(a, p, q);
      x = resultObj.result;
      y = resultObj.py;
    } else if(b === 1) {
      if(p < q) {
        if(a > 1) {
          x = Math.pow(p, 1 / a);
          y = -Expm1.expm1(Math.log(p) / a);
        } else {
          x = Math.pow(p, 1 / a);
          y = 1 - x;
        }
      } else {
        x = Math.exp(Log1p.log1p(-q) / a);
        y = -Expm1.expm1(Log1p.log1p(-q) / a);
      }
      if(invert) {
        const temp = x;
        x = y;
        y = temp;
      }

      py = y;
      return {result: x, py: py};
    } else if(a + b > 5) {
      //
      // When a+b is large then we can use one of Prof Temme's
      // asymptotic expansions, begin by swapping things around
      // so that p < 0.5, we do this to avoid cancellations errors
      // when p is large.
      //
      if(p > 0.5) {
        const temp1 = a;
        a = b;
        b = temp1;
        const temp2 = p;
        p = q;
        q = temp2;
        invert = !invert;
      }
      let minv = Math.min(a, b);
      let maxv = Math.max(a, b);

      if((Math.sqrt(minv) > (maxv - minv)) && (minv > 5)) {
        //
        // When a and b differ by a small amount
        // the curve is quite symmetrical and we can use an error
        // function to approximate the inverse. This is the cheapest
        // of the three Temme expantions, and the calculated value
        // for x will never be much larger than p, so we don't have
        // to worry about cancellation as long as p is small.
        //
        x = IBetaInverse.temme_method_1_ibeta_inverse(a, b, p);
        y = 1 - x;
      } else {
        let r = a + b;
        let theta = Math.asin(Math.sqrt(a / r));
        let lambda = minv / r;
        if((lambda >= 0.2) && (lambda <= 0.8) && (r >= 10)) {
          //
          // The second error function case is the next cheapest
          // to use, it brakes down when the result is likely to be
          // very small, if a+b is also small, but we can use a
          // cheaper expansion there in any case.  As before x won't
          // be much larger than p, so as long as p is small we should
          // be free of cancellation error.
          //
          let ppa = Math.pow(p, 1/a);
          if((ppa < 0.0025) && (a + b < 200)) {
            x = ppa * Math.pow(a * Beta.beta(a, b), 1/a);
          } else {
            x = IBetaInverse.temme_method_2_ibeta_inverse(a, b, p, r, theta);
          }
          y = 1 - x;
        } else {
          //
          // If we get here then a and b are very different in magnitude
          // and we need to use the third of Temme's methods which
          // involves inverting the incomplete gamma.  This is much more
          // expensive than the other methods.  We also can only use this
          // method when a > b, which can lead to cancellation errors
          // if we really want y (as we will when x is close to 1), so
          // a different expansion is used in that case.
          //
          if(a < b) {
            const temp1 = a;
            a = b;
            b = temp1;
            const temp2 = p;
            p = q;
            q = temp2;
            invert = !invert;
          }
          //
          // Try and compute the easy way first:
          //
          let bet = 0;
          if(b < 2) {
            bet = Beta.beta(a, b);
          }

          if(bet !== 0) {
            y = Math.pow(b * q * bet, 1/b);
            x = 1 - y;
          } else {
            y = 1;
          }

          if(y > 1e-5) {
            x = IBetaInverse.temme_method_3_ibeta_inverse(a, b, p, q);
            y = 1 - x;
          }
        }
      }
    } else if((a < 1) && (b < 1)) {
      //
      // Both a and b less than 1,
      // there is a point of inflection at xs:
      //
      let xs = (1 - a) / (2 - a - b);
      //
      // Now we need to ensure that we start our iteration from the
      // right side of the inflection point:
      //
      let fs = Beta.ibeta(a, b, xs) - p;
      if(Math.abs(fs) / p < Precision.epsilon() * 3) {
        // The result is at the point of inflection, best just return it:
        py = invert ? xs : 1 - xs;
        return {result: invert ? 1-xs : xs, py: py};
      }
      if(fs < 0) {
        const temp1 = a;
        a = b;
        b = temp1;
        const temp2 = p;
        p = q;
        q = temp2;
        invert = !invert;
        xs = 1 - xs;
      }
      let xg = Math.pow(a * p * Beta.beta(a, b), 1/a);
      x = xg / (1 + xg);
      y = 1 / (1 + xg);
      //
      // And finally we know that our result is below the inflection
      // point, so set an upper limit on our search:
      //
      if(x > xs) {
        x = xs;
      }

      upper = xs;
    } else if((a > 1) && (b > 1)) {
      //
      // Small a and b, both greater than 1,
      // there is a point of inflection at xs,
      // and it's complement is xs2, we must always
      // start our iteration from the right side of the
      // point of inflection.
      //
      let xs = (a - 1) / (a + b - 2);
      let xs2 = (b - 1) / (a + b - 2);
      let ps = Beta.ibeta(a, b, xs) - p;

      if(ps < 0) {
        const temp1 = a;
        a = b;
        b = temp1;
        const temp2 = p;
        p = q;
        q = temp2;
        const temp3 = xs;
        xs = xs2;
        xs2 = temp3;
        invert = !invert;
      }
      //
      // Estimate x and y, using expm1 to get a good estimate
      // for y when it's very small:
      //
      let lx = Math.log(p * a * Beta.beta(a, b)) / a;
      x = Math.exp(lx);
      y = x < 0.9 ? 1 - x : (-Expm1.expm1(lx));

      if((b < a) && (x < 0.2)) {
        //
        // Under a limited range of circumstances we can improve
        // our estimate for x, frankly it's clear if this has much effect!
        //
        let ap1 = a - 1;
        let bm1 = b - 1;
        let a_2 = a * a;
        let a_3 = a * a_2;
        let b_2 = b * b;
        let terms: number[] = [0, 1];
        terms.push(bm1 / ap1);
        ap1 *= ap1;
        terms.push(bm1 * (3 * a * b + 5 * b + a_2 - a - 4) / (2 * (a + 2) * ap1));
        ap1 *= (a + 1);
        terms.push(bm1 * (33 * a * b_2 + 31 * b_2 + 8 * a_2 * b_2 - 30 * a * b - 47 * b +
          11 * a_2 * b + 6 * a_3 * b + 18 + 4 * a - a_3 + a_2 * a_2 - 10 * a_2) /
          (3 * (a + 3) * (a + 2) * ap1));
        x = Rational.evaluate_polynomial(terms, x);
      }
      //
      // And finally we know that our result is below the inflection
      // point, so set an upper limit on our search:
      //
      if(x > xs) {
        x = xs;
      }

      upper = xs;
    } else /*if((a <= 1) != (b <= 1))*/{
      //
      // If all else fails we get here, only one of a and b
      // is above 1, and a+b is small.  Start by swapping
      // things around so that we have a concave curve with b > a
      // and no points of inflection in [0,1].  As long as we expect
      // x to be small then we can use the simple (and cheap) power
      // term to estimate x, but when we expect x to be large then
      // this greatly underestimates x and leaves us trying to
      // iterate "round the corner" which may take almost forever...
      //
      // We could use Temme's inverse gamma function case in that case,
      // this works really rather well (albeit expensively) even though
      // strictly speaking we're outside it's defined range.
      //
      // However it's expensive to compute, and an alternative approach
      // which models the curve as a distorted quarter circle is much
      // cheaper to compute, and still keeps the number of iterations
      // required down to a reasonable level.  With thanks to Prof Temme
      // for this suggestion.
      //
      if(b < a) {
        const temp1 = a;
        a = b;
        b = temp1;
        const temp2 = p;
        p = q;
        q = temp2;
        invert = !invert;
      }
      if(Math.pow(p, 1/a) < 0.5) {
        x = Math.pow(p * a * Beta.beta(a, b), 1 / a);
        if(x === 0) {
          x = Number.MIN_VALUE;
        }

        y = 1 - x;
      } else /*if(pow(q, 1/b) < 0.1)*/{
        // model a distorted quarter circle:
        y = Math.pow(1 - Math.pow(p, b * Beta.beta(a, b)), 1/b);
        if(y == 0) {
          y = Number.MIN_VALUE;
        }
        x = 1 - y;
      }
    }

    //
    // Now we have a guess for x (and for y) we can set things up for
    // iteration.  If x > 0.5 it pays to swap things round:
    //
    if(x > 0.5) {
      const temp1 = a;
      a = b;
      b = temp1;
      const temp2 = p;
      p = q;
      q = temp2;
      const temp3 = x;
      x = y;
      y = temp3;
      invert = !invert;
      let l = 1 - upper;
      let u = 1 - lower;
      lower = l;
      upper = u;
    }
    //
    // lower bound for our search:
    //
    // We're not interested in denormalised answers as these tend to
    // these tend to take up lots of iterations, given that we can't get
    // accurate derivatives in this area (they tend to be infinite).
    //
    if(lower === 0) {
      if(invert) {
        //
        // We're not interested in answers smaller than machine epsilon:
        //
        lower = Precision.epsilon();
        if(x < lower) {
          x = lower;
        }
      } else {
        lower = Number.MIN_VALUE;
      }
      if(x < lower) {
        x = lower;
      }
    }
    //
    // Figure out how many digits to iterate towards:
    //
    let digits = 53 / 2; //53 / 2;
    if((x < 1e-50) && ((a < 1) || (b < 1))) {
      //
      // If we're in a region where the first derivative is very
      // large, then we have to take care that the root-finder
      // doesn't terminate prematurely.  We'll bump the precision
      // up to avoid this, but we have to take care not to set the
      // precision too high or the last few iterations will just
      // thrash around and convergence may be slow in this case.
      // Try 3/4 of machine epsilon:
      //
      digits *= 3;
      digits /= 2;
    }
    //
    // Now iterate, we can use either p or q as the target here
    // depending on which is smaller:
    //
    let max_iter = 500;

    const halleyResult = Roots.halley_iterate(
      IBetaInverse.ibeta_roots(a, b, (p < q ? p : q), (p < q ? false : true)),
      x,
      lower,
      upper,
      digits,
      max_iter
    );
    x = halleyResult.result;

    //
    // Tidy up, if "lower" was too high then zero is the best answer we have:
    //
    if(x === lower) {
      x = 0;
    }
    py = invert ? x : 1 - x;

    return {result: invert ? 1-x : x, py: py};
  }

  public static ibeta_inv(a: number, b: number, p: number): {result: number, py: number} {
    if(a <= 0) {
      throw new Error(`Domain error: The argument a to the incomplete beta function${""
      } inverse must be greater than zero (got a=${a}).`);
    }

    if(b <= 0) {
      throw new Error(`Domain error: The argument b to the incomplete beta function${""
      } inverse must be greater than zero (got b=${b}).`);
    }

    if((p < 0) || (p > 1)) {
      throw new Error(`Domain error: Argument p outside the range [0,1] in the${""
      } incomplete beta function inverse (got p=${p}).`);
    }


    let resultObj = IBetaInverse.ibeta_inv_imp(
      a,
      b,
      p,
      1-p,
    );
    let rx = resultObj.result;
    let ry = resultObj.py;

    return {result: rx, py: ry};
  }

  public static ibetac_inv(a: number, b: number, q: number): {result: number, py: number}{
      if(a <= 0) {
        throw new Error(`Domain error: The argument a to the incomplete beta function${""
          } inverse must be greater than zero (got a=${a}).`);
      }

      if(b <= 0) {
        throw new Error(`Domain error: The argument b to the incomplete beta function${""
          } inverse must be greater than zero (got b=${b}).`);
      }

      if((q < 0) || (q > 1)) {
        throw new Error(`Domain error: Argument q outside the range [0,1] in the${""
          } incomplete beta function inverse (got q=${q}).`);
      }


      let resultObj = IBetaInverse.ibeta_inv_imp(
        a,
        b,
        1-q,
        q,
      );
      let rx = resultObj.result;
      let ry = resultObj.py;

      return {result: rx, py: ry};
  }

}

