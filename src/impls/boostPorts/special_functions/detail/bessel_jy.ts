"use strict";

/**
 * (C) Copyright Xiaogang Zhang 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const Gamma = require("../gamma").Gamma;
const SinPI = require("../sin_pi").SinPI;
const Precision = require("../../tools/precision").Precision;
const CosPI = require("../cos_pi").CosPI;
const BesselJYSeries = require("./bessel_jy_series").BesselJYSeries;
const BesselJYAsym = require("./bessel_jy_asym").BesselJYAsym;
const Constants = require("../../tools/constants").Constants;
const UncheckedFactorial = require("./unchecked_factorial").UncheckedFactorial;
const Sign = require("../sign").Sign;


export class BesselJY {

  /**
   * Simultaneous calculation of A&S 9.2.9 and 9.2.10
   * for use in A&S 9.2.5 and 9.2.6.
   * This series is quick to evaluate, but divergent unless
   * x is very large, in fact it's pretty hard to figure out
   * with any degree of precision when this series actually
   * *will* converge!!  Consequently, we may just have to
   * try it and see...
   */
  private static hankel_PQ(v: number, x: number): {ok: boolean, p: number, q: number} {
    const tolerance = 2 * Precision.epsilon();
    let p = 1;
    let q = 0;
    let k = 1;
    let z8 = 8 * x;
    let sq = 1;
    const mu = 4 * v * v;
    let term = 1;
    let ok: boolean = true;
    do {
      term *= (mu - sq * sq) / (k * z8);
      q += term;
      k += 1;
      sq += 2;
      let mult = (sq * sq - mu) / (k * z8);
      ok = Math.abs(mult) < 0.5;
      term *= mult;
      p += term;
      k += 1;
      sq += 2;
    }
    while((Math.abs(term) > tolerance * p) && ok);
    return {ok: ok, p: p, q: q};
  }

  /**
   * Calculate Y(v, x) and Y(v+1, x) by Temme's method, see
   * Temme, Journal of Computational Physics, vol 21, 343 (1976)
   */
  private static temme_jy(v: number, x: number): {Y: number, Y1: number} {
    let g, h, p, q, f, coef, sum, sum1, tolerance;
    let a, d, e, sigma;
    let k;

    // BOOST_ASSERT(fabs(v) <= 0.5f);  // precondition for using this routine

    let gp = Gamma.tgamma1pm1(v);
    let gm = Gamma.tgamma1pm1(-v);
    let spv = SinPI.sin_pi(v);
    let spv2 = SinPI.sin_pi(v/2);
    let xp = Math.pow(x/2, v);

    a = Math.log(x / 2);
    sigma = -a * v;
    d = Math.abs(sigma) < Precision.epsilon() ? 1 : Math.sinh(sigma) / sigma;
    e = Math.abs(v) < Precision.epsilon() ? (v*Math.PI*Math.PI/2) : (2*spv2*spv2/v);

    let g1 = (v === 0) ? (-Math.E) : ((gp - gm) / ((1 + gp) * (1 + gm) * 2 * v));
    let g2 = (2 + gp + gm) / ((1 + gp) * (1 + gm) * 2);
    let vspv = (Math.abs(v) < Precision.epsilon()) ? (1/Math.PI) : (v / spv);
    f = (g1 * Math.cosh(sigma) - g2 * a * d) * 2 * vspv;

    p = vspv / (xp * (1 + gm));
    q = vspv * xp / (1 + gp);

    g = f + e * q;
    h = p;
    coef = 1;
    sum = coef * g;
    sum1 = coef * h;

    let v2 = v * v;
    let coef_mult = -x * x / 4;

    // series summation
    tolerance = Precision.epsilon();
    const max_iter = 500;
    for (k = 1; k < max_iter; k++) {
      f = (k * f + p + q) / (k*k - v2);
      p /= k - v;
      q /= k + v;
      g = f + e * q;
      h = p - k * g;
      coef *= coef_mult / k;
      sum += coef * g;
      sum1 += coef * h;
      if (Math.abs(coef * g) < Math.abs(sum) * tolerance) {
        break;
      }
    }

    return {Y: -sum, Y1: -2 * sum1 / x};
  }

  /**
   * Evaluate continued fraction fv = J_(v+1) / J_v, see
   * Abramowitz and Stegun, Handbook of Mathematical Functions, 1972, 9.1.73
   */
  public static CF1_jy(v: number, x: number): {fv: number, sign: number} {

    let C, D, f, a, b, delta, tiny, tolerance;
    let k;
    let s = 1;

    // |x| <= |v|, CF1_jy converges rapidly
    // |x| > |v|, CF1_jy needs O(|x|) iterations to converge

    // modified Lentz's method, see
    // Lentz, Applied Optics, vol 15, 668 (1976)
    // TODO: see if we can use /tools/fraction for this continued fraction
    tolerance = 2 * Precision.epsilon();
    tiny = Math.sqrt(Number.MIN_VALUE);
    C = f = tiny;                           // b0 = 0, replace with tiny
    D = 0;
    const max_iter = 500;
    for (k = 1; k < max_iter * 100; k++) {
      a = -1;
      b = 2 * (v + k) / x;
      C = b + a / C;
      D = b + a * D;
      if (C == 0) { C = tiny; }
      if (D == 0) { D = tiny; }
      D = 1 / D;
      delta = C * D;
      f *= delta;
      if (D < 0) { s = -s; }
      if (Math.abs(delta - 1) < tolerance)
      { break; }
    }

    return {
      fv: -f,
      sign: s             // sign of denominator
    };
  }

  /**
   * This algorithm was originally written by Xiaogang Zhang
   * using std::complex to perform the complex arithmetic.
   * However, that turns out to 10x or more slower than using
   * all real-valued arithmetic, so it's been rewritten using
   * real values only.
   */
  private static CF2_jy(v: number, x: number): {p: number, q: number} {
    let Cr, Ci, Dr, Di, fr, fi, a, br, bi, delta_r, delta_i, temp;
    let tiny;
    let k;

    // |x| >= |v|, CF2_jy converges rapidly
    // |x| -> 0, CF2_jy fails to converge
    // BOOST_ASSERT(Math.abs(x) > 1);

    // modified Lentz's method, complex numbers involved, see
    // Lentz, Applied Optics, vol 15, 668 (1976)
    // TODO: see if we can use /tools/fraction for this continued fraction
    const tolerance = 2 * Precision.epsilon();
    tiny = Math.sqrt(Number.MIN_VALUE);
    Cr = fr = -0.5 / x;
    Ci = fi = 1;
    //Dr = Di = 0;
    let v2 = v * v;
    a = (0.25 - v2) / x; // Note complex this one time only!
    br = 2 * x;
    bi = 2;
    temp = Cr * Cr + 1;
    Ci = bi + a * Cr / temp;
    Cr = br + a / temp;
    Dr = br;
    Di = bi;
    if (Math.abs(Cr) + Math.abs(Ci) < tiny) { Cr = tiny; }
    if (Math.abs(Dr) + Math.abs(Di) < tiny) { Dr = tiny; }
    temp = Dr * Dr + Di * Di;
    Dr = Dr / temp;
    Di = -Di / temp;
    delta_r = Cr * Dr - Ci * Di;
    delta_i = Ci * Dr + Cr * Di;
    temp = fr;
    fr = temp * delta_r - fi * delta_i;
    fi = temp * delta_i + fi * delta_r;

    const max_iter = 500;
    for (k = 2; k < max_iter; k++) {
      a = k - 0.5;
      a *= a;
      a -= v2;
      bi += 2;
      temp = Cr * Cr + Ci * Ci;
      Cr = br + a * Cr / temp;
      Ci = bi - a * Ci / temp;
      Dr = br + a * Dr;
      Di = bi + a * Di;
      if (Math.abs(Cr) + Math.abs(Ci) < tiny) { Cr = tiny; }
      if (Math.abs(Dr) + Math.abs(Di) < tiny) { Dr = tiny; }
      temp = Dr * Dr + Di * Di;
      Dr = Dr / temp;
      Di = -Di / temp;
      delta_r = Cr * Dr - Ci * Di;
      delta_i = Ci * Dr + Cr * Di;
      temp = fr;
      fr = temp * delta_r - fi * delta_i;
      fi = temp * delta_i + fi * delta_r;
      if (Math.abs(delta_r - 1) + Math.abs(delta_i) < tolerance) {
        break;
      }
    }

    return {p: fr, q: fi};
  }

  public static bessel_jy(v: number, x: number, kind: "need_j" | "need_y"):
  {J: number, Y: number} {
    const need_j = 1;
    const need_y = 2;
    let _kind = kind === "need_j" ? need_j : need_y;
    let J, Y;

    // BOOST_ASSERT(x >= 0);

    let u, Jv, Ju, Yv, Yv1, Yu, Yu1 = 0, fv, fu;
    let W, p, q, gamma, current, prev, next;
    let reflect: boolean = false;
    let n, k;
    let s;
    const org_kind = _kind;
    let cp = 0;
    let sp = 0;

    if (v < 0) {
      reflect = true;
      v = -v;                             // v is non-negative from here
    }

    if (v > Number.MAX_SAFE_INTEGER) {
      throw new Error(`Evaluation error: Order of Bessel function is too large to${""
      } evaluate: got ${v}`);
    }
    n = Math.round(v);
    u = v - n;                              // -1/2 <= u < 1/2

    if(reflect) {
      let z = (u + n % 2);
      cp = CosPI.cos_pi(z);
      sp = SinPI.sin_pi(z);
      if(u !== 0) {
        _kind = need_j | need_y;               // need both for reflection formula
      }

    }

    if(x === 0) {
      if(v === 0) {
        J = 1;
      } else if((u === 0) || !reflect) {
        J = 0;
      } else if(_kind & need_j) {
        throw new Error(`Domain error: Value of Bessel J_v(x) is complex-infinity${""
        } at ${x}`);
      } else {
        J = NaN;  // any value will do, not using J.
      }

      if((_kind & need_y) === 0) {
        Y = NaN; // any value will do, not using Y.
      } else if(v === 0) {
        throw new Error(`Overflow error`);
      } else {
        throw new Error(`Domain error: Value of Bessel Y_v(x) is complex-infinity${""
        } at ${x}`);
      }

      return {J: J, Y: Y};
    }

    // x is positive until reflection
    W = 2 / (x * Math.PI);               // Wronskian
    let Yv_scale = 1;
    if(((_kind & need_y) === 0) && ((x < 1) || (v > x * x / 4) || (x < 5))) {
      //
      // This series will actually converge rapidly for all small
      // x - say up to x < 20 - but the first few terms are large
      // and divergent which leads to large errors :-(
      //
      Jv = BesselJYSeries.bessel_j_small_z_series(v, x);
      Yv = NaN;
    } else if ((x < 1) && (u != 0) &&
              (Math.log(Precision.epsilon() / 2) > v * Math.log((x/2) * (x/2) / v))){
      // Evaluate using series representations.
      // This is particularly important for x << v as in this
      // area temme_jy may be slow to converge, if it converges at all.
      // Requires x is not an integer.
      if (_kind & need_j) {
        Jv = BesselJYSeries.bessel_j_small_z_series(v, x);
      } else {
        Jv = NaN;
      }

      if((org_kind & need_y && (!reflect || (cp !== 0))) ||
         (org_kind & need_j && (reflect && (sp !== 0)))) {
        // Only calculate if we need it, and if the reflection formula will actually use
        // it:
        let resultObj = BesselJYSeries.bessel_y_small_z_series(v, x,);
        Yv = resultObj.result;
        Yv_scale = resultObj.pscale;
      } else {
        Yv = NaN;
      }

    } else if((u === 0) && (x < Precision.epsilon())){
      // Truncated series evaluation for small x and v an integer,
      // much quicker in this area than temme_jy below.
      if (_kind & need_j) {
        Jv = BesselJYSeries.bessel_j_small_z_series(v, x);
      } else {
        Jv = NaN;
      }

      if((org_kind & need_y && (!reflect || (cp !== 0))) ||
         (org_kind & need_j && (reflect && (sp !== 0)))) {
        // Only calculate if we need it, and if the reflection formula will actually use it:
        let resultObj = BesselJYSeries.bessel_yn_small_z(n, x, Yv_scale);
        Yv = resultObj.result;
        Yv_scale = resultObj.scale;
      } else {
        Yv = NaN;
      }

    } else if (BesselJYAsym.asymptotic_bessel_large_x_limit_realv(v, x)) {
      if(_kind & need_y) {
        Yv = BesselJYAsym.asymptotic_bessel_y_large_x_2(v, x);
      } else {
        Yv = NaN; // any value will do, we're not using it.
      }

      if(_kind & need_j) {
        Jv = BesselJYAsym.asymptotic_bessel_j_large_x_2(v, x);
      } else {
        Jv = NaN; // any value will do, we're not using it.
      }

    } else if((x > 8) && BesselJY.hankel_PQ(v, x).ok) {
      const resultObj = BesselJY.hankel_PQ(v, x);
      p = resultObj.p;
      q = resultObj.q;
      //
      // Hankel approximation: note that this method works best when x
      // is large, but in that case we end up calculating sines and cosines
      // of large values, with horrendous resulting accuracy.  It is fast though
      // when it works....
      //
      // Normally we calculate sin/cos(chi) where:
      //
      // chi = x - fmod(T(v / 2 + 0.25f), T(2)) * boost::math::constants::pi<T>();
      //
      // But this introduces large errors, so use sin/cos addition formulae to
      // improve accuracy:
      //
      const mod_v = (v / 2 + 0.25) % 2;  // originally: fmod(v / 2 + 0.25, 2);
      const sx = Math.sin(x);
      const cx = Math.cos(x);
      const sv = SinPI.sin_pi(mod_v);
      const cv = CosPI.cos_pi(mod_v);

      const sc = sx * cv - sv * cx; // == sin(chi);
      const cc = cx * cv + sx * sv; // == cos(chi);
      const chi = Constants.SQRT2() / (Constants.SQRTPI() * Math.sqrt(x));
      Yv = chi * (p * sc + q * cc);
      Jv = chi * (p * cc - q * sc);

    } else if (x <= 2) {                           // x in (0, 2]
      let resultObj = BesselJY.temme_jy(u, x); // Temme series
      Yu = resultObj.Y;
      Yu1 = resultObj.Y1;

      prev = Yu;
      current = Yu1;
      let scale = 1;

      for (k = 1; k <= n; k++) {            // forward recurrence for Y
        let fact = 2 * (u + k) / x;
        if((Number.MAX_VALUE - Math.abs(prev)) / fact < Math.abs(current)){
          scale /= current;
          prev /= current;
          current = 1;
        }
        next = fact * current - prev;
        prev = current;
        current = next;
      }
      Yv = prev;
      Yv1 = current;
      if(_kind & need_j) {
        let resultObj2 = BesselJY.CF1_jy(v, x);         // continued fraction CF1_jy
        fv = resultObj2.fv;
        s = resultObj2.sign;
        Jv = scale * W / (Yv * fv - Yv1);           // Wronskian relation
      } else {
        Jv = NaN;    // any value will do, we're not using it.
      }
      Yv_scale = scale;

    } else {                                    // x in (2, \infty)
      // Get Y(u, x):

      let ratio;
      const resultObj = BesselJY.CF1_jy(v, x);
      fv = resultObj.fv;
      s = resultObj.sign;

      // tiny initial value to prevent overflow
      const init = Math.sqrt(Number.MIN_VALUE);

      prev = fv * s * init;
      current = s * init;
      if(v < UncheckedFactorial.max_factorial()){

        for (k = n; k > 0; k--) {             // backward recurrence for J
          next = 2 * (u + k) * current / x - prev;
          prev = current;
          current = next;
        }
        ratio = (s * init) / current;     // scaling ratio
        // can also call CF1_jy() to get fu, not much difference in precision
        fu = prev / current;
      } else {
        //
        // When v is large we may get overflow in this calculation
        // leading to NaN's and other nasty surprises:
        //
        let over: boolean = false;
        for (k = n; k > 0; k--) {             // backward recurrence for J
          let t = 2 * (u + k) / x;
          if((t > 1) && (Number.MAX_VALUE / t < current)) {
            over = true;
            break;
          }
          next = t * current - prev;
          prev = current;
          current = next;
        }

        if(!over) {
          ratio = (s * init) / current;     // scaling ratio
          // can also call CF1_jy() to get fu, not much difference in precision
          fu = prev / current;
        } else {
          ratio = 0;
          fu = 1;
        }
      }

      const resultObj2 = BesselJY.CF2_jy(u, x); // continued fraction CF2_jy
      p = resultObj2.p;
      q = resultObj2.q;

      const t = u / x - fu;                   // t = J'/J
      gamma = (p - t) / q;
      //
      // We can't allow gamma to cancel out to zero competely as it messes up
      // the subsequent logic.  So pretend that one bit didn't cancel out
      // and set to a suitably small value.  The only test case we've been able to
      // find for this, is when v = 8.5 and x = 4*PI.
      //
      if(gamma === 0) {
        gamma = u * Precision.epsilon() / x;
      }

      Ju = Sign.sign(current) * Math.sqrt(W / (q + gamma * (p - t)));
      Jv = Ju * ratio;                    // normalization

      Yu = gamma * Ju;
      Yu1 = Yu * (u/x - p - q/gamma);

      if(_kind & need_y) {
        // compute Y:
        prev = Yu;
        current = Yu1;
        for (k = 1; k <= n; k++) {            // forward recurrence for Y
          let fact = 2 * (u + k) / x;
          if((Number.MAX_VALUE - Math.abs(prev)) / fact < Math.abs(current)) {
            prev /= current;
            Yv_scale /= current;
            current = 1;
          }
          next = fact * current - prev;
          prev = current;
          current = next;
        }
        Yv = prev;
      } else {
        Yv = NaN; // any value will do, we're not using it.
      }
    }

    if (reflect) {
      if ((sp != 0) && (Number.MAX_VALUE * Math.abs(Yv_scale) < Math.abs(sp * Yv))) {
        if (org_kind & need_j) {
          throw new Error(`Overflow error`);
        } else {
          J = 0;
        }
      } else {
        J = cp * Jv - (sp === 0 ? 0 : (sp * Yv) / Yv_scale);     // reflection formula
      }

      if ((cp !== 0) && (Number.MAX_VALUE * Math.abs(Yv_scale) < Math.abs(cp * Yv))) {
        if (org_kind & need_y) {
          throw new Error(`Overflow error`);
        } else {
          Y = 0;
        }
      } else {
        Y = (sp !== 0 ? sp * Jv : 0) + (cp === 0 ? 0 : (cp * Yv) / Yv_scale);
      }
    } else {
      J = Jv;
      if (Number.MAX_VALUE * Math.abs(Yv_scale) < Math.abs(Yv)) {
        if (org_kind & need_y) {
          throw new Error(`Overflow error`);
        } else {
          Y = 0;
        }
      } else {
        Y = Yv / Yv_scale;
      }
    }

    return {J: J, Y: Y};
  }

}
