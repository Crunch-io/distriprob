"use strict";

/**
 * (C) Copyright John Maddock 2011.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const UncheckedFactorial = require("./unchecked_factorial").UncheckedFactorial;
const Gamma = require("../gamma").Gamma;
const Series = require("../../tools/series").Series;
const Precision = require("../../tools/precision").Precision;
const CosPI = require("../cos_pi").CosPI;


export class BesselJYSeries {

  private static *bessel_j_small_z_series_term(v: number, x: number):
  IterableIterator<number> {
    let N = 0;
    let mult = x / 2;
    mult *= -mult;
    let term = 1;

    while(true) {
      let r = term;
      N++;
      term *= mult / (N * (N + v));
      yield r;
    }
  }

  /**
   * Series evaluation for BesselJ(v, z) as z -> 0.
   * See http://functions.wolfram.com/Bessel-TypeFunctions/BesselJ/06/01/04/01/01/0003/
   * Converges rapidly for all z << v.
   */
  public static bessel_j_small_z_series(v: number, x: number): number {
    let prefix;
    if(v < UncheckedFactorial.max_factorial()) {
      prefix = Math.pow(x / 2, v) / Gamma.tgamma(v+1);
    } else {
      prefix = v * Math.log(x / 2) - Gamma.lgamma(v+1).result;
      prefix = Math.exp(prefix);
    }
    if(0 === prefix) {
      return prefix;
    }

    const s = BesselJYSeries.bessel_j_small_z_series_term(v, x);
    const max_iter = 500;
    const result = Series.sum_series(s, Precision.epsilon(), max_iter, 0).sum;

    return prefix * result;
  }

  private static *bessel_y_small_z_series_term_a(v: number, x: number):
  IterableIterator<number> {
    let N = 0;
    let mult = x / 2;
    mult *= -mult;
    let term = 1;

    while (true) {
      let r = term;
      N++;
      term *= mult / (N * (N - v));
      yield r;
    }
  }

  private static *bessel_y_small_z_series_term_b(v: number, x: number):
  IterableIterator<number> {
    let N = 0;
    let mult = x / 2;
    mult *= -mult;
    let term = 1;

    while (true) {
      let r = term;
      ++N;
      term *= mult / (N * (N + v));
      yield r;
    }
  }

  /**
   * Series form for BesselY as z -> 0,
   * see: http://functions.wolfram.com/Bessel-TypeFunctions/BesselY/06/01/04/01/01/0003/
   * This series is only useful when the second term is small compared to the first
   * otherwise we get catestrophic cancellation errors.
   *
   * Approximating tgamma(v) by v^v, and assuming |tgamma(-z)| < eps we end up requiring:
   * eps/2 * v^v(x/2)^-v > (x/2)^v or log(eps/2) > v log((x/2)^2/v)
   */
  public static bessel_y_small_z_series(v: number, x: number):
  {result: number, pscale: number} {
    let prefix;
    let gam;
    let p = Math.log(x / 2);
    let scale = 1;
    const need_logs: boolean = (v >= UncheckedFactorial.max_factorial()) ||
      (Precision.log_max_value() / v < Math.abs(p));

    if(!need_logs) {
      gam = Gamma.tgamma(v);
      p = Math.pow(x / 2, v);
      if(Number.MAX_VALUE * p < gam){
        scale /= gam;
        gam = 1;
        if(Number.MAX_VALUE * p < gam){
          throw new Error(`Overflow error`);
        }
      }
      prefix = -gam / (Math.PI * p);
    } else {
      gam = Gamma.lgamma(v).result;
      p = v * p;
      prefix = gam - Math.log(Math.PI) - p;
      if(Precision.log_max_value() < prefix) {
        prefix -= Math.log(Number.MAX_VALUE / 4);
        scale /= (Number.MAX_VALUE / 4);
        if(Precision.log_max_value() < prefix) {
          throw new Error(`Overflow error`);
        }
      }
      prefix = -Math.exp(prefix);
    }

    const s = BesselJYSeries.bessel_y_small_z_series_term_a(v, x);
    const max_iter = 500;
    const pscale = scale;
    let result = Series.sum_series(s, Precision.epsilon(), max_iter, 0).sum;
    result *= prefix;

    if(!need_logs) {
      prefix = Gamma.tgamma(-v) * CosPI.cos_pi(v) * p / Math.PI;
    } else {
      let lgamResultObj = Gamma.lgamma(-v);
      let sgn = lgamResultObj.sign;
      prefix = lgamResultObj.result + p;
      prefix = Math.exp(prefix) * sgn / Math.PI;
    }
    let s2 = BesselJYSeries.bessel_y_small_z_series_term_b(v, x);
    const b = Series.sum_series(s2, Precision.epsilon(), max_iter, 0).sum;
    result -= scale * prefix * b;

    return {result: result, pscale: pscale};
  }

  public static bessel_yn_small_z(n: number, z: number, scale: number):
  {result: number, scale: number} {
    //
    // See http://functions.wolfram.com/Bessel-TypeFunctions/BesselY/06/01/04/01/02/
    //
    // Note that when called we assume that x < epsilon and n is a positive integer.
    //

    if(n === 0) {
      return {
        result: (2 / Math.PI) * (Math.log(z / 2) +  Math.E),
        scale: scale
      };
    } else if(n === 1) {
      return {
        result:(z/Math.PI)*Math.log(z/2)-2/(Math.PI*z)-(z/(2 * Math.PI))*(1-2*Math.E),
        scale: scale
      };
    } else if(n === 2) {
      return {
        result: (z*z)/(4*Math.PI)*Math.log(z/2)-(4/(Math.PI*z*z)) -
          ((z*z)/(8*Math.PI))*(3/2-2*Math.E),
        scale: scale
      };
    } else {
      const p = Math.pow(z / 2, n);
      let result = -((UncheckedFactorial.unchecked_factorial(n - 1) / Math.PI));
      if(p * Number.MAX_VALUE < result) {
        const div = Number.MAX_VALUE / 8;
        result /= div;
        scale /= div;
        if(p * Number.MAX_VALUE < result){
          throw new Error(`Overflow error`);
        }
      }
      return {result: result / p, scale: scale};
    }
  }

}