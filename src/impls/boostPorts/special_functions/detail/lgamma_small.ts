"use strict";

/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const Precision = require("../../tools/precision").Precision;
const Rational = require("../../tools/rational").Rational;


export class LGammaSmall {

  public static lgamma_small_imp(z: number, zm1: number, zm2: number): number {
    // This version uses rational approximations for small
    // values of z accurate enough for 64-bit mantissas
    // (80-bit long doubles), works well for 53-bit doubles as well.
    // Lanczos is only used to select the Lanczos function.

    let result = 0;
    if(z < Precision.epsilon()){
      result = -Math.log(z);
    } else if((zm1 === 0) || (zm2 === 0)) {
      // nothing to do, result is zero....
    } else if(z > 2) {
      // Begin by performing argument reduction until
      // z is in [2,3):
      if(z >= 3) {
        do {
          z -= 1;
          zm2 -= 1;
          result += Math.log(z);
        } while(z >= 3);
        // Update zm2, we need it below:
        zm2 = z - 2;
      }

      //
      // Use the following form:
      //
      // lgamma(z) = (z-2)(z+1)(Y + R(z-2))
      //
      // where R(z-2) is a rational approximation optimised for
      // low absolute error - as long as it's absolute error
      // is small compared to the constant Y - then any rounding
      // error in it's computation will get wiped out.
      //
      // R(z-2) has the following properties:
      //
      // At double: Max error found:                    4.231e-18
      // At long double: Max error found:               1.987e-21
      // Maximum Deviation Found (approximation error): 5.900e-24
      //
      const P = [
        -0.180355685678449379109e-1,
        0.25126649619989678683e-1,
        0.494103151567532234274e-1,
        0.172491608709613993966e-1,
        -0.259453563205438108893e-3,
        -0.541009869215204396339e-3,
        -0.324588649825948492091e-4
      ];
      const Q = [
        0.1e1,
        0.196202987197795200688e1,
        0.148019669424231326694e1,
        0.541391432071720958364e0,
        0.988504251128010129477e-1,
        0.82130967464889339326e-2,
        0.224936291922115757597e-3,
        -0.223352763208617092964e-6
      ];

      const Y = 0.158963680267333984375;

      let r = zm2 * (z + 1);
      let R = Rational.evaluate_polynomial(P, zm2);
      R /= Rational.evaluate_polynomial(Q, zm2);

      result +=  r * Y + r * R;
    } else {
      //
      // If z is less than 1 use recurrance to shift to
      // z in the interval [1,2]:
      //
      if(z < 1) {
        result += -Math.log(z);
        zm2 = zm1;
        zm1 = z;
        z += 1;
      }
      //
      // Two approximations, on for z in [1,1.5] and
      // one for z in [1.5,2]:
      //
      if(z <= 1.5) {
        //
        // Use the following form:
        //
        // lgamma(z) = (z-1)(z-2)(Y + R(z-1))
        //
        // where R(z-1) is a rational approximation optimised for
        // low absolute error - as long as it's absolute error
        // is small compared to the constant Y - then any rounding
        // error in it's computation will get wiped out.
        //
        // R(z-1) has the following properties:
        //
        // At double precision: Max error found:                1.230011e-17
        // At 80-bit long double precision:   Max error found:  5.631355e-21
        // Maximum Deviation Found:                             3.139e-021
        // Expected Error Term:                                 3.139e-021

        //
        const Y = 0.52815341949462890625;

        const P = [
          0.490622454069039543534e-1,
          -0.969117530159521214579e-1,
          -0.414983358359495381969e0,
          -0.406567124211938417342e0,
          -0.158413586390692192217e0,
          -0.240149820648571559892e-1,
          -0.100346687696279557415e-2
        ];
        const Q = [
          0.1e1,
          0.302349829846463038743e1,
          0.348739585360723852576e1,
          0.191415588274426679201e1,
          0.507137738614363510846e0,
          0.577039722690451849648e-1,
          0.195768102601107189171e-2
        ];

        let r = Rational.evaluate_polynomial(P, zm1) /
          Rational.evaluate_polynomial(Q, zm1);
        let prefix = zm1 * zm2;

        result += prefix * Y + prefix * r;
      } else {
        //
        // Use the following form:
        //
        // lgamma(z) = (2-z)(1-z)(Y + R(2-z))
        //
        // where R(2-z) is a rational approximation optimised for
        // low absolute error - as long as it's absolute error
        // is small compared to the constant Y - then any rounding
        // error in it's computation will get wiped out.
        //
        // R(2-z) has the following properties:
        //
        // At double precision, max error found:              1.797565e-17
        // At 80-bit long double precision, max error found:  9.306419e-21
        // Maximum Deviation Found:                           2.151e-021
        // Expected Error Term:                               2.150e-021
        //
        const Y = 0.452017307281494140625;

        const P = [
          -0.292329721830270012337e-1,
          0.144216267757192309184e0,
          -0.142440390738631274135e0,
          0.542809694055053558157e-1,
          -0.850535976868336437746e-2,
          0.431171342679297331241e-3
        ];
        const Q = [
          0.1e1,
          -0.150169356054485044494e1,
          0.846973248876495016101e0,
          -0.220095151814995745555e0,
          0.25582797155975869989e-1,
          -0.100666795539143372762e-2,
          -0.827193521891290553639e-6
        ];
        let r = zm2 * zm1;
        let R = Rational.evaluate_polynomial(P, -zm2) /
          Rational.evaluate_polynomial(Q, -zm2);

        result += r * Y + r * R;
      }
    }
    return result;
  }

}

