"use strict";

/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const Rational = require("../tools/rational").Rational;


export class Digamma {

  /**
   * Begin by defining the smallest value for which it is safe to
   * use the asymptotic expansion for digamma:
   */
  private static digamma_large_lim(): number {return 10;}

  /**
   * Implementations of the asymptotic expansion come next,
   * the coefficients of the series have been evaluated
   * in advance at high precision, and the series truncated
   * at the first term that's too small to effect the result.
   * Note that the series becomes divergent after a while
   * so truncation is very important.
   */

  /**
   * 17-digit precision for x >= 10:
   */
  private static digamma_imp_large(x: number): number {
    const P: number[] = [
      0.0833333333333333333333,
      -0.0083333333333333333333,
      0.0039682539682539682539,
      -0.0041666666666666666667,
      0.0075757575757575757576,
      -0.0210927960927960927961,
      0.0833333333333333333333,
      -0.443259803921568627451
    ];
    x -= 1;
    let result = Math.log(x);
    result += 1 / (2 * x);
    const z = 1 / (x*x);
    result -= z * Rational.evaluate_polynomial(P, z);
    return result;
  }

  /**
   * Now follow rational approximations over the range [1,2].
   *
   * 18-digit precision:
   */
  private static digamma_imp_1_2(x: number): number {
    //
    // Now the approximation, we use the form:
    //
    // digamma(x) = (x - root) * (Y + R(x-1))
    //
    // Where root is the location of the positive root of digamma,
    // Y is a constant, and R is optimised for low absolute error
    // compared to Y.
    //
    // Maximum Deviation Found:               1.466e-18
    // At double precision, max error found:  2.452e-17
    //
    const Y = 0.99558162689208984;

    const root1 = 1569415565 / 1073741824;
    const root2 = (381566830 / 1073741824) / 1073741824;
    const root3 = 0.90163120932586959186e-19;

    const P: number[] = [
      0.25479851061131551,
      -0.32555031186804491,
      -0.65031853770896507,
      -0.28919126444774784,
      -0.045251321448739056,
      -0.0020713321167745952
    ];
    const Q: number[] = [
      1.0,
      2.0767117023730469,
      1.4606242909763515,
      0.43593529692665969,
      0.054151797245674225,
      0.0021284987017821144,
      -0.55789841321675513e-6
    ];
    let g = x - root1;
    g -= root2;
    g -= root3;
    const r = Rational.evaluate_polynomial(P, x-1) /
      Rational.evaluate_polynomial(Q, x-1);
    const result = g * Y + g * r;

    return result;
  }

  public static digamma(x: number): number {
    //
    // This handles reflection of negative arguments, and all our
    // error handling, then forwards to the T-specific approximation.
    //

    let result = 0;
    //
    // Check for negative arguments and use reflection:
    //
    if(x <= -1) {
      // Reflect:
      x = 1 - x;
      // Argument reduction for tan:
      let remainder = x - Math.floor(x);
      // Shift to negative if > 0.5:
      if(remainder > 0.5) {
        remainder -= 1;
      }
      //
      // check for evaluation at a negative pole:
      //
      if(remainder === 0) {
        throw new Error(`Pole error`);
      }
      result = Math.PI / Math.tan(Math.PI * remainder);
    }

    if(x === 0) {
      throw new Error(`Pole error`);
    }

    //
    // If we're above the lower-limit for the
    // asymptotic expansion then use it:
    //
    if(x >= Digamma.digamma_large_lim()) {
      result += Digamma.digamma_imp_large(x);
    } else {
      //
      // If x > 2 reduce to the interval [1,2]:
      //
      while(x > 2) {
        x -= 1;
        result += 1/x;
      }
      //
      // If x < 1 use recurrance to shift to > 1:
      //
      while(x < 1) {
        result -= 1/x;
        x += 1;
      }
      result += Digamma.digamma_imp_1_2(x, );
    }
    return result;
  }

}
