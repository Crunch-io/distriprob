"use strict";

/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

import {Sign} from "../special_functions/sign";
import {Tol} from "./toms748_solve";

type RootFindingState = {
  f: (x: number) => {f0: number, f1: number, f2?: number},
  last_f0: number,
  f0: number,
  delta: number,
  result: number,
  guess: number,
  min: number,
  max: number
}

export class Roots {

  private static handle_zero_derivative(state: RootFindingState): void {
    if(state.last_f0 === 0) {
      // this must be the first iteration, pretend that we had a
      // previous one at either min or max:
      if(state.result === state.min) {
        state.guess = state.max;
      } else {
        state.guess = state.min;
      }
      state.last_f0 = state.f(state.guess).f0;
      state.delta = state.guess - state.result;
    }
    if(Sign.sign(state.last_f0) * Sign.sign(state.f0) < 0) {
      // we've crossed over so move in opposite direction to last step:
      if(state.delta < 0) {
        state.delta = (state.result - state.min) / 2;
      } else {
        state.delta = (state.result - state.max) / 2;
      }
    } else {
      // move in same direction as last step:
      if(state.delta < 0) {
        state.delta = (state.result - state.max) / 2;
      } else {
        state.delta = (state.result - state.min) / 2;
      }
    }
  }

  public static bisect(f: (x: number) => number,
                       min: number,
                       max: number,
                       tol: Tol,
                       max_iter: number):
  {a: number, b: number, iterations: number} {
    let fmin = f(min);
    let fmax = f(max);

    if(fmin === 0) {
      return {a: min, b: min, iterations: 2};
    }

    if(fmax === 0) {
      return {a: max, b: max, iterations: 2};
    }

    //
    // Error checking:
    //
    if(min >= max) {
      throw new Error(`Evaluation error: Arguments in wrong order in BoostRoots.bisect${""
      } (first arg=${min})`);
    }
    if(fmin * fmax >= 0) {
      throw new Error(`Evaluation error: No change of sign in BoostRoots.bisect,${""
      } either there is no root to find, or there are multiple roots in the interval${""
      } (f(min) = ${fmin}`);
    }

    //
    // Three function invocations so far:
    //
    let count = max_iter;
    if(count < 3) {
      count = 0;
    } else {
      count -= 3;
    }


    while(count && (!tol(min, max))) {
      let mid = (min + max) / 2;
      let fmid = f(mid);

      if((mid === max) || (mid === min)) {
        break;
      }

      if(fmid === 0) {
        min = max = mid;
        break;
      } else if(Sign.sign(fmid) * Sign.sign(fmin) < 0) {
        max = mid;
        fmax = fmid;
      } else {
        min = mid;
        fmin = fmid;
      }
      --count;
    }

    max_iter -= count;

    return {a: min, b: max, iterations: max_iter};
  }

  public static newton_raphson_iterate(f: (x: number) => {f0: number, f1: number},
                                       guess: number,
                                       min: number,
                                       max: number,
                                       digits: number,
                                       max_iter: number):
  {result: number, iterations: number} {
    const state : RootFindingState = {
      f: f,
      last_f0: 0,
      f0: 0,
      delta: Number.MAX_VALUE,
      result: guess,
      guess: guess,
      min: min,
      max: max,
    };

    let f1;
    let factor = Math.pow(2, 1-digits);
    let delta1 = Number.MAX_VALUE;
    let delta2 = Number.MAX_VALUE;
    let count = max_iter;
    let fResult;

    do {
      state.last_f0 = state.f0;
      delta2 = delta1;
      delta1 = state.delta;
      fResult = f(state.result);
      state.f0 = fResult.f0;
      f1 = fResult.f1;
      count--;
      if(0 === state.f0) {
        break;
      }
      if(f1 === 0) {
        Roots.handle_zero_derivative(state);
      } else {
        state.delta = state.f0 / f1;
      }

      if(Math.abs(state.delta * 2) > Math.abs(delta2))
      {
        // last two steps haven't converged, try bisection:
        state.delta = (state.delta > 0) ? (state.result - min)/2 : (state.result - max)/2;
      }
      state.guess = state.result;
      state.result -= state.delta;
      if(state.result <= min) {
        state.delta = 0.5 * (state.guess - state.min);
        state.result = state.guess - state.delta;
        if((state.result == min) || (state.result == max)){
          break;
        }
      } else if(state.result >= state.max) {
        state.delta = 0.5 * (state.guess - state.max);
        state.result = state.guess - state.delta;
        if((state.result == min) || (state.result == max)) {
          break;
        }
      }
      // update brackets:
      if(state.delta > 0) {
        state.max = state.guess;
      } else {
        state.min = state.guess;
      }
    }while(count && (Math.abs(state.result * factor) < Math.abs(state.delta)));

    max_iter -= count;

    return {result: state.result, iterations: max_iter};
  }

  private static halley_step(x: number, f0: number, f1: number, f2: number): number {
    let denom = 2 * f0;
    let num = 2 * f1 - f0 * (f2 / f1);
    let delta;

    if((Math.abs(num) < 1) && (Math.abs(denom) >= Math.abs(num) * Number.MAX_VALUE)) {
      // possible overflow, use Newton step:
      delta = f0 / f1;
    } else {
      delta = denom / num;
    }

    return delta;
  }

  private static second_order_root_finder(f: (x: number) => {
                                                              f0: number,
                                                              f1: number,
                                                              f2: number
                                                            },
                                          guess: number,
                                          min: number,
                                          max: number,
                                          digits: number,
                                          max_iter: number,
                                          step: (x:number,
                                                 f0: number,
                                                 f1: number,
                                                 f2: number) => number):
  {result: number, iterations: number} {
    const state: RootFindingState = {
      f: f,
      last_f0: 0,
      f0: 0,
      delta: Math.max(10000000 * guess, 10000000),     // arbitarily large delta
      result: guess,
      guess: guess,
      min: min,
      max: max
    };


    let f1, f2;
    let factor = Math.pow(2, 1-digits);
    let delta1 = state.delta;
    let delta2 = state.delta;
    let out_of_bounds_sentry: boolean = false;
    let count = max_iter;
    let fResult;

    do{
      state.last_f0 = state.f0;
      delta2 = delta1;
      delta1 = state.delta;
      fResult = f(state.result);
      state.f0 = fResult.f0;
      f1 = fResult.f1;
      f2 = fResult.f2;
      count--;

      if(0 === state.f0) {
        break;
      }

      if(f1 === 0) {
        // Oops zero derivative!!!
        Roots.handle_zero_derivative(state);
      } else {
        if(f2 !== 0) {
          state.delta = step(state.result, state.f0, f1, f2);
          if(state.delta * f1 / state.f0 < 0) {
            // Oh dear, we have a problem as Newton and Halley steps
            // disagree about which way we should move.  Probably
            // there is cancelation error in the calculation of the
            // Halley step, or else the derivatives are so small
            // that their values are basically trash.  We will move
            // in the direction indicated by a Newton step, but
            // by no more than twice the current guess value, otherwise
            // we can jump way out of bounds if we're not careful.
            // See https://svn.boost.org/trac/boost/ticket/8314.
            state.delta = state.f0 / f1;
            if(Math.abs(state.delta) > 2 * Math.abs(state.guess))
              state.delta = (state.delta < 0 ? -1 : 1) * 2 * Math.abs(state.guess);
          }
        } else {
          state.delta = state.f0 / f1;
        }
      }

      let convergence = Math.abs(state.delta / delta2);

      if((convergence > 0.8) && (convergence < 2)) {
        // last two steps haven't converged, try bisection:
        state.delta = (state.delta > 0) ?
          (state.result - state.min) / 2 : (state.result - state.max) / 2;
        if(Math.abs(state.delta) > state.result) {
          // protect against huge jumps!
          state.delta = Sign.sign(state.delta) * state.result;
        }
        // reset delta2 so that this branch will *not* be taken on the
        // next iteration:
        delta2 = state.delta * 3;
      }
      state.guess = state.result;
      state.result -= state.delta;

      // check for out of bounds step:
      if(state.result < state.min) {
        let diff = ((Math.abs(state.min) < 1) &&
          (Math.abs(state.result) > 1) &&
          (Number.MAX_VALUE / Math.abs(state.result) < Math.abs(state.min))) ?
            1000 : state.result / state.min;
        if(Math.abs(diff) < 1) {
          diff = 1 / diff;
        }

        if(!out_of_bounds_sentry && (diff > 0) && (diff < 3)) {
          // Only a small out of bounds step, lets assume that the result
          // is probably approximately at min:
          state.delta = 0.99 * (state.guess - state.min);
          state.result = state.guess - state.delta;
          out_of_bounds_sentry = true; // only take this branch once!
        } else {
          state.delta = (state.guess - state.min) / 2;
          state.result = state.guess - state.delta;
          if((state.result === state.min) || (state.result === state.max)) {
            break;
          }
        }
      } else if(state.result > state.max) {
        let diff = ((Math.abs(state.max) < 1) &&
          (Math.abs(state.result) > 1) &&
          (Number.MAX_VALUE / Math.abs(state.result) < Math.abs(state.max))) ?
            1000 : state.result / state.max;

        if(Math.abs(diff) < 1) {
          diff = 1 / diff;
        }

        if(!out_of_bounds_sentry && (diff > 0) && (diff < 3)) {
          // Only a small out of bounds step, lets assume that the result
          // is probably approximately at min:
          state.delta = 0.99 * (state.guess - state.max);
          state.result = state.guess - state.delta;
          out_of_bounds_sentry = true; // only take this branch once!
        } else {
          state.delta = (state.guess - state.max) / 2;
          state.result = guess - state.delta;
          if((state.result === state.min) || (state.result === state.max)) {
            break;
          }
        }
      }
      // update brackets:
      if(state.delta > 0) {
        state.max = state.guess;
      } else {
        state.min = state.guess;
      }

    } while(count && (Math.abs(state.result * factor) < Math.abs(state.delta)));

    max_iter -= count;


    return {result: state.result, iterations: max_iter};
  }

  public static halley_iterate(f: (x: number) => {
                                                  f0: number,
                                                  f1: number,
                                                  f2: number
                                                 },
                               guess: number,
                               min: number,
                               max: number,
                               digits: number,
                               max_iter: number):
  {result: number, iterations: number} {
    return Roots.second_order_root_finder(
      f,
      guess,
      min,
      max,
      digits,
      max_iter,
      Roots.halley_step);
  }
}

