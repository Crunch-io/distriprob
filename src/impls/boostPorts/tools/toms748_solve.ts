"use strict";

/**
 * (C) Copyright John Maddock 2006.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const Precision = require("./precision").Precision;
const Sign = require("../special_functions/sign").Sign;

type FunctionPointSet = {
  a: number,
  b: number,
  d: number,
  fa: number,
  fb: number,
  fd: number,
}

export type Tol = (a: number, b: number) => boolean;

export class Toms748 {

  public static eps_tolerance(bits?: number): (a: number, b: number) => boolean {
    let eps = 4 * Precision.epsilon();

    if (typeof bits === "number") {
      eps = Math.max(Math.pow(2, 1 - bits), eps);
    }

    return (a: number, b: number) => {
      return Math.abs(a - b) <= (eps * Math.min(Math.abs(a), Math.abs(b)));
    }
  }


  public static equal_floor(a: number, b: number): boolean {
    return Math.floor(a) === Math.floor(b);
  }

  public static equal_ceil(a: number, b: number): boolean {
    return Math.ceil(a) === Math.ceil(b);
  }

  public static equal_nearest_integer(a: number, b: number): boolean {
    return Math.floor(a + 0.5) === Math.floor(b + 0.5);
  }


  private static bracket(f: (x: number) => number, c: number, fps: FunctionPointSet):
  void {
    //
    // Given a point c inside the existing enclosing interval
    // [a, b] sets a = c if f(c) == 0, otherwise finds the new
    // enclosing interval: either [a, c] or [c, b] and sets
    // d and fd to the point that has just been removed from
    // the interval.  In other words d is the third best guess
    // to the root.
    //
    const tol = Precision.epsilon() * 2;
    //
    // If the interval [a,b] is very small, or if c is too close
    // to one end of the interval then we need to adjust the
    // location of c accordingly:
    //
    if((fps.b - fps.a) < 2 * tol * fps.a) {
      c = fps.a + (fps.b - fps.a) / 2;
    } else if(c <= fps.a + Math.abs(fps.a) * tol) {
      c = fps.a + Math.abs(fps.a) * tol;
    } else if(c >= fps.b - Math.abs(fps.b) * tol) {
      c = fps.b - Math.abs(fps.b) * tol;
    }
    //
    // OK, lets invoke f(c):
    //
    let fc = f(c);
    //
    // if we have a zero then we have an exact solution to the root:
    //
    if(fc === 0) {
      fps.a = c;
      fps.fa = 0;
      fps.d = 0;
      fps.fd = 0;
      return;
    }
    //
    // Non-zero fc, update the interval:
    //
    if(Sign.sign(fps.fa) * Sign.sign(fc) < 0) {
      fps.d = fps.b;
      fps.fd = fps.fb;
      fps.b = c;
      fps.fb = fc;
    } else {
      fps.d = fps.a;
      fps.fd = fps.fa;
      fps.a = c;
      fps.fa= fc;
    }

    return;
  }

  private static safe_div(num: number, denom: number, r: number): number {
    //
    // return num / denom without overflow,
    // return r if overflow would occur.
    //
    if(Math.abs(denom) < 1) {
      if(Math.abs(denom * Number.MAX_VALUE) <= Math.abs(num)) {
        return r;
      }
    }
    return num / denom;
  }

  private static secant_interpolate(a: number, b: number, fa: number, fb: number):
  number {
    //
    // Performs standard secant interpolation of [a,b] given
    // function evaluations f(a) and f(b).  Performs a bisection
    // if secant interpolation would leave us very close to either
    // a or b.  Rationale: we only call this function when at least
    // one other form of interpolation has already failed, so we know
    // that the function is unlikely to be smooth with a root very
    // close to a or b.
    //

    const tol = Precision.epsilon() * 5;
    const c = a - (fa / (fb - fa)) * (b - a);
    if((c <= a + Math.abs(a) * tol) || (c >= b - Math.abs(b) * tol)) {
      return (a + b) / 2;
    }
    return c;
  }


  private static quadratic_interpolate(a: number,
                                       b: number,
                                       d: number,
                                       fa: number,
                                       fb: number,
                                       fd: number,
                                       count: number):
  number {
    //
    // Performs quadratic interpolation to determine the next point,
    // takes count Newton steps to find the location of the
    // quadratic polynomial.
    //
    // Point d must lie outside of the interval [a,b], it is the third
    // best approximation to the root, after a and b.
    //
    // Note: this does not guarentee to find a root
    // inside [a, b], so we fall back to a secant step should
    // the result be out of range.
    //
    // Start by obtaining the coefficients of the quadratic polynomial:
    //
    const B = Toms748.safe_div(fb - fa, b - a, Number.MAX_VALUE);
    let A = Toms748.safe_div(fd - fb, d - b, Number.MAX_VALUE);
    A = Toms748.safe_div(A - B, d - a, 0);

    if(A === 0) {
      // failure to determine coefficients, try a secant step:
      return Toms748.secant_interpolate(a, b, fa, fb);
    }
    //
    // Determine the starting point of the Newton steps:
    //
    let c;
    if(Sign.sign(A) * Sign.sign(fa) > 0) {
      c = a;
    } else {
      c = b;
    }
    //
    // Take the Newton steps:
    //
    for(let i = 1; i <= count; i++) {
      c -= Toms748.safe_div(fa+(B+A*(c-b))*(c-a), B + A * (2 * c - a - b), 1+c-a);
    }
    if((c <= a) || (c >= b)) {
      // Oops, failure, try a secant step:
      c = Toms748.secant_interpolate(a, b, fa, fb);
    }
    return c;
  }

  private static cubic_interpolate(a: number,
                                   b: number,
                                   d: number,
                                   e: number,
                                   fa: number,
                                   fb: number,
                                   fd: number,
                                   fe: number):
  number {
    //
    // Uses inverse cubic interpolation of f(x) at points
    // [a,b,d,e] to obtain an approximate root of f(x).
    // Points d and e lie outside the interval [a,b]
    // and are the third and forth best approximations
    // to the root that we have found so far.
    //
    // Note: this does not guarentee to find a root
    // inside [a, b], so we fall back to quadratic
    // interpolation in case of an erroneous result.
    //

    const q11 = (d - e) * fd / (fe - fd);
    const q21 = (b - d) * fb / (fd - fb);
    const q31 = (a - b) * fa / (fb - fa);
    const d21 = (b - d) * fd / (fd - fb);
    const d31 = (a - b) * fb / (fb - fa);
    const q22 = (d21 - q11) * fb / (fe - fb);
    const q32 = (d31 - q21) * fa / (fd - fa);
    const d32 = (d31 - q21) * fd / (fd - fa);
    const q33 = (d32 - q22) * fa / (fe - fa);
    let c = q31 + q32 + q33 + a;

    if((c <= a) || (c >= b)) {
      // Out of bounds step, fall back to quadratic interpolation:
      c = Toms748.quadratic_interpolate(a, b, d, fa, fb, fd, 3);
    }

    return c;
  }

  public static toms748_solve(f: (x: number) => number,
                              ax: number,
                              bx: number,
                              fax: number,
                              fbx: number,
                              tol: Tol,
                              max_iter: number):
  {a: number, b: number, iterations: number} {
    //
    // Main entry point and logic for Toms Algorithm 748
    // root finder.
    //
    let iterations;
    let count = max_iter;
    const fps: FunctionPointSet = {
      a: ax,
      b: bx,
      fa: fax,
      fb: fbx,
      d: NaN,
      fd: NaN
    };
    let c, u, fu, a0, b0, e, fe;
    const mu = 0.5;

    // initialise a, b and fa, fb:
    if(fps.a >= fps.b) {
      throw new Error(`Domain error: Parameters a and b out of order: a=${fps.a
      }, b=${fps.b}`);
    }

    if(tol(fps.a, fps.b) || (fps.fa === 0) || (fps.fb === 0)) {
      if(fps.fa === 0) {
        fps.b = fps.a;
      } else if(fps.fb === 0) {
        fps.a = fps.b;
      }
      return {a: fps.a, b: fps.b, iterations: 0}
    }

    if(Sign.sign(fps.fa) * Sign.sign(fps.fb) > 0) {
      throw new Error(`Domain error: Parameters a and b do not bracket the root: a=${
        fps.a}, b=${fps.b}`);
    }

    // dummy value for fd, e and fe:
    fe = e = fps.fd = 1e5;

    if(fps.fa !== 0) {
      //
      // On the first step we take a secant step:
      //
      c = Toms748.secant_interpolate(fps.a, fps.b, fps.fa, fps.fb);
      Toms748.bracket(f, c, fps);
      count--;

      if(count && (fps.fa !== 0) && !tol(fps.a, fps.b)) {
        //
        // On the second step we take a quadratic interpolation:
        //
        c = Toms748.quadratic_interpolate(
          fps.a,
          fps.b,
          fps.d,
          fps.fa,
          fps.fb,
          fps.fd,
          2
        );
        e = fps.d;
        fe = fps.fd;
        Toms748.bracket(f, c, fps);
        count--;
      }
    }

    while(count && (fps.fa !== 0) && !tol(fps.a, fps.b)) {
      // save our brackets:
      a0 = fps.a;
      b0 = fps.b;
      //
      // Starting with the third step taken
      // we can use either quadratic or cubic interpolation.
      // Cubic interpolation requires that all four function values
      // fa, fb, fd, and fe are distinct, should that not be the case
      // then variable prof will get set to true, and we'll end up
      // taking a quadratic step instead.
      //
      let min_diff = Number.MIN_VALUE * 32;
      let prof: boolean = (Math.abs(fps.fa - fps.fb) < min_diff) ||
                          (Math.abs(fps.fa - fps.fd) < min_diff) ||
                          (Math.abs(fps.fa - fe) < min_diff) ||
                          (Math.abs(fps.fb - fps.fd) < min_diff) ||
                          (Math.abs(fps.fb - fe) < min_diff) ||
                          (Math.abs(fps.fd - fe) < min_diff);
      if(prof) {
        // can't take cubic step
        c = Toms748.quadratic_interpolate(
          fps.a,
          fps.b,
          fps.d,
          fps.fa,
          fps.fb,
          fps.fd,
          2
        );
      } else {
        c = Toms748.cubic_interpolate(
          fps.a,
          fps.b,
          fps.d,
          e,
          fps.fa,
          fps.fb,
          fps.fd,
          fe
        );
      }
      //
      // re-bracket, and check for termination:
      //
      e = fps.d;
      fe = fps.fd;
      Toms748.bracket(f, c, fps);
      if((0 === --count) || (fps.fa === 0) || tol(fps.a, fps.b)) {
        break;
      }
      //
      // Now another interpolated step:
      //
      prof = (Math.abs(fps.fa - fps.fb) < min_diff) ||
             (Math.abs(fps.fa - fps.fd) < min_diff) ||
             (Math.abs(fps.fa - fe) < min_diff) ||
             (Math.abs(fps.fb - fps.fd) < min_diff) ||
             (Math.abs(fps.fb - fe) < min_diff) ||
             (Math.abs(fps.fd - fe) < min_diff);
      if(prof) {
        // can't take cubic step
        c = Toms748.quadratic_interpolate(
          fps.a,
          fps.b,
          fps.d,
          fps.fa,
          fps.fb,
          fps.fd,
          3
        );
      } else {
        c = Toms748.cubic_interpolate(
          fps.a,
          fps.b,
          fps.d,
          e,
          fps.fa,
          fps.fb,
          fps.fd,
          fe
        );
      }
      //
      // Bracket again, and check termination condition, update e:
      //
      Toms748.bracket(f, c, fps);
      if((0 === --count) || (fps.fa === 0) || tol(fps.a, fps.b)) {
        break;
      }
      //
      // Now we take a double-length secant step:
      //
      if(Math.abs(fps.fa) < Math.abs(fps.fb)) {
        u = fps.a;
        fu = fps.fa;
      } else {
        u = fps.b;
        fu = fps.fb;
      }
      c = u - 2 * (fu / (fps.fb - fps.fa)) * (fps.b - fps.a);
      if(Math.abs(c - u) > (fps.b - fps.a) / 2) {
        c = fps.a + (fps.b - fps.a) / 2;
      }
      //
      // Bracket again, and check termination condition:
      //
      e = fps.d;
      fe = fps.fd;
      Toms748.bracket(f, c, fps);
      if((0 === --count) || (fps.fa === 0) || tol(fps.a, fps.b)) {
        break;
      }
      //
      // And finally... check to see if an additional bisection step is
      // to be taken, we do this if we're not converging fast enough:
      //
      if((fps.b - fps.a) < mu * (b0 - a0)){
        continue;
      }
      //
      // bracket again on a bisection:
      //
      e = fps.d;
      fe = fps.fd;
      Toms748.bracket(f, fps.a + (fps.b - fps.a) / 2, fps);
      count--;
    } // while loop

    iterations = max_iter - count;
    if(fps.fa === 0) {
      fps.b = fps.a;
    } else if(fps.fb === 0) {
      fps.a = fps.b;
    }

    return {a: fps.a, b: fps.b, iterations: iterations};
  }

  public static bracket_and_solve_root(f: (x: number) => number,
                                       guess: number,
                                       factor: number,
                                       rising: boolean,
                                       tol: Tol,
                                       max_iter: number):
  {a: number, b: number, iterations: number} {
    //
    // Set up inital brackets:
    //
    let a = guess;
    let b = a;
    let fa = f(a);
    let fb = fa;
    //
    // Set up invocation count:
    //
    let count = max_iter - 1;

    let step = 32;

    if((fa < 0) == (guess < 0 ? !rising : rising)) {
      //
      // Zero is to the right of b, so walk upwards
      // until we find it:
      //
      while(Sign.sign(fb) === Sign.sign(fa)){
        if(count === 0){
          throw new Error(`Evaluation error: Unable to bracket root, last nearest${""
          } value was ${b}`);
        }
        //
        // Heuristic: normally it's best not to increase the step sizes as we'll just end
        // up with a really wide range to search for the root.  However, if the initial
        // guess was *really* bad then we need to speed up the search otherwise we'll take
        // forever if we're orders of magnitude out.  This happens most often if the guess
        // is a small value (say 1) and the result we're looking for is close to
        // std::numeric_limits<T>::min().
        //
        if((max_iter - count) % step === 0) {
          factor *= 2;
          if(step > 1){
            step /= 2;
          }
        }
        //
        // Now go ahead and move our guess by "factor":
        //
        a = b;
        fa = fb;
        b *= factor;
        fb = f(b);
        count--;
      }
    } else {
      //
      // Zero is to the left of a, so walk downwards
      // until we find it:
      //
      while(Sign.sign(fb) === Sign.sign(fa)) {
        if(Math.abs(a) < Number.MIN_VALUE) {
          // Escape route just in case the answer is zero!
          max_iter -= count;
          max_iter += 1;
          return a > 0 ?
            {a: 0, b: a, iterations: max_iter}
            :
            {a: a, b: 0, iterations: max_iter};
        }
        if(count === 0) {
          throw new Error(`Evaluation error: Unable to bracket root, last nearest${""
          } value was ${a}`);
        }
        //
        // Heuristic: normally it's best not to increase the step sizes as we'll just end
        // up with a really wide range to search for the root.  However, if the initial
        // guess was *really* bad then we need to speed up the search otherwise we'll take
        // forever if we're orders of magnitude out.  This happens most often if the guess
        // is a small value (say 1) and the result we're looking for is close to
        // std::numeric_limits<T>::min().
        //
        if((max_iter - count) % step === 0) {
          factor *= 2;
          if(step > 1) step /= 2;
        }
        //
        // Now go ahead and move are guess by "factor":
        //
        b = a;
        fb = fa;
        a /= factor;
        fa = f(a);
        count--;
      }
    }
    max_iter -= count;
    max_iter += 1;
    const r = Toms748.toms748_solve(
      f,
      (a < 0 ? b : a),
      (a < 0 ? a : b),
      (a < 0 ? fb : fa),
      (a < 0 ? fa : fb),
      tol,
      count
    );
    r.iterations += max_iter;

    return r;
  }
}

