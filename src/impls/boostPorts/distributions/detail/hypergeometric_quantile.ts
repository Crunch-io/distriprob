"use strict";

/**
 * (C) Copyright John Maddock 2008.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const HypergeometricPDF = require("./hypergeometric_pdf").HypergeometricPDF;
const Gamma = require("../../special_functions/gamma").Gamma;
const Precision = require("../../tools/precision").Precision;

import {Cache} from "../../../cache";

export class HypergeometricQuantile {

  private static round_x_from_p(x: number,
                                p: number,
                                cum: number,
                                fudge_factor: number,
                                lbound: number,
                                ubound: number,
                                round: "up" | "down"):
  number {
    if (round === "up") {
      // if((cum < p * fudge_factor) && (x !== ubound)) {
      //   return x + 1;
      // }
      return x;
    } else if (round === "down") {
      // if((p < cum * fudge_factor) && (x !== lbound)) {
      //   return x - 1;
      // }
      // return x;
      if (x !== lbound) {
        return x-1;
      }
      return x;
    } else {
      throw new Error(`Domain error: unrecognized rounding option: ${round}`);
    }
  }

  private static round_x_from_q(x: number,
                                q: number,
                                cum: number,
                                fudge_factor: number,
                                lbound: number,
                                ubound: number,
                                round: "up" | "down"):
  number {
    if (round === "up") {
      // if((q < cum * fudge_factor) && (x !== ubound)) {
      //   console.log("bumped up");
      //   return x + 1;
      // }
      return x;
    } else if (round === "down") {
      // if((q * fudge_factor > cum) && (x !== lbound)) {
      //   return x - 1;
      // }
      // return x;
      if (x !== lbound) {
        return x-1;
      }
      return x;
    } else {
      throw new Error(`Domain error: unrecognized rounding option: ${round}`);
    }
  }

  public static imp(p: number,
                    q: number,
                    r: number,
                    n: number,
                    N: number,
                    round: "up" | "down",
                    cache: Cache):
  number {
    let result;
    const fudge_factor = 1 + Precision.epsilon() * ((N <= cache.primes.maxLimit) ? 50 : 2 * N);
    const base = Math.max(0, Math.trunc(n + r) - Math.trunc(N));
    const lim = Math.min(r, n);

    if(p <= 0.5) {
      let x = base;
      result = HypergeometricPDF.imp(x, r, n, N, cache);
      let diff = result;
      if (diff === 0) {
        x++;
        // We want to skip through x values as fast as we can until we start getting non-zero values,
        // otherwise we're just making lots of expensive PDF calls:

        let log_pdf = Gamma.lgamma(n + 1).result
          + Gamma.lgamma(r + 1).result
          + Gamma.lgamma(N - n + 1).result
          + Gamma.lgamma(N - r + 1).result
          - Gamma.lgamma(N + 1).result
          - Gamma.lgamma(x + 1).result
          - Gamma.lgamma(n - x + 1).result
          - Gamma.lgamma(r - x + 1).result
          - Gamma.lgamma(N - n - r + x + 1).result;

        while (log_pdf < Precision.log_min_value()) {
          log_pdf += -Math.log(x + 1) + Math.log(n - x) + Math.log(r - x) -
            Math.log(N - n - r + x + 1);
          x++;
        }

        // By the time we get here, log_pdf may be fairly inaccurate due to
        // roundoff errors, get a fresh PDF calculation before proceding:
        diff = HypergeometricPDF.imp(x, r, n, N, cache);
      }

      while(result < p) {
        diff = (diff > Number.MIN_VALUE * 8) ?
          (n - x) * (r - x) * diff / ((x + 1) * (N + x + 1 - n - r))
          :
          HypergeometricPDF.imp(x + 1, r, n, N, cache);
        if(result + diff / 2 > p) {
          break;
        }
        x++;
        result += diff;
      }

      return HypergeometricQuantile.round_x_from_p(
        x,
        p,
        result,
        fudge_factor,
        base,
        lim,
        round
      );

    } else {

      let x = lim;
      result = 0;
      let diff = HypergeometricPDF.imp(x, r, n, N, cache);
      if (diff === 0) {
        // We want to skip through x values as fast as we can until we start getting non-zero values,
        // otherwise we're just making lots of expensive PDF calls:
        x--;
        let log_pdf = Gamma.lgamma(n + 1).result
          + Gamma.lgamma(r + 1).result
          + Gamma.lgamma(N - n + 1).result
          + Gamma.lgamma(N - r + 1).result
          - Gamma.lgamma(N + 1).result
          - Gamma.lgamma(x + 1).result
          - Gamma.lgamma(n - x + 1).result
          - Gamma.lgamma(r - x + 1).result
          - Gamma.lgamma(N - n - r + x + 1).result;

        while (log_pdf < Precision.log_min_value()){
          log_pdf += Math.log(x) - Math.log(n - x + 1) - Math.log(r - x + 1) +
            Math.log(N - n - r + x);
          x--;
        }
        // By the time we get here, log_pdf may be fairly inaccurate due to
        // roundoff errors, get a fresh PDF calculation before proceding:
        diff = HypergeometricPDF.imp(x, r, n, N, cache);
      }

      while(result + diff / 2 < q) {
        result += diff;
        diff = (diff > Number.MIN_VALUE * 8) ?
          x * (N + x - n - r) * diff / ((1 + n - x) * (1 + r - x))
          :
          HypergeometricPDF.imp(x - 1, r, n, N, cache);
        x--;
      }

      return HypergeometricQuantile.round_x_from_q(
        x,
        q,
        result,
        fudge_factor,
        base,
        lim,
        round
      );
    }
  }
}