"use strict";

/**
 * (C) Copyright John Maddock 2008.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const NonCentralBeta = require("./non_central_beta").NonCentralBeta;
const Precision = require("../tools/precision").Precision;
const Gamma = require("../special_functions/gamma").Gamma;
const Constants = require("../tools/constants").Constants;
const Beta = require("../special_functions/beta").Beta;
const UncheckedFactorial = require("../special_functions/detail/unchecked_factorial").UncheckedFactorial;
const NormalDist = require("../../normalDist").NormalDist;
const Sign = require("../special_functions/sign").Sign;
const GenericQuantile = require("./detail/generic_quantile").GenericQuantile;
const Log1p = require("../special_functions/log1p").Log1p;


export class NonCentralT {
  private static non_central_t2_p(v: number,
                                  delta: number,
                                  x: number,
                                  y: number,
                                  init_val: number):
  number {
    //
    // Variables come first:
    //
    const max_iter = 500000;
    const errtol = Precision.epsilon();
    let d2 = delta * delta / 2;
    //
    // k is the starting point for iteration, and is the
    // maximum of the poisson weighting term, we don't
    // ever allow k == 0 as this can lead to catastrophic
    // cancellation errors later (test case is v = 1621286869049072.3
    // delta = 0.16212868690490723, x = 0.86987415482475994).
    //
    let k = Math.trunc(d2);
    let pois;
    if(k === 0) {
      k = 1;
    }
    // Starting PoissonDist weight:
    pois = Gamma.gamma_p_derivative(k+1, d2)
      * Gamma.tgamma_delta_ratio(k + 1, 0.5)
      * delta / Constants.SQRT2();

    if(pois === 0) {
      return init_val;
    }

    // Recurrance & starting beta terms:
    let betaObj = x < y ?
      Beta.ibeta_imp(k + 1, v / 2, x, false, true)
      :
      Beta.ibeta_imp(v / 2, k + 1, y, true, true);
    let xterm = betaObj.pderivative;
    let beta = betaObj.result;
    xterm *= y / (v / 2 + k);
    let poisf = pois, betaf = beta, xtermf = xterm;
    let sum = init_val;
    if((xterm === 0) && (beta === 0)) {
      return init_val;
    }

    //
    // Backwards recursion first, this is the stable
    // direction for recursion:
    //
    let count = 0;
    let last_term = 0;
    for(let i = k; i >= 0; i--) {
      let term = beta * pois;
      sum += term;
      // Don't terminate on first term in case we "fixed" k above:
      if((Math.abs(last_term) > Math.abs(term)) && Math.abs(term/sum) < errtol) {
        break;
      }
      last_term = term;
      pois *= (i + 0.5) / d2;
      beta += xterm;
      xterm *= (i) / (x * (v / 2 + i - 1));
      count++;
    }
    last_term = 0;
    for(let i = k + 1; ; i++) {
      poisf *= d2 / (i + 0.5);
      xtermf *= (x * (v / 2 + i - 1)) / (i);
      betaf -= xtermf;
      let term = poisf * betaf;
      sum += term;
      if((Math.abs(last_term) >= Math.abs(term)) && (Math.abs(term/sum) < errtol)) {
        break;
      }
      last_term = term;
      ++count;
      if(count > max_iter) {
        throw new Error(`Evaluation error: Series did not converge, closest value was ${
          sum}`);
      }
    }

    return sum;
  }

  private static non_central_t2_q(v: number,
                                  delta: number,
                                  x: number,
                                  y: number,
                                  init_val: number):
  number {
    //
    // Variables come first:
    //
    const max_iter = 500000;
    const errtol = Precision.epsilon();
    let d2 = delta * delta / 2;
    //
    // k is the starting point for iteration, and is the
    // maximum of the poisson weighting term, we don't allow
    // k == 0 as this can cause catastrophic cancellation errors
    // (test case is v = 561908036470413.25, delta = 0.056190803647041321,
    // x = 1.6155232703966216):
    //
    let k = Math.trunc(d2);
    if(k === 0){
      k = 1;
    }
    // Starting PoissonDist weight:
    let pois;
    if((k < UncheckedFactorial.max_factorial()) &&
       (d2 < Precision.log_max_value()) &&
       (Math.log(d2) * k < Precision.log_max_value())) {
      //
      // For small k we can optimise this calculation by using
      // a simpler reduced formula:
      //
      pois = Math.exp(-d2);
      pois *= Math.pow(d2, k);
      pois /= Gamma.tgamma(k + 1 + 0.5);
      pois *= delta / Constants.SQRT2();
    } else {
      pois = Gamma.gamma_p_derivative(k+1, d2)
        * Gamma.tgamma_delta_ratio(k + 1, 0.5)
        * delta / Constants.SQRT2();
    }

    if(pois === 0) {
      return init_val;
    }
    // Recurance term:
    let xterm;
    let beta;
    // Starting beta term:
    if(k !== 0) {
      const betaObj = x < y ?
        Beta.ibeta_imp(k + 1, v / 2, x, true, true)
        :
        Beta.ibeta_imp(v / 2, k + 1, y, false, true);
      beta = betaObj.result;
      xterm = betaObj.pderivative;
      xterm *= y / (v / 2 + k);
    } else {
      beta = Math.pow(y, v / 2);
      xterm = beta;
    }
    let poisf = pois, betaf = beta, xtermf = xterm;
    let sum = init_val;
    if((xterm === 0) && (beta === 0)) {
      return init_val;
    }

    //
    // Fused forward and backwards recursion:
    //
    let count = 0;
    let last_term = 0;
    for(let i = k + 1, j = k; ; i++, j--){
      poisf *= d2 / (i + 0.5);
      xtermf *= (x * (v / 2 + i - 1)) / (i);
      betaf += xtermf;
      let term = poisf * betaf;

      if(j >= 0) {
        term += beta * pois;
        pois *= (j + 0.5) / d2;
        beta -= xterm;
        xterm *= (j) / (x * (v / 2 + j - 1));
      }

      sum += term;
      // Don't terminate on first term in case we "fixed" the value of k above:
      if((Math.abs(last_term) > Math.abs(term)) && Math.abs(term/sum) < errtol) {
        break;
      }
      last_term = term;
      if(count > max_iter) {
        throw new Error(`Evaluation error: Series did not converge, closest value was ${
          sum}`);
      }
      count++;
    }

    return sum;
  }

  private static central_t_cdf(v: number, t: number, invert: boolean): number {
    const df = v;
    const lowerTail = !invert;

    if (!lowerTail) {
      return NonCentralT.central_t_cdf(df, -t, false);
    }

    if (t === 0) {
      return 0.5;
    }

    const normalLimit = 1 / Precision.epsilon();

    if (df > normalLimit) {
      return NormalDist.cdf(t, 0, 1, lowerTail);
    } else {
      const t2 = t * t;
      let probability;

      if(df > 2 * t2) {
        const z = t2 / (df + t2);
        probability = Beta.ibetac(0.5, df / 2, z) / 2;
      } else {
        const z = df / (df + t2);
        probability = Beta.ibeta(df / 2, 0.5, z) / 2;
      }
      return (t > 0 ? 1   - probability : probability);
    }
  }

  public static non_central_t_cdf(v: number, delta: number, t: number, invert: boolean):
  number {
    if (t === Number.POSITIVE_INFINITY) {
      return invert ? 0 : 1;
    } else if (t === Number.NEGATIVE_INFINITY) {
      return invert ? 1 : 0;
    }

    if (v === Number.POSITIVE_INFINITY) {
      // Infinite degrees of freedom, so use normal distribution located at delta.
      return NormalDist.cdf(t, delta, 1, !invert);
    }
    //
    // Otherwise, for t < 0 we have to use the reflection formula:
    if(t < 0) {
      t = -t;
      delta = -delta;
      invert = !invert;
    }

    if(Math.abs(delta / (4 * v)) < Precision.epsilon()) {
      // Approximate with a Student's T centred on delta,
      // the crossover point is based on eq 2.6 from
      // "A Comparison of Approximations To Percentiles of the
      // Noncentral t-Distribution".  H. Sahai and M. M. Ojeda,
      // Revista Investigacion Operacional Vol 21, No 2, 2000.
      // Original sources referenced in the above are:
      // "Some Approximations to the Percentage Points of the Noncentral
      // t-Distribution". C. van Eeden. International Statistical Review, 29, 4-31.
      // "Continuous Univariate Distributions".  N.L. Johnson, S. Kotz and
      // N. Balkrishnan. 1995. John Wiley and Sons New York.
      const result = NonCentralT.central_t_cdf(v, t - delta, false);
      return invert ? 1 - result : result;
    }
    //
    // x and y are the corresponding random
    // variables for the noncentral beta distribution,
    // with y = 1 - x:
    //
    const x = t * t / (v + t * t);
    const y = v / (v + t * t);
    const d2 = delta * delta;
    const a = 0.5;
    const b = v / 2;
    const c = a + b + d2 / 2;
    //
    // Crossover point for calculating p or q is the same
    // as for the noncentral beta:
    //
    const cross = 1 - (b / c) * (1 + d2 / (2 * c * c));
    let result;
    if(x < cross) {
      //
      // Calculate p:
      //
      if(x !== 0) {
        result = NonCentralBeta.non_central_beta_p(a, b, d2, x, y);
        result = NonCentralT.non_central_t2_p(v, delta, x, y, result);
        result /= 2;
      } else {
        result = 0;
      }
      result += NormalDist.cdf(-delta);
    } else {
      //
      // Calculate q:
      //
      invert = !invert;
      if(x !== 0) {
        result = NonCentralBeta.non_central_beta_q(a, b, d2, x, y);
        result = NonCentralT.non_central_t2_q(v, delta, x, y, result);
        result /= 2;
      }
      else { // x == 0
        result = NormalDist.cdf(-delta, 0, 1, false);
      }

    }
    if(invert) {
      result = 1 - result;
    }
    return result;
  }

  private static non_central_t_quantile_functor(v: number,
                                                delta: number,
                                                target: number,
                                                comp: boolean):
  (x: number) => number {

    return (x: number) => {
      let cdfEval = NonCentralT.non_central_t_cdf(v, delta, x, comp);

      return comp ? target - cdfEval : cdfEval - target;
    }
  }

  public static non_central_t_quantile(v: number, delta: number, p: number, q: number):
  number {
    let guess = 0;
    if ( (v === Number.POSITIVE_INFINITY) || (v > 1 / Precision.epsilon()) ) {
      // Infinite or very large degrees of freedom, so use normal distribution located at
      // delta.
      if (p < q) {
        return NormalDist.quantile(p, delta, 1, true);
      } else {
        return NormalDist.quantile(q, delta, 1, false);
      }
    } else if(v > 3) {
      // Use normal distribution to calculate guess.
      const mean = (v > 1 / Precision.epsilon()) ?
        delta
        :
        delta * Math.sqrt(v / 2) * Gamma.tgamma_delta_ratio((v - 1) * 0.5, 0.5);
      const vari = (v > 1 / Precision.epsilon()) ?
        1
        :
        (((delta * delta + 1) * v) / (v - 2) - mean * mean);
      if(p < q) {
        guess = NormalDist.quantile(p, mean, vari, true);
      } else {
        guess = NormalDist.quantile(q, mean, vari, false);
      }

    }
    //
    // We *must* get the sign of the initial guess correct,
    // or our root-finder will fail, so double check it now:
    //
    const pzero = NonCentralT.non_central_t_cdf(v, delta, 0, !(p < q));
    let s;
    if(p < q) {
      s = Sign.sign(p - pzero);
    } else {
      s = Sign.sign(pzero - q);
    }

    if(s !== Sign.sign(guess)){
      guess = s;
    }

    const f = NonCentralT.non_central_t_quantile_functor(
      v,
      delta,
      (p < q ? p : q),
      (p >= q));

    const result = GenericQuantile.generic_quantile(
      f,
      (p < q ? p : q),
      guess,
      (p >= q),
      Number.NEGATIVE_INFINITY,
      Number.POSITIVE_INFINITY
    );
    return result;
  }

  private static non_central_t2_pdf(n: number,
                                    delta: number,
                                    x: number,
                                    y: number,
                                    init_val: number):
  number {
    //
    // Variables come first:
    //
    const max_iter = 500;
    const errtol = Precision.epsilon();
    const d2 = delta * delta / 2;
    //
    // k is the starting point for iteration, and is the
    // maximum of the poisson weighting term:
    //
    let k = Math.trunc(d2);
    let pois, xterm;
    if(k === 0) {
      k = 1;
    }
    // Starting PoissonDist weight:
    pois = Gamma.gamma_p_derivative(k+1, d2)
      * Gamma.tgamma_delta_ratio(k + 1, 0.5)
      * delta / Constants.SQRT2();
    // Starting beta term:
    xterm = x < y ?
      Beta.ibeta_derivative(k + 1, n / 2, x)
      :
      Beta.ibeta_derivative(n / 2, k + 1, y);
    let poisf = pois, xtermf = xterm;
    let sum = init_val;
    if((pois === 0) || (xterm === 0)) {
      return init_val;
    }

    //
    // Backwards recursion first, this is the stable
    // direction for recursion:
    //
    let count = 0;
    for(let i = k; i >= 0; i--) {
      let term = xterm * pois;
      sum += term;
      if(((Math.abs(term/sum) < errtol) && (i !== k)) || (term === 0)) {
        break;
      }
      pois *= (i + 0.5) / d2;
      xterm *= (i) / (x * (n / 2 + i));
      count++;
      if(count > max_iter) {
        throw new Error(`Evaluation error: Series did not converge, closest value was ${
          sum}`);
      }
    }

    for(let i = k + 1; ; i++) {
      poisf *= d2 / (i + 0.5);
      xtermf *= (x * (n / 2 + i)) / (i);
      let term = poisf * xtermf;
      sum += term;
      if((Math.abs(term/sum) < errtol) || (term === 0)) {
        break;
      }
      count++;
      if(count > max_iter) {
        throw new Error(`Evaluation error: Series did not converge, closest value was ${
          sum}`);
      }
    }

    return sum;
  }

  public static central_t_pdf(n: number, t: number): number {
    const df = n;
    const x = t;
    const normalLimit = 1 / Precision.epsilon();
    let result;

    if (df > normalLimit) {
      result = NormalDist.pdf(x, 0, 1);
    } else {
      const basem1 = x * x / df;
      if(basem1 < 0.125) {
        result = Math.exp(-Log1p.log1p(basem1) * (1+df) / 2);
      } else {
        result = Math.pow(1 / (1 + basem1), (df + 1) / 2);
      }
      result /= Math.sqrt(df) * Beta.beta(df / 2, 0.5);
    }
    return result;
  }

  public static non_central_t_pdf(n: number, delta: number, t: number): number {
    if (t === Number.POSITIVE_INFINITY || t === Number.NEGATIVE_INFINITY) {
      return 0;
    }

    if (n === Number.POSITIVE_INFINITY) {
      // Infinite degrees of freedom, so use normal distribution located at delta.
      return NormalDist.pdf(t, delta, 1);
    }
    //
    // Otherwise, for t < 0 we have to use the reflection formula:
    if(t < 0) {
      t = -t;
      delta = -delta;
    }

    if(t === 0) {
      //
      // Handle this as a special case, using the formula
      // from Weisstein, Eric W.
      // "Noncentral Student's t-Distribution."
      // From MathWorld--A Wolfram Web Resource.
      // http://mathworld.wolfram.com/NoncentralStudentst-Distribution.html
      //
      // The formula is simplified thanks to the relation
      // 1F1(a,b,0) = 1.
      //
      return Gamma.tgamma_delta_ratio(n / 2 + 0.5, 0.5)
        * Math.sqrt(n / Math.PI)
        * Math.exp(-delta * delta / 2) / 2;
    }

    if(Math.abs(delta / (4 * n)) < Precision.epsilon()){
      // Approximate with a Student's T centred on delta,
      // the crossover point is based on eq 2.6 from
      // "A Comparison of Approximations To Percentiles of the
      // Noncentral t-Distribution".  H. Sahai and M. M. Ojeda,
      // Revista Investigacion Operacional Vol 21, No 2, 2000.
      // Original sources referenced in the above are:
      // "Some Approximations to the Percentage Points of the Noncentral
      // t-Distribution". C. van Eeden. International Statistical Review, 29, 4-31.
      // "Continuous Univariate Distributions".  N.L. Johnson, S. Kotz and
      // N. Balkrishnan. 1995. John Wiley and Sons New York.
      return NonCentralT.central_t_pdf(n, t - delta);
    }
    //
    // x and y are the corresponding random
    // variables for the noncentral beta distribution,
    // with y = 1 - x:
    //
    const x = t * t / (n + t * t);
    const y = n / (n + t * t);
    const a = 0.5;
    const b = n / 2;
    const d2 = delta * delta;
    //
    // Calculate pdf:
    //
    const dt = n * t / (n * n + 2 * n * t * t + t * t * t * t);
    let result = NonCentralBeta.non_central_beta_pdf(a, b, d2, x, y);
    const tol = Precision.epsilon() * result * 500;
    result = NonCentralT.non_central_t2_pdf(n, delta, x, y, result);
    if(result <= tol) {
      result = 0;
    }
    result *= dt;

    return result;
  }
}