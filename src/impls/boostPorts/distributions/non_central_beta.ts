"use strict";

/**
 * (C) Copyright John Maddock 2008.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const Precision = require("../tools/precision").Precision;
const Gamma = require("../special_functions/gamma").Gamma;
const Beta = require("../special_functions/beta").Beta;
const Toms748 = require("../tools/toms748_solve").Toms748;
const Sign = require("../special_functions/sign").Sign;
const Series = require("../tools/series").Series;

// type definition import
import {Tol} from "../tools/toms748_solve";


export class NonCentralBeta {
  public static non_central_beta_p(a: number,
                                    b: number,
                                    lam: number,
                                    x: number,
                                    y: number,
                                    init_val: number = 0) : number {
    //
    // Variables come first:
    //
    let max_iter = 500000;
    let errtol = Precision.epsilon();
    let l2 = lam / 2;
    //
    // k is the starting point for iteration, and is the
    // maximum of the poisson weighting term,
    // note that unlike other similar code, we do not set
    // k to zero, when l2 is small, as forward iteration
    // is unstable:
    //
    let k = Math.trunc(l2);
    if(k === 0){
      k = 1;
    }

    // Starting PoissonDist weight:
    let pois = Gamma.gamma_p_derivative(k+1, l2);

    if(pois === 0) {
      return init_val;
    }

    const betaObj = x < y ?
      Beta.ibeta_imp(a + k, b, x, false, true)
      :
      Beta.ibeta_imp(b, a + k, y, true, true);
    // recurrence term:
    let xterm = betaObj.pderivative;
    // Starting beta term:
    let beta = betaObj.result;

    xterm *= y / (a + b + k - 1);
    let poisf = pois;
    let betaf = beta;
    let xtermf = xterm;
    let sum = init_val;

    if((beta === 0) && (xterm === 0)) {
      return init_val;
    }

    //
    // Backwards recursion first, this is the stable
    // direction for recursion:
    //
    let last_term = 0;
    let count = k;
    for(let i = k; i >= 0; i--) {
      let term = beta * pois;
      sum += term;
      if(((Math.abs(term/sum) < errtol) && (last_term >= term)) || (term === 0)) {
        count = k - i;
        break;
      }
      pois *= i / l2;
      beta += xterm;
      xterm *= (a + i - 1) / (x * (a + b + i - 2));
      last_term = term;
    }
    for(let i = k + 1; ; i++) {
      poisf *= l2 / i;
      xtermf *= (x * (a + b + i - 2)) / (a + i - 1);
      betaf -= xtermf;

      let term = poisf * betaf;
      sum += term;
      if((Math.abs(term/sum) < errtol) || (term === 0)) {
        break;
      }
      if(count + i - k > max_iter) {
        console.log("count:", count + i - k);
        throw new Error(`Evaluation error: Series did not converge, closest value was ${
          sum}`);
      }
    }
    return sum;
  }

  public static non_central_beta_q(a: number,
                                    b: number,
                                    lam: number,
                                    x: number,
                                    y: number,
                                    init_val: number = 0): number {
    //
    // Variables come first:
    //
    let max_iter = 500000;
    let errtol = Precision.epsilon();
    let l2 = lam / 2;

    //
    // k is the starting point for iteration, and is the
    // maximum of the poisson weighting term:
    //
    let k = Math.trunc(l2);
    let pois;
    if(k <= 30) {
      //
      // Might as well start at 0 since we'll likely have this number of terms anyway:
      //
      if(a + b > 1) {
        k = 0;
      } else if(k === 0) {
        k = 1;
      }
    }
    if(k === 0) {
      // Starting PoissonDist weight:
      pois = Math.exp(-l2);
    } else {
      // Starting PoissonDist weight:
      pois = Gamma.gamma_p_derivative(k+1, l2);
    }
    if(pois === 0) {
      return init_val;
    }

    const betaObj = x < y ?
      Beta.ibeta_imp(a + k, b, x, true, true)
      :
      Beta.ibeta_imp(b, a + k, y, false, true);
    // recurance term:
    let xterm = betaObj.pderivative;
    // Starting beta term:
    let beta = betaObj.result;

    xterm *= y / (a + b + k - 1);
    let poisf = pois;
    let betaf = beta;
    let xtermf = xterm;
    let sum = init_val;
    if((beta === 0) && (xterm === 0)) {
      return init_val;
    }
    //
    // Forwards recursion first, this is the stable
    // direction for recursion, and the location
    // of the bulk of the sum:
    //
    let last_term = 0;
    let count = 0;
    for(let i = k + 1; ; i++){
      poisf *= l2 / i;
      xtermf *= (x * (a + b + i - 2)) / (a + i - 1);
      betaf += xtermf;

      let term = poisf * betaf;
      sum += term;
      if((Math.abs(term/sum) < errtol) && (last_term >= term)) {
        count = i - k;
        break;
      }
      if((i - k) > max_iter) {
        throw new Error(`Evaluation error: Series did not converge, closest${""
        } value was ${sum}`);
      }
      last_term = term;
    }
    for(let i = k; i >= 0; i--) {
      let term = beta * pois;
      sum += term;
      if(Math.abs(term/sum) < errtol) {
        count += k - i;
        break;
      }
      if((count + k - i) > max_iter) {
        throw new Error(`Evaluation error: Series did not converge, closest${""
          } value was ${sum}`);
      }
      pois *= i / l2;
      beta -= xterm;
      xterm *= (a + i - 1) / (x * (a + b + i - 2));
    }

    return sum;
  }

  public static non_central_beta_cdf(x: number,
                                     y: number,
                                     a: number,
                                     b: number,
                                     l: number,
                                     invert: boolean): number {

    if(x === 0){
      return invert ? 1.0 : 0.0;
    }
    if(y === 0){
      return invert ? 0.0 : 1.0;
    }

    let result: number;
    let c = a + b + l / 2;
    let cross = 1 - (b / c) * (1 + l / (2 * c * c));

    if(l === 0) {
      if (x === 0) {
        result = invert ? 1 : 0;
      }

      if (x === 1) {
        result = invert ? 0 : 1;
      }

      return invert ? Beta.ibetac(a, b, x) : Beta.ibeta(a, b, x);
    } else if(x > cross) {
      // Complement is the smaller of the two:
      result = NonCentralBeta.non_central_beta_q(a, b, l, x, y, invert ? 0 : -1);
      invert = !invert;
    } else {
      result = NonCentralBeta.non_central_beta_p(a, b, l, x, y, invert ? -1 : 0);
    }
    if(invert){
      result = -result;
    }

    return result;
  }

  private static nc_beta_quantile_functor(a: number,
                                          b: number,
                                          l: number,
                                          t: number,
                                          c: boolean):
  (x: number) => number {
    const target = t;
    const complement = c;

    return (x: number) => {
      let cdfEval = NonCentralBeta.non_central_beta_cdf(x, 1-x, a, b, l, complement);
      return complement ? target - cdfEval : cdfEval - target;
    }
  }

  public static bracket_and_solve_root01(f: (x: number) => number,
                                         guess: number,
                                         factor: number,
                                         rising: boolean,
                                         tol: Tol,
                                         max_iter: number):
  {a: number, b: number, iterations: number} {

    //
    // Set up inital brackets:
    //
    let a = guess;
    let b = a;
    let fa = f(a);
    let fb = fa;
    //
    // Set up invocation count:
    //
    let count = max_iter - 1;

    if((fa < 0) == (guess < 0 ? !rising : rising)) {
      //
      // Zero is to the right of b, so walk upwards
      // until we find it:
      //
      while(Sign.sign(fb) === Sign.sign(fa)) {
        if(count === 0) {
          throw new Error(`Evaluation error: Unable to bracket root, last nearest${""
          } value was ${b}`);
        }
        //
        // Heuristic: every 20 iterations we double the growth factor in case the
        // initial guess was *really* bad !
        //
        if((max_iter - count) % 20 === 0) {
          factor *= 2;
        }
        //
        // Now go ahead and move our guess by "factor",
        // we do this by reducing 1-guess by factor:
        //
        a = b;
        fa = fb;
        b = 1 - ((1 - b) / factor);
        fb = f(b);
        count--;
      }
    } else {
      //
      // Zero is to the left of a, so walk downwards
      // until we find it:
      //
      while(Sign.sign(fb) === Sign.sign(fa)) {
        if(Math.abs(a) < Number.MIN_VALUE) {
          // Escape route just in case the answer is zero!
          max_iter -= count;
          max_iter += 1;
          return a > 0 ?
            {a: 0, b: a, iterations: max_iter}
            :
            {a: a, b: 0, iterations: max_iter} ;
        }
        if(count === 0) {
          throw new Error(`Evaluation error: Unable to bracket root, last nearest${""
          } value was ${a}`);
        }
        //
        // Heuristic: every 20 iterations we double the growth factor in case the
        // initial guess was *really* bad !
        //
        if((max_iter - count) % 20 === 0) {
          factor *= 2;
        }
        //
        // Now go ahead and move are guess by "factor":
        //
        b = a;
        fb = fa;
        a /= factor;
        fa = f(a);
        count--;
      }
    }
    max_iter -= count;
    max_iter += 1;
    const r = Toms748.toms748_solve(
      f,
      (a < 0 ? b : a),
      (a < 0 ? a : b),
      (a < 0 ? fb : fa),
      (a < 0 ? fa : fb),
      tol,
      count
    );
    r.iterations += max_iter;

    return r;
  }

  public static nc_beta_quantile(a: number,
                                 b: number,
                                 l: number,
                                 p: number,
                                 comp: boolean):
  number {
    //
    // Special cases first:
    //
    if(p === 0) {
      return comp ? 1.0 : 0.0;
    }

    if(p === 1) {
      return !comp ? 1.0 : 0.0;
    }


    let c = a + b + l / 2;
    let mean = 1 - (b / c) * (1 + l / (2 * c * c));
    let guess = mean;
    const f = NonCentralBeta.nc_beta_quantile_functor(a, b, l, p, comp);
    const tol = Toms748.eps_tolerance(53);
    const max_iter = 500;

    let ir = NonCentralBeta.bracket_and_solve_root01(
      f,
      guess,
      2.5,
      true,
      tol,
      max_iter
    );
    const result = ir.a + (ir.b - ir.a) / 2;

    return result;
  }

  public static non_central_beta_pdf(a: number,
                                      b: number,
                                      lam: number,
                                      x: number,
                                      y: number): number {
    //
    // Special cases:
    //
    if((x === 0) || (y === 0)) {
      return 0;
    }

    //
    // Variables come first:
    //
    let max_iter = 50;
    let errtol = Precision.epsilon();
    let l2 = lam / 2;
    //
    // k is the starting point for iteration, and is the
    // maximum of the poisson weighting term:
    //
    let k = Math.trunc(l2);
    // Starting PoissonDist weight:
    let pois = Gamma.gamma_p_derivative(k+1, l2);
    // Starting beta term:
    let beta = x < y ?
      Beta.ibeta_derivative(a + k, b, x)
      :
      Beta.ibeta_derivative(b, a + k, y);
    let sum = 0;
    let poisf = pois;
    let betaf = beta;

    //
    // Stable backwards recursion first:
    //
    let count = k;
    for(let i = k; i >= 0; i--) {
      let term = beta * pois;
      sum += term;
      if((Math.abs(term/sum) < errtol) || (term === 0)) {
        count = k - i;
        break;
      }
      pois *= i / l2;
      beta *= (a + i - 1) / (x * (a + i + b - 1));
    }

    for(let i = k + 1; ; i++) {
      poisf *= l2 / i;
      betaf *= x * (a + b + i - 1) / (a + i - 1);

      let term = poisf * betaf;
      sum += term;
      if((Math.abs(term/sum) < errtol) || (term === 0)) {
        break;
      }
      if((count + i - k) > max_iter) {
        throw new Error(`Evaluation error: Series did not converge, closest value${""
        } was ${sum}`);
      }
    }
    return sum;
  }

  public static nc_beta_pdf(a: number, b: number, lam: number, x: number): number {
    if (lam === 0) {
      return Beta.ibeta_derivative(a, b, x);
    }
    return NonCentralBeta.non_central_beta_pdf(a, b, lam, x, 1-x);
  }

  private static *hypergeometric_2F2_sum(a1: number,
                                         a2: number,
                                         b1: number,
                                         b2: number,
                                         z: number):
  IterableIterator<number> {
    let term = 1;
    let k = 0;

    while (true) {
      let result = term;
      term *= a1 * a2 / (b1 * b2);
      a1 += 1;
      a2 += 1;
      b1 += 1;
      b2 += 1;
      k += 1;
      term /= k;
      term *= z;
      yield result;
    }
  }

  private static hypergeometric_2F2(a1: number,
                                    a2: number,
                                    b1: number,
                                    b2: number,
                                    z: number):
  number {
    const s = NonCentralBeta.hypergeometric_2F2_sum(a1, a2, b1, b2, z);
    const max_iter = 50;
    const result = Series.sum_series(s, Precision.epsilon(), max_iter, 0);
    return result.sum;
  }

}

const a = 1.992940368652343750000000000000000000000e2; //3;
const b = 9.964702148437500000000000000000000000000e2; //1;
const ncp = 1.962219390869140625000000000000000000000e2; //0;
const x = 4.865405857563018798828125000000000000000e-1; //0.24435906140769345;
const p = 0.01;
const y = 1-x;
const invert = true;

//console.log(NonCentralBeta.non_central_beta_pdf(a, b, ncp, x, y));
//console.log(NonCentralBeta.non_central_beta_cdf(x, y, a, b, ncp, invert));
//console.log(NonCentralBeta.nc_beta_quantile(a, b, ncp, p, invert));