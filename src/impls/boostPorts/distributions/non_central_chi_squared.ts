"use strict";

/**
 * (C) Copyright John Maddock 2008.
 * (C) Copyright Zachary Martin 2016 (port to javascript).
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const Precision = require("../tools/precision").Precision;
const Gamma = require("../special_functions/gamma").Gamma;
const IGammaInverse = require("../special_functions/detail/igamma_inverse").IGammaInverse;
const GenericQuantile = require("./detail/generic_quantile").GenericQuantile;
const Bessel = require("../special_functions/bessel").Bessel;


export class NonCentralChiSquared {
  private static non_central_chi_square_q(x: number,
                                          f: number,
                                          theta: number,
                                          init_sum: number = 0):
  number {
    //
    // Computes the complement of the Non-Central Chi-Square
    // Distribution CDF by summing a weighted sum of complements
    // of the central-distributions.  The weighting factor is
    // a PoissonDist Distribution.
    //
    // This is an application of the technique described in:
    //
    // Computing discrete mixtures of continuous
    // distributions: noncentral chisquare, noncentral t
    // and the distribution of the square of the sample
    // multiple correlation coeficient.
    // D. Benton, K. Krishnamoorthy.
    // Computational Statistics & Data Analysis 43 (2003) 249 - 267
    //

    // Special case:
    if(x === 0) {
      return 1;
    }

    //
    // Initialize the variables we'll be using:
    //
    const lambda = theta / 2;
    const del = f / 2;
    const y = x / 2;
    const max_iter = 5000;
    const errtol = Precision.epsilon();
    let sum = init_sum;
    //
    // k is the starting location for iteration, we'll
    // move both forwards and backwards from this point.
    // k is chosen as the peek of the PoissonDist weights, which
    // will occur *before* the largest term.
    //
    const k = Math.round(lambda);  //iround(lambda, pol);
    // Forwards and backwards PoissonDist weights:
    let poisf = Gamma.gamma_p_derivative(1 + k, lambda);
    let poisb = poisf * k / lambda;
    // Initial forwards central chi squared term:
    let gamf = Gamma.gamma_q(del + k, y);
    // Forwards and backwards recursion terms on the central chi squared:
    let xtermf = Gamma.gamma_p_derivative(del + 1 + k, y);
    let xtermb = xtermf * (del + k) / y;
    // Initial backwards central chi squared term:
    let gamb = gamf - xtermb;

    //
    // Forwards iteration first, this is the
    // stable direction for the gamma function
    // recurrences:
    //
    let i;
    for(i = k; (i-k) < max_iter; i++) {
      let term = poisf * gamf;
      sum += term;
      poisf *= lambda / (i + 1);
      gamf += xtermf;
      xtermf *= y / (del + i + 1);
      if(((sum == 0) || (Math.abs(term / sum) < errtol)) && (term >= poisf * gamf)) {
        break;
      }
    }

    //Error check:
    if((i-k) >= max_iter) {
      throw new Error(`Evaluation error: Series did not converge, closest value was ${sum
      }`);
    }
    //
    // Now backwards iteration: the gamma
    // function recurrences are unstable in this
    // direction, we rely on the terms deminishing in size
    // faster than we introduce cancellation errors.
    // For this reason it's very important that we start
    // *before* the largest term so that backwards iteration
    // is strictly converging.
    //
    for(i = k - 1; i >= 0; i--) {
      let term = poisb * gamb;
      sum += term;
      poisb *= i / lambda;
      xtermb *= (del + i) / y;
      gamb -= xtermb;
      if((sum == 0) || (Math.abs(term / sum) < errtol))
        break;
    }

    return sum;
  }

  private static non_central_chi_square_p_ding(x: number,
                                               f: number,
                                               theta: number,
                                               init_sum: number = 0):
  number {
    //
    // This is an implementation of:
    //
    // Algorithm AS 275:
    // Computing the Non-Central #2 Distribution Function
    // Cherng G. Ding
    // Applied Statistics, Vol. 41, No. 2. (1992), pp. 478-482.
    //
    // This uses a stable forward iteration to sum the
    // CDF, unfortunately this can not be used for large
    // values of the non-centrality parameter because:
    // * The first term may underfow to zero.
    // * We may need an extra-ordinary number of terms
    //   before we reach the first *significant* term.
    //

    // Special case:
    if(x === 0) {
      return 0;
    }

    let tk = Gamma.gamma_p_derivative(f/2 + 1, x/2);
    const lambda = theta / 2;
    let vk = Math.exp(-lambda);
    let uk = vk;
    let sum = init_sum + tk * vk;
    if(sum === 0) {
      return sum;
    }

    const max_iter = 5000;
    const errtol = Precision.epsilon();

    let i;
    let lterm = 0;
    let term = 0;
    for(i = 1; i < max_iter; i++) {
      tk = tk * x / (f + 2 * i);
      uk = uk * lambda / i;
      vk = vk + uk;
      lterm = term;
      term = vk * tk;
      sum += term;
      if((Math.abs(term / sum) < errtol) && (term <= lterm)) {
        break;
      }
    }
    //Error check:
    if(i >= max_iter) {
      throw new Error(`Evaluation error: Series did not converge, closest value was ${sum
      }`);
    }

    return sum;
  }

  private static non_central_chi_square_p(y: number,
                                          n: number,
                                          lambda: number,
                                          init_sum: number):
  number {
    //
    // This is taken more or less directly from:
    //
    // Computing discrete mixtures of continuous
    // distributions: noncentral chisquare, noncentral t
    // and the distribution of the square of the sample
    // multiple correlation coeficient.
    // D. Benton, K. Krishnamoorthy.
    // Computational Statistics & Data Analysis 43 (2003) 249 - 267
    //
    // We're summing a PoissonDist weighting term multiplied by
    // a central chi squared distribution.
    //

    // Special case:
    if(y === 0) {
      return 0;
    }

    const max_iter = 5000;
    const errtol = Precision.epsilon();
    let errorf = 0;
    let errorb = 0;

    let x = y / 2;
    let del = lambda / 2;
    //
    // Starting location for the iteration, we'll iterate
    // both forwards and backwards from this point.  The
    // location chosen is the maximum of the PoissonDist weight
    // function, which ocurrs *after* the largest term in the
    // sum.
    //
    let k = Math.round(del); //iround(del, pol);
    let a = n / 2 + k;
    // Central chi squared term for forward iteration:
    let gamkf = Gamma.gamma_p(a, x);

    if(lambda === 0) {
      return gamkf;
    }

    // Central chi squared term for backward iteration:
    let gamkb = gamkf;
    // Forwards PoissonDist weight:
    let poiskf = Gamma.gamma_p_derivative(k+1, del);
    // Backwards PoissonDist weight:
    let poiskb = poiskf;
    // Forwards gamma function recursion term:
    let xtermf = Gamma.gamma_p_derivative(a, x);
    // Backwards gamma function recursion term:
    let xtermb = xtermf * x / a;
    let sum = init_sum + poiskf * gamkf;
    if(sum === 0) {
      return sum;
    }

    let i = 1;
    //
    // Backwards recursion first, this is the stable
    // direction for gamma function recurrences:
    //
    while(i <= k) {
      xtermb *= (a - i + 1) / x;
      gamkb += xtermb;
      poiskb = poiskb * (k - i + 1) / del;
      errorf = errorb;
      errorb = gamkb * poiskb;
      sum += errorb;
      if((Math.abs(errorb / sum) < errtol) && (errorb <= errorf)) {
        break;
      }
      i++;
    }
    i = 1;
    //
    // Now forwards recursion, the gamma function
    // recurrence relation is unstable in this direction,
    // so we rely on the magnitude of successive terms
    // decreasing faster than we introduce cancellation error.
    // For this reason it's vital that k is chosen to be *after*
    // the largest term, so that successive forward iterations
    // are strictly (and rapidly) converging.
    //
    do {
      xtermf = xtermf * x / (a + i - 1);
      gamkf = gamkf - xtermf;
      poiskf = poiskf * del / (k + i);
      errorf = poiskf * gamkf;
      sum += errorf;
      i++;
    } while ((Math.abs(errorf / sum) > errtol) && (i < max_iter));

    //Error check:
    if(i >= max_iter) {
      throw new Error(`Evaluation error: Series did not converge, closest value was ${sum
      }`);
    }

    return sum;
  }

  private static non_central_chi_square_pdf(x: number, n: number, lambda: number):
  number {
    //
    // As above but for the PDF:
    //
    const max_iter = 500;
    const errtol = Precision.epsilon();
    let x2 = x / 2;
    let n2 = n / 2;
    let l2 = lambda / 2;
    let sum = 0;
    let k = Math.trunc(l2);
    let pois = Gamma.gamma_p_derivative(k + 1, l2) *
      Gamma.gamma_p_derivative(n2 + k, x2);
    if(pois === 0) {
      return 0;
    }
    let poisb = pois;
    for(let i = k; ; i++) {
      sum += pois;
      if(pois / sum < errtol) {
        break;
      }
      if(i - k >= max_iter) {
        throw new Error(`Evaluation error: Series did not converge, closest value was ${
          sum}`);
      }
      pois *= l2 * x2 / ((i + 1) * (n2 + i));
    }

    for(let i = k - 1; i >= 0; i--) {
      poisb *= (i + 1) * (n2 + i) / (l2 * x2);
      sum += poisb;
      if(poisb / sum < errtol) {
        break;
      }
    }

    return sum / 2;
  }

  public static non_central_chi_squared_cdf(x: number,
                                             k: number,
                                             l: number,
                                             invert: boolean):
  number {
    let result;
    if(l === 0) {
      if (invert) {
        return Gamma.gamma_q(k / 2, x / 2);
      } else {
        return Gamma.gamma_p(k / 2, x / 2);
      }
    } else if(x > k + l) {
      // Complement is the smaller of the two:
      result = NonCentralChiSquared.non_central_chi_square_q(
        x,
        k,
        l,
        invert ? 0 : -1
      );
      invert = !invert;
    } else if(l < 200) {
      // For small values of the non-centrality parameter
      // we can use Ding's method:
      result = NonCentralChiSquared.non_central_chi_square_p_ding(
        x,
        k,
        l,
        invert ? -1 : 0
      );
    } else {
      // For larger values of the non-centrality
      // parameter Ding's method will consume an
      // extra-ordinary number of terms, and worse
      // may return zero when the result is in fact
      // finite, use Krishnamoorthy's method instead:
      result = NonCentralChiSquared.non_central_chi_square_p(
        x,
        k,
        l,
        invert ? -1 : 0
      );
    }

    if(invert) {
      result = -result;
    }

    return result;
  }

  private static nccs_quantile_functor(k: number, l: number, t: number, c: boolean):
  (x: number) => number {
    let dof = k;
    let ncp = l;
    let target = t;
    let complement = c;

    return (x: number) => {
      let cdfEval = NonCentralChiSquared.non_central_chi_squared_cdf(x,
        dof,
        ncp,
        complement
      );

      return complement ? target - cdfEval : cdfEval - target;
    }
  }

  public static nccs_quantile(k: number, l: number, p: number, comp: boolean): number {
    //
    // Special cases get short-circuited first:
    //
    if(p === 0) {
      return comp ? Number.POSITIVE_INFINITY : 0
    }

    if(p === 1) {
      return comp ? 0 : Number.POSITIVE_INFINITY;
    }

    if (l === 0) {
      return 2 * (comp ?
                    IGammaInverse.gamma_q_inv(k / 2, p)
                    :
                    IGammaInverse.gamma_p_inv(k / 2, p)
                 );
    }

    //
    // This is Pearson's approximation to the quantile, see
    // Pearson, E. S. (1959) "Note on an approximation to the distribution of
    // noncentral chi squared", Biometrika 46: 364.
    // See also:
    // "A comparison of approximations to percentiles of the noncentral
    // chi2-distribution",
    // Hardeo Sahai and Mario Miguel Ojeda,
    // Revista de Matematica: Teoria y Aplicaciones 2003 10(1-2) : 57-76.
    // Note that the latter reference refers to an approximation of the CDF, when they
    // really mean the quantile.
    //
    let b = -(l * l) / (k + 3 * l);
    let c = (k + 3 * l) / (k + 2 * l);
    let ff = (k + 2 * l) / (c * c);
    let guess = b + c * NonCentralChiSquared.nccs_quantile(ff, 0, p, comp);
    //
    // Sometimes guess goes very small or negative, in that case we have
    // to do something else for the initial guess, this approximation
    // was provided in a private communication from Thomas Luu, PhD candidate,
    // University College London.  It's an asymptotic expansion for the
    // quantile which usually gets us within an order of magnitude of the
    // correct answer.
    // Fast and accurate parallel computation of quantile functions for random number
    // generation,
    // Thomas LuuDoctorial Thesis 2016
    // http://discovery.ucl.ac.uk/1482128/
    //
    if(guess < 0.005) {
      const pp = comp ? 1 - p : p;
      guess = Math.pow(Math.pow(2, (k / 2 - 1)) * Math.exp(l / 2) * pp * k *
        Gamma.tgamma(k / 2), (2 / k));
      if(guess === 0) {
        guess = Number.MIN_VALUE;
      }
    }
    const f = NonCentralChiSquared.nccs_quantile_functor(k, l, p, comp);
    let result = GenericQuantile.generic_quantile(
      f,
      p,
      guess,
      comp,
      0,
      Number.MAX_VALUE
    );

    return result;
  }

  public static nccs_pdf(k: number, l: number, x: number): number {
    let r;

    if(l === 0) {
      return Gamma.gamma_p_derivative(k / 2, x / 2) / 2;
    }

    // Special case:
    if(x === 0) {
      return 0;
    }

    if(l > 50) {
      r = NonCentralChiSquared.non_central_chi_square_pdf(x, k, l);
    } else {
      r = Math.log(x / l) * (k / 4 - 0.5) - (x + l) / 2;
      if(Math.abs(r) >= Precision.log_max_value() / 4) {
        r = NonCentralChiSquared.non_central_chi_square_pdf(x, k, l);
      } else {
        r = Math.exp(r);
        r = 0.5 * r * Bessel.cyl_bessel_i(k/2 - 1, Math.sqrt(l * x));
      }
    }
    return r;
  }
}
