"use strict";

/**
 * (C) Copyright Zachary Martin 2016.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

const spawn = require("threads").spawn;
import {IRandomState} from "./random";


export class Laborer {
  private static readonly DEPENDENCIES = [

    // boostPorts/distributions
    require("./boostPorts/distributions/detail/generic_quantile").GenericQuantile,
    require("./boostPorts/distributions/detail/hypergeometric_cdf").HypergeometricCDF,
    require("./boostPorts/distributions/detail/hypergeometric_pdf").HypergeometricPDF,
    require("./boostPorts/distributions/detail/hypergeometric_quantile").HypergeometricQuantile,
    require("./boostPorts/distributions/detail/inv_discrete_quantile").InvDiscreteQuantile,
    require("./boostPorts/distributions/non_central_beta").NonCentralBeta,
    require("./boostPorts/distributions/non_central_chi_squared").NonCentralChiSquared,
    require("./boostPorts/distributions/non_central_t").NonCentralT,

    // boostPorts/special_functions
    require("./boostPorts/special_functions/airy").Airy,
    require("./boostPorts/special_functions/bernoulli").Bernoulli,
    require("./boostPorts/special_functions/bessel").Bessel,
    require("./boostPorts/special_functions/bessel_prime").BoostBesselPrime,
    require("./boostPorts/special_functions/beta").Beta,
    require("./boostPorts/special_functions/cos_pi").CosPI,
    require("./boostPorts/special_functions/detail/bessel_derivatives_linear").BesselDerivativesLinear,
    require("./boostPorts/special_functions/detail/bessel_i0").BesselI0,
    require("./boostPorts/special_functions/detail/bessel_i1").BesselI1,
    require("./boostPorts/special_functions/detail/bessel_ik").BesselIK,
    require("./boostPorts/special_functions/detail/bessel_j0").BesselJ0,
    require("./boostPorts/special_functions/detail/bessel_j1").BesselJ1,
    require("./boostPorts/special_functions/detail/bessel_jn").BesselJN,
    require("./boostPorts/special_functions/detail/bessel_jy").BesselJY,
    require("./boostPorts/special_functions/detail/bessel_jy_asym").BesselJYAsym,
    require("./boostPorts/special_functions/detail/bessel_jy_derivatives_asym").BesselJYDerivativesAsym,
    require("./boostPorts/special_functions/detail/bessel_jy_derivatives_series").BesselJYDerivativesSeries,
    require("./boostPorts/special_functions/detail/bessel_jy_series").BesselJYSeries,
    require("./boostPorts/special_functions/detail/bessel_jy_zero").BesselJYZero,
    require("./boostPorts/special_functions/detail/bessel_k0").BesselK0,
    require("./boostPorts/special_functions/detail/bessel_k1").BesselK1,
    require("./boostPorts/special_functions/detail/bessel_kn").BesselKN,
    require("./boostPorts/special_functions/detail/bessel_y0").BesselY0,
    require("./boostPorts/special_functions/detail/bessel_y1").BesselY1,
    require("./boostPorts/special_functions/detail/bessel_yn").BesselYN,
    require("./boostPorts/special_functions/detail/erf_inv").ErfInv,
    require("./boostPorts/special_functions/detail/gamma_inva").GammaInvA,
    require("./boostPorts/special_functions/detail/ibeta_inv_ab").IBetaInvAB,
    require("./boostPorts/special_functions/detail/ibeta_inverse").IBetaInverse,
    require("./boostPorts/special_functions/detail/igamma_inverse").IGammaInverse,
    require("./boostPorts/special_functions/detail/igamma_large").IGammaLarge,
    require("./boostPorts/special_functions/detail/lgamma_small").LGammaSmall,
    require("./boostPorts/special_functions/detail/t_distribution_inv").InverseStudentsT,
    require("./boostPorts/special_functions/detail/unchecked_bernoulli").UncheckedBernoulli,
    require("./boostPorts/special_functions/detail/unchecked_factorial").UncheckedFactorial,
    require("./boostPorts/special_functions/digamma").Digamma,
    require("./boostPorts/special_functions/erf").Erf,
    require("./boostPorts/special_functions/expm1").Expm1,
    require("./boostPorts/special_functions/factorial").Factorial,
    require("./boostPorts/special_functions/gamma").Gamma,
    require("./boostPorts/special_functions/hypot").Hypot,
    require("./boostPorts/special_functions/lanczos").Lanczos,
    require("./boostPorts/special_functions/log1p").Log1p,
    require("./boostPorts/special_functions/owens_t").OwensT,
    require("./boostPorts/special_functions/polygamma").Polygamma,
    require("./boostPorts/special_functions/powm1").Powm1,
    require("./boostPorts/special_functions/sign").Sign,
    require("./boostPorts/special_functions/sin_pi").SinPI,
    require("./boostPorts/special_functions/sinc").Sinc,
    require("./boostPorts/special_functions/zeta").Zeta,

    // boostPorts/tools
    require("./boostPorts/tools/constants").Constants,
    require("./boostPorts/tools/fraction").Fraction,
    require("./boostPorts/tools/precision").Precision,
    require("./boostPorts/tools/rational").Rational,
    require("./boostPorts/tools/roots").Roots,
    require("./boostPorts/tools/series").Series,
    require("./boostPorts/tools/toms748_solve").Toms748,

    // ./
    require("./betaDist").BetaDist,
    require("./binomialDist").BinomialDist,
    require("./cache").Cache,
    require("./chiSquaredDist").ChiSquaredDist,
    require("./errorHandling").check,
    require("./exponentialDist").ExponentialDist,
    require("./fDist").FDist,
    require("./gammaDist").GammaDist,
    require("./hypergeometricDist").HypergeometricDist,
    require("./negativeBinomialDist").NegativeBinomialDist,
    require("./normalDist").NormalDist,
    require("./poissonDist").PoissonDist,
    require("./primeFactors").Primes,
    require("./random").Random,
    require("./skewNormalDist").SkewNormalDist,
    require("./studentsTDist").StudentsTDist,
    require("./uniformDist").UniformDist,



  ];
  private resolutionQueue: {resolve: Function, reject: Function}[];
  private thread;
  private dead: boolean;

  constructor() {
    this.resolutionQueue = [];
    this.thread = spawn(Laborer.createScriptFunction(Laborer.DEPENDENCIES));
    this.thread.on("message", (response)=>{
      this.resolve(response);
    });
    this.dead = false;
  }

  public sendMessageToThread(msg): Promise<number>{
    if (this.dead) {
      return Promise.reject(new Error(`Worker thread is dead, cannot assign work`));
    }

    this.thread.send(msg);

    return new Promise<number>((resolve, reject) => {
      this.resolutionQueue.push({resolve: resolve, reject: reject});
    });
  }

  private resolve(value) {
    const resolution = this.resolutionQueue.shift();

    console.log("value:", value);

    if (this.dead && this.resolutionQueue.length === 0) {
      this.thread.kill();
    }

    if (resolution) {
      if (value === "ready"){
        resolution.resolve();
      } else if (value && value.error) {
        resolution.reject(new Error(value.message));
      } else {
        resolution.resolve(value);
      }
    }
  }

  public terminate() {
    this.dead = true;
    if (this.resolutionQueue.length === 0) {
      this.thread.kill();
    }
  }

  private static createScriptFunction(dependencies: any) {
    let body = "";

    for(let dependency of dependencies){
      if (typeof dependency === "function"){
        body += `${dependency.toString()}\n`;
      } else if (typeof dependency === "object") {
        for (let prop in dependency) {
          body +=`const ${prop} = ${JSON.stringify(dependency[prop])};\n`;
        }
      }
    }

    body += `
      if (typeof cache === "undefined") {
        cache = new Cache();
      }
      if (typeof hypergeometricDist === "undefined") {
        hypergeometricDist = new HypergeometricDist(cache); 
      }
    `;

    body += `
      let result; 
      try{
        result = eval(input)
      } catch(e) {
        result = {
          error: true,
          message: e.message,
          stack: e.stack
        };
      }
      done(result);
    `;

    return new Function("input", "done", body);
  }

  get ready() {
    return this.sendMessageToThread(`"ready"`);
  }

  private getThreadPromise<T>(className: string,
                              functionName: string,
                              args: IArguments): Promise<T> {
    let msg = `${className}.${functionName}(`;

    for (let i = 0; i < args.length; i++) {
      let argStr;

      if (typeof args[i] === "number") {
        argStr = args[i] + "";
      } else if (typeof args[i] === "string") {
        argStr = `"${args[i]}"`;
      } else {
        argStr = JSON.stringify(args[i]);
      }

      if (i !== args.length - 1) {
        msg += `${argStr}, `;
      } else {
        msg += `${argStr})`
      }
    }

    console.log(`sending message: ${msg}`);

    return this.sendMessageToThread(msg);
  }

  get beta() {
    const that = this;
    const betaDistClassName = "BetaDist";
    return {
      pdf: function(x: number,
                    alpha: number,
                    beta: number,
                    ncp: number = 0): Promise<number>{
        return that.getThreadPromise(betaDistClassName, "pdf", arguments);
      },
      cdf: function(x: number,
                    alpha: number,
                    beta: number,
                    lowerTail: boolean = true,
                    ncp: number = 0): Promise<number> {
        return that.getThreadPromise(betaDistClassName, "cdf", arguments);
      },
      quantile: function(x: number,
                         alpha: number,
                         beta: number,
                         lowerTail: boolean = true,
                         ncp: number = 0): Promise<number> {
        return that.getThreadPromise(betaDistClassName, "quantile", arguments);
      },
      random: function(n: number,
                       alpha: number,
                       beta: number,
                       ncp: number = 0,
                       seed?: number | string | IRandomState): Promise<number[]> {
        return that.getThreadPromise(betaDistClassName, "random", arguments);
      }
    }
  }

  get binomial() {
    const that = this;
    const binomialDistClassName = "BinomialDist";
    return {
      pdf: function(k: number,
                    trials: number,
                    probSuccess: number): Promise<number> {
        return that.getThreadPromise<number>(binomialDistClassName, "pdf", arguments);
      },
      cdf: function(k: number,
                    trials: number,
                    probSuccess: number,
                    lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise<number>(binomialDistClassName, "cdf", arguments);
      },
      quantile: function(p: number,
                         trials: number,
                         probSuccess: number,
                         lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise<number>(binomialDistClassName,"quantile", arguments);
      },
      random: function(n: number,
                       trials: number,
                       probSuccess: number,
                       seed?: number | string): Promise<number[]> {
        return that.getThreadPromise<number>(binomialDistClassName, "random", arguments);
      }
    }
  }

  get chi2() {
    const that = this;
    const chi2DistClassName = "ChiSquaredDist";
    return {
      pdf: function(x: number,
                    degreesOfFreedom: number,
                    ncp: number = 0): Promise<number> {
        return that.getThreadPromise<number>(chi2DistClassName, "pdf", arguments);
      },
      cdf: function(x: number,
                    degreesOfFreedom: number,
                    lowerTail: boolean = true,
                    ncp: number = 0): Promise<number> {
        return that.getThreadPromise<number>(chi2DistClassName, "cdf", arguments);
      },
      quantile: function(p: number,
                         degreesOfFreedom: number,
                         lowerTail: boolean = true,
                         ncp: number = 0): Promise<number> {
        return that.getThreadPromise<number>(chi2DistClassName, "quantile", arguments);
      },
      random: function(n: number,
                       degreesOfFreedom: number,
                       ncp: number = 0,
                       seed?: number | string | IRandomState): Promise<number[]> {
        return that.getThreadPromise<number[]>(chi2DistClassName, "random", arguments);
      }
    }
  }

  get exponential() {
    const that = this;
    const expDistClassName = "ExponentialDist";
    return {
      pdf: function(x: number,
                    lambda: number): Promise<number> {
        return that.getThreadPromise(expDistClassName, "pdf", arguments);
      },
      cdf: function(x: number,
                    lambda: number,
                    lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise(expDistClassName, "cdf", arguments);
      },
      quantile: function(p: number,
                         lambda: number,
                         lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise(expDistClassName, "quantile", arguments);
      },
      random: function(n: number,
                       lambda: number,
                       seed?: number | string | IRandomState): Promise<number[]> {
        return that.getThreadPromise(expDistClassName, "random", arguments);
      }
    }
  }

  get F() {
    const that = this;
    const fDistClassName = "FDist";
    return {
      pdf: function(x: number,
                    dof1: number,
                    dof2: number,
                    ncp: number = 0): Promise<number> {
        return that.getThreadPromise(fDistClassName, "pdf", arguments);
      },
      cdf: function(x: number,
                    dof1: number,
                    dof2: number,
                    lowerTail: boolean = true,
                    ncp: number = 0): Promise<number> {
        return that.getThreadPromise(fDistClassName, "cdf", arguments);
      },
      quantile: function(p: number,
                         dof1: number,
                         dof2: number,
                         lowerTail: boolean = true,
                         ncp: number = 0): Promise<number> {
        return that.getThreadPromise(fDistClassName, "quantile", arguments);
      },
      random: function(n: number,
                       dof1: number,
                       dof2: number,
                       ncp: number = 0,
                       seed?: number | string | IRandomState): Promise<number[]> {
        return that.getThreadPromise(fDistClassName, "random", arguments);
      }
    }
  }

  get gamma() {
    const that = this;
    const gammaDistClassName = "GammaDist";
    return {
      pdf: function(x: number,
                    shape: number,
                    scale: number): Promise<number> {
        return that.getThreadPromise(gammaDistClassName, "pdf", arguments);
      },
      cdf: function(x: number,
                    shape: number,
                    scale: number,
                    lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise(gammaDistClassName, "cdf", arguments);
      },
      quantile: function(p: number,
                         shape: number,
                         scale: number,
                         lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise(gammaDistClassName, "quantile", arguments);
      },
      random: function(n: number,
                       shape: number,
                       scale: number,
                       seed?: number | string | IRandomState): Promise<number[]> {
        return that.getThreadPromise(gammaDistClassName, "random", arguments);
      }
    }
  }

  get hypergeometric() {
    const that = this;
    const hypergeoClass = "hypergeometricDist";
    return {
      pdf: function(sampleSuccesses: number,
            draws: number,
            successPop: number,
            totalPop: number): Promise<number> {
        return that.getThreadPromise<number>(hypergeoClass, "pdf", arguments);
      },
      cdf: function(sampleSuccesses: number,
            draws: number,
            successPop: number,
            totalPop: number,
            lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise<number>(hypergeoClass, "cdf", arguments);
      },
      quantile: function(p: number,
                 draws: number,
                 successPop: number,
                 totalPop: number,
                 lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise<number>(hypergeoClass, "quantile", arguments);
      },
      random: function(n: number,
               draws: number,
               successPop: number,
               totalPop: number,
               seed?: string | number | IRandomState): Promise<number[]> {
        return that.getThreadPromise<number[]>(hypergeoClass, "random", arguments);
      }
    }
  }

  get negativeBinomial() {
    const that = this;
    const negativeBinomialClass = "NegativeBinomialDist";
    return {
      pdf: function(numFailures: number,
                    numSuccesses: number,
                    probSuccess: number): Promise<number>{
        return that.getThreadPromise<number>(negativeBinomialClass, "pdf", arguments);
      },
      cdf: function (numFailures: number,
                     numSuccesses: number,
                     probSuccess: number,
                     lowerTail?: boolean): Promise<number>{
        return that.getThreadPromise<number>(negativeBinomialClass, "cdf", arguments);
      },
      quantile: function(p: number,
                         numSuccesses: number,
                         probSuccess: number,
                         lowerTail?: boolean): Promise<number> {
        return that.getThreadPromise<number>(
          negativeBinomialClass,
          "quantile",
          arguments
        );
      },
      random: function(n: number,
                       numSuccesses: number,
                       probSuccess: number,
                       seed?: number | string | IRandomState): Promise<number[]> {
        return that.getThreadPromise<number[]>(
          negativeBinomialClass,
          "random",
          arguments
        );
      }
    }
  }

  get normal() {
    const that = this;
    const normalDistClassName = "NormalDist";
    return {
      pdf: function(x: number,
                    mu?: number,
                    sigma?: number): Promise<number> {
        return that.getThreadPromise<number>(normalDistClassName, "pdf", arguments);
      },
      cdf: function(x: number,
                    mu?: number,
                    sigma?: number,
                    lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise<number>(normalDistClassName, "cdf", arguments);
      },
      quantile: function(p: number,
                         mu?: number,
                         sigma?: number,
                         lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise<number>(normalDistClassName, "quantile", arguments);
      },
      random: function(n: number,
                       mu?: number,
                       sigma?: number,
                       seed?: number | string | IRandomState): Promise<number[]> {
        return that.getThreadPromise<number[]>(normalDistClassName, "random", arguments);
      }
    }
  }

  get poisson() {
    const that = this;
    const poissonDistClassName = "PoissonDist";
    return {
      pdf: function(k: number,
                    lambda: number): Promise<number> {
        return that.getThreadPromise<number>(poissonDistClassName, "pdf", arguments);
      },
      cdf: function(k: number,
                    lambda: number,
                    lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise<number>(poissonDistClassName, "cdf", arguments);
      },
      quantile: function(p: number,
                         lambda: number,
                         lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise<number>(poissonDistClassName, "quantile", arguments);
      },
      random: function(n: number,
                       lambda: number,
                       seed?: number | string): Promise<number[]> {
        return that.getThreadPromise<number[]>(poissonDistClassName, "random", arguments);
      }
    }
  }

  get skewNormal() {
    const that = this;
    const skewNormalDistClass = "SkewNormalDist";
    return {
      pdf: function(x: number,
                    location?: number,
                    scale?: number,
                    shape?: number): Promise<number> {
        return that.getThreadPromise<number>(skewNormalDistClass, "pdf", arguments);
      },
      cdf: function(x: number,
                    location?: number,
                    scale?: number,
                    shape?: number,
                    lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise<number>(skewNormalDistClass, "cdf", arguments);
      },
      quantile: function(p: number,
                         location?: number,
                         scale?: number,
                         shape?: number,
                         lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise<number>(skewNormalDistClass, "quantile", arguments);
      },
      random: function(n: number,
                       location?: number,
                       scale?: number,
                       shape?: number,
                       seed?: number | string | IRandomState): Promise<number[]> {
        return that.getThreadPromise<number[]>(skewNormalDistClass, "random", arguments);
      }
    }
  }

  get t() {
    const that = this;
    const tDistClass = "StudentsTDist";
    return {
      pdf: function(x: number,
                    degreesOfFreedom: number,
                    ncp: number = 0): Promise<number> {
        return that.getThreadPromise<number>(tDistClass, "pdf", arguments);
      },
      cdf: function(x: number,
                    degreesOfFreedom: number,
                    lowerTail: boolean = true,
                    ncp: number = 0): Promise<number> {
        return that.getThreadPromise<number>(tDistClass, "cdf", arguments);
      },
      quantile: function(p: number,
                         degreesOfFreedom: number,
                         lowerTail: boolean = true,
                         ncp: number = 0): Promise<number> {
        return that.getThreadPromise<number>(tDistClass, "quantile", arguments);
      },
      random: function(n: number,
                       degreesOfFreedom: number,
                       ncp: number = 0,
                       seed?: number | string | IRandomState): Promise<number[]> {
        return that.getThreadPromise<number[]>(tDistClass, "random", arguments);
      }
    }
  }

  get uniform() {
    const that = this;
    const uniformDistClassName = "UniformDist";
    return {
      pdf: function(x: number,
                    lowerSupportBound: number,
                    upperSupportBound: number): Promise<number> {
        return that.getThreadPromise(uniformDistClassName, "pdf", arguments);
      },
      cdf: function(x: number,
                    lowerSupportBound: number,
                    upperSupportBound: number,
                    lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise(uniformDistClassName, "cdf", arguments);
      },
      quantile: function(x: number,
                         lowerSupportBound: number,
                         upperSupportBound: number,
                         lowerTail: boolean = true): Promise<number> {
        return that.getThreadPromise(uniformDistClassName, "quantile", arguments);
      },
      random: function(n: number,
                       lowerSupportBound: number,
                       upperSupportBound: number,
                       seed?: number | string): Promise<number[]> {
        return that.getThreadPromise(uniformDistClassName, "random", arguments);
      }
    }
  }
}


