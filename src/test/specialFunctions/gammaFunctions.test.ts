"use strict";

/**
 * (C) Copyright Zachary Martin 2016.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

import {should} from "chai";
import {gamma} from "../../index";
import {digitsOfAgreement} from "../digitCompare";
const testCasesDi = require("../../../test_cases/gammaFunctions/testCases_di");
const testCasesTri = require("../../../test_cases/gammaFunctions/testCases_tri");
const testCasesPoly = require("../../../test_cases/gammaFunctions/testCases_poly");
const testCasesFuncAndLog =
  require("../../../test_cases/gammaFunctions/testCases_function_and_log");
const testCasesDeltaRatio =
  require("../../../test_cases/gammaFunctions/testCases_delta_ratio");
const testCasesRatio = require("../../../test_cases/gammaFunctions/testCases_ratio");
const testCasesIncomplete =
  require("../../../test_cases/gammaFunctions/testCases_incomplete");

should();

const DIGIT_AGREE_TOLERANCE = 13;
const DIGIT_AGREE_TOLERANCE_POLY = 12;
const DIGIT_AGREE_TOLERANCE_INC = 11;
const DIGIT_AGREE_TOLERANCE_INC_INV = 9;

describe("gamma functions", function() {

  describe("function", function() {
    describe("accuracy tests", function() {
      describe("boost data set", function() {
        for (let testCase of testCasesFuncAndLog) {
          it("should match high accuracy estimates of function values", function () {
            let testValue = gamma.function(
              testCase["z"]
            );

            //console.log(`n: ${testCase["n"]}, z: ${testCase["z"]}, got: ${testValue}, expected: ${testCase["result"]}`);

            let doa = digitsOfAgreement(testCase["result"], testValue);
            doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
          });
        }
      });
    });
  });

  describe("log", function() {
    describe("accuracy tests", function() {
      describe("boost data set", function() {
        for (let testCase of testCasesFuncAndLog) {
          it("should match high accuracy estimates of function values", function () {
            let testValue = gamma.functionLog(
              testCase["z"]
            );

            //console.log(`n: ${testCase["n"]}, z: ${testCase["z"]}, got: ${testValue}, expected: ${testCase["result"]}`);

            let doa = digitsOfAgreement(testCase["logResult"], testValue);
            doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
          });
        }
      });
    });
  });


  describe("di", function() {
    describe("accuracy tests", function() {
      describe("boost data set", function() {
        for (let testCase of testCasesDi) {
          it("should match high accuracy estimates of function values", function () {
            let testValue = gamma.di(
              testCase["z"]
            );

            //console.log(`n: ${testCase["n"]}, z: ${testCase["z"]}, got: ${testValue}, expected: ${testCase["result"]}`);

            let doa = digitsOfAgreement(testCase["result"], testValue);
            if (testCase["result"] > 1 / Number.MAX_VALUE) {
              doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
            } else {
              doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE - 1);
            }
          });
        }
      });
    });
  });

  describe("tri", function() {
    describe("accuracy tests", function() {
      describe("boost data set", function() {
        for (let testCase of testCasesTri) {
          it("should match high accuracy estimates of function values", function () {
            let testValue = gamma.tri(
              testCase["z"]
            );

            //console.log(`n: ${testCase["n"]}, z: ${testCase["z"]}, got: ${testValue}, expected: ${testCase["result"]}`);

            let doa = digitsOfAgreement(testCase["result"], testValue);
            if (testCase["result"] > 1 / Number.MAX_VALUE) {
              doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
            } else {
              doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE - 1);
            }
          });
        }
      });
    });
  });

  describe("poly", function() {
    describe("accuracy tests", function() {
      describe("boost data set", function() {
        for (let testCase of testCasesPoly) {
          it("should match high accuracy estimates of function values", function () {
            let testValue = gamma.poly(
              testCase["n"],
              testCase["z"]
            );

            //console.log(`n: ${testCase["n"]}, z: ${testCase["z"]}, got: ${testValue}, expected: ${testCase["result"]}`);

            let doa = digitsOfAgreement(testCase["result"], testValue);
            if (testCase["result"] > 1 / Number.MAX_VALUE) {
              doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE_POLY);
            }
          });
        }
      });
    });
  });

  describe("delta ratio", function() {
    describe("accuracy tests", function() {
      describe("boost data set", function() {
        for (let testCase of testCasesDeltaRatio) {
          it("should match high accuracy estimates of function values - plus delta",
              function () {
              let testValue = gamma.functionDeltaRatio(
                testCase["a"],
                testCase["delta"]
              );

              //console.log(`n: ${testCase["n"]}, z: ${testCase["z"]}, got: ${testValue}, expected: ${testCase["result"]}`);

              let doa = digitsOfAgreement(testCase["plusResult"], testValue);
              doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE+1);
          });

          it("should match high accuracy estimates of function values - minus delta",
            function () {
              let testValue = gamma.functionDeltaRatio(
                testCase["a"],
                -testCase["delta"]
              );

              //console.log(`n: ${testCase["n"]}, z: ${testCase["z"]}, got: ${testValue}, expected: ${testCase["result"]}`);

              let doa = digitsOfAgreement(testCase["minusResult"], testValue);
              doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);

            });
        }
      });
    });
  });

  describe("ratio", function() {
    describe("accuracy tests", function() {
      describe("boost data set", function() {
        for (let testCase of testCasesRatio) {
          it("should match high accuracy estimates of function values", function () {
            let testValue = gamma.functionRatio(
              testCase["a"],
              testCase["b"]
            );

            //console.log(`n: ${testCase["n"]}, z: ${testCase["z"]}, got: ${testValue}, expected: ${testCase["result"]}`);

            let doa = digitsOfAgreement(testCase["result"], testValue);
            doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
          });
        }
      });
    });
  });

  describe("incomplete", function() {
    describe("accuracy tests", function() {
      describe("boost data set", function() {
        for (let testCase of testCasesIncomplete) {
          if (testCase["a"] <= 171) {
            it("should match high accuracy estimates of function values - upper", function () {
              let testValue = gamma.incomplete(
                testCase["a"],
                testCase["z"],
                false,
                false
              );

              //console.log(`a: ${testCase["a"]}, z: ${testCase["z"]}, got: ${testValue}, expected: ${testCase["upper"]}`);

              let doa = digitsOfAgreement(testCase["upper"], testValue);
              doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE_INC);
            });
          }

          it("should match high accuracy estimates of function values - upperReg", function () {
            let testValue = gamma.incomplete(
              testCase["a"],
              testCase["z"],
              false,
              true
            );

            //console.log(`a: ${testCase["a"]}, z: ${testCase["z"]}, got: ${testValue}, expected: ${testCase["upperReg"]}`);

            let doa = digitsOfAgreement(testCase["upperReg"], testValue);
            doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE_INC);
          });

          if (testCase["a"] <= 171) {
            it("should match high accuracy estimates of function values - lower", function () {
              let testValue = gamma.incomplete(
                testCase["a"],
                testCase["z"],
                true,
                false
              );

              //console.log(`a: ${testCase["a"]}, z: ${testCase["z"]}, got: ${testValue}, expected: ${testCase["lower"]}`);

              let doa = digitsOfAgreement(testCase["lower"], testValue);
              doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE_INC);
            });
          }

          it("should match high accuracy estimates of function values - lowerReg", function () {
            let testValue = gamma.incomplete(
              testCase["a"],
              testCase["z"],
              true,
              true
            );

            //console.log(`a: ${testCase["a"]}, z: ${testCase["z"]}, got: ${testValue}, expected: ${testCase["lowerReg"]}`);

            let doa = digitsOfAgreement(testCase["lowerReg"], testValue);
            doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE_INC);
          });

          it("should match high accuracy estimates of function values - lowerReg inverse", function () {
            if (testCase["lowerReg"] !== 0 && testCase["lowerReg"] !== 1){
              let testValue = gamma.incompleteInverse(
                testCase["a"],
                testCase["lowerReg"],
                true
              );

              //console.log(`a: ${testCase["a"]}, p: ${testCase["lowerReg"]}, got: ${testValue}, expected: ${testCase["z"]}`);

              let doa = digitsOfAgreement(testCase["z"], testValue);
              if (testCase["lowerReg"] > 0.9) {
                doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE_INC_INV +
                  Math.log10(1 - testCase["lowerReg"]));
              } else {
                doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE_INC_INV);
              }
            }
          });

          it("should match high accuracy estimates of function values - upperReg inverse", function () {
            if (testCase["upperReg"] !== 0 && testCase["upperReg"] !== 1) {
              let testValue = gamma.incompleteInverse(
                testCase["a"],
                testCase["upperReg"],
                false
              );

              //console.log(`a: ${testCase["a"]}, q: ${testCase["upperReg"]}, got: ${testValue}, expected: ${testCase["z"]}`);

              let doa = digitsOfAgreement(testCase["z"], testValue);
              if (testCase["upperReg"] > 0.9) {
                doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE_INC_INV +
                  Math.log10(1 - testCase["upperReg"]));
              } else {
                doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE_INC_INV);
              }
            }
          });

          it("should match high accuracy estimates of function values - lowerReg inverse parameter", function () {
            if (testCase["lowerReg"] !== 0 && testCase["lowerReg"] !== 1){
              let testValue = gamma.incompleteInverseParameter(
                testCase["z"],
                testCase["lowerReg"],
                true
              );

              //console.log(`a: ${testCase["a"]}, p: ${testCase["lowerReg"]}, got: ${testValue}, expected: ${testCase["z"]}`);

              let doa = digitsOfAgreement(testCase["a"], testValue);
              if (testCase["lowerReg"] > 0.9) {
                doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE +
                  Math.log10(1 - testCase["lowerReg"]));
              } else {
                doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
              }
            }
          });

          it("should match high accuracy estimates of function values - upperReg inverse parameter", function () {
            if (testCase["upperReg"] !== 0 && testCase["upperReg"] !== 1){
              let testValue = gamma.incompleteInverseParameter(
                testCase["z"],
                testCase["upperReg"],
                false
              );

              //console.log(`a: ${testCase["a"]}, p: ${testCase["lowerReg"]}, got: ${testValue}, expected: ${testCase["z"]}`);

              let doa = digitsOfAgreement(testCase["a"], testValue);
              if (testCase["upperReg"] > 0.9) {
                doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE +
                  Math.log10(1 - testCase["upperReg"]));
              } else {
                doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
              }
            }
          });

        }
      });
    });
  });

});