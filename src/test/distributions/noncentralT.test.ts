"use strict";

/**
 * (C) Copyright Zachary Martin 2016.
 * Use, modification and distribution are subject to the
 * Boost Software License:
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

import {should} from "chai";
import {t} from "../../index";
import {digitsOfAgreement} from "../digitCompare";
const testCases = require("../../../test_cases/studentsT/testCases").testCases;
const testCasesTough = require("../../../test_cases/studentsT/testCases").testCasesTough;
const testCasesAsym = require("../../../test_cases/studentsT/testCases_asym");
const testCasesSmallNCP = require("../../../test_cases/studentsT/testCases_small_delta");

should();

const DIGIT_AGREE_TOLERANCE = 12;
const DIGIT_AGREE_TOLERANCE_TOUGH = 6;

describe("Non-central Chi Squared distribution", function() {

  describe("accuracy tests", function() {
    for (let testCase of testCases) {
      it("should match high accuracy estimates for cdf in lower tail", function (){
        let testValue = t.cdf(
          testCase["x"],
          testCase["dof"],
          true,
          testCase["ncp"]
        );
        let doa = digitsOfAgreement(testCase["p"], testValue);

        doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
      });

      it("should match high accuracy estimates for cdf in upper tail", function (){
        let testValue = t.cdf(
          testCase["x"],
          testCase["dof"],
          false,
          testCase["ncp"]
        );
        let doa = digitsOfAgreement(testCase["q"], testValue);

        doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
      });

      if (testCase["p"]  < 0.99 && testCase["p"] !== 0) {
        it ("should match high accuracy estimates for quantile in lower tail", function(){
          let testValue = t.quantile(
            testCase["p"],
            testCase["dof"],
            true,
            testCase["ncp"],
          );

          let doa = digitsOfAgreement(testCase["x"], testValue);

          doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
        });
      }

      if (testCase["q"]  < 0.99 && testCase["q"] !== 0) {
        it ("should match high accuracy estimates for quantile in upper tail", function(){
          let testValue = t.quantile(
            testCase["q"],
            testCase["dof"],
            false,
            testCase["ncp"],
          );

          let doa = digitsOfAgreement(testCase["x"], testValue);

          doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
        });
      }
    }

    for (let testCase of testCasesTough) {
      it(
        "should match high accuracy estimates for cdf in lower tail -- tough case",
        function (){
          let testValue = t.cdf(
            testCase["x"],
            testCase["dof"],
            true,
            testCase["ncp"]
          );
          let doa = digitsOfAgreement(testCase["p"], testValue);

          doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE_TOUGH);
        }
      );

      it(
        "should match high accuracy estimates for cdf in upper tail -- tough case",
        function (){
          let testValue = t.cdf(
            testCase["x"],
            testCase["dof"],
            false,
            testCase["ncp"]
          );
          let doa = digitsOfAgreement(testCase["q"], testValue);

          doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE_TOUGH);
        }
      );

      if (testCase["p"]  < 0.99 && testCase["p"] !== 0) {
        it (
          "should match high accuracy estimates for quantile in lower tail -- tough case",
          function(){
            let testValue = t.quantile(
              testCase["p"],
              testCase["dof"],
              true,
              testCase["ncp"],
            );

            let doa = digitsOfAgreement(testCase["x"], testValue);

            doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE_TOUGH);
          }
        );
      }

      if (testCase["q"]  < 0.99 && testCase["q"] !== 0) {
        it (
          "should match high accuracy estimates for quantile in upper tail -- asym case",
          function(){
            let testValue = t.quantile(
              testCase["q"],
              testCase["dof"],
              false,
              testCase["ncp"],
            );

            let doa = digitsOfAgreement(testCase["x"], testValue);

            doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE_TOUGH);
          }
        );
      }
    }

    for (let testCase of testCasesAsym) {
      it(
        "should match high accuracy estimates for cdf in lower tail -- asym case",
        function (){
          let testValue = t.cdf(
            testCase["x"],
            testCase["dof"],
            true,
            testCase["ncp"]
          );
          let doa = digitsOfAgreement(testCase["p"], testValue);

          doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
        }
      );

      it(
        "should match high accuracy estimates for cdf in upper tail -- asym case",
        function (){
          let testValue = t.cdf(
            testCase["x"],
            testCase["dof"],
            false,
            testCase["ncp"]
          );
          let doa = digitsOfAgreement(testCase["q"], testValue);

          doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
        }
      );

      if (testCase["p"]  < 0.99 && testCase["p"] !== 0) {
        it (
          "should match high accuracy estimates for quantile in lower tail -- asym case",
          function(){
            let testValue = t.quantile(
              testCase["p"],
              testCase["dof"],
              true,
              testCase["ncp"],
            );

            let doa = digitsOfAgreement(testCase["x"], testValue);

            doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
          }
        );
      }

      if (testCase["q"]  < 0.99 && testCase["q"] !== 0) {
        it (
          "should match high accuracy estimates for quantile in upper tail -- asym case",
          function(){
            let testValue = t.quantile(
              testCase["q"],
              testCase["dof"],
              false,
              testCase["ncp"],
            );

            let doa = digitsOfAgreement(testCase["x"], testValue);

            doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
          }
        );
      }
    }

    for (let testCase of testCasesSmallNCP) {
      it(
        "should match high accuracy estimates for cdf in lower tail -- small ncp",
        function (){
          let testValue = t.cdf(
            testCase["x"],
            testCase["dof"],
            true,
            testCase["ncp"]
          );
          let doa = digitsOfAgreement(testCase["p"], testValue);

          doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
        }
      );

      it(
        "should match high accuracy estimates for cdf in upper tail -- small ncp",
        function (){
          let testValue = t.cdf(
            testCase["x"],
            testCase["dof"],
            false,
            testCase["ncp"]
          );
          let doa = digitsOfAgreement(testCase["q"], testValue);

          doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
        }
      );

      if (testCase["p"]  < 0.99 && testCase["p"] !== 0) {
        it (
          "should match high accuracy estimates for quantile in lower tail -- small ncp",
          function(){
            let testValue = t.quantile(
              testCase["p"],
              testCase["dof"],
              true,
              testCase["ncp"],
            );

            let doa = digitsOfAgreement(testCase["x"], testValue);

            doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
          }
        );
      }

      if (testCase["q"]  < 0.99 && testCase["q"] !== 0) {
        it (
          "should match high accuracy estimates for quantile in upper tail -- small ncp",
          function(){
            let testValue = t.quantile(
              testCase["q"],
              testCase["dof"],
              false,
              testCase["ncp"],
            );

            let doa = digitsOfAgreement(testCase["x"], testValue);

            doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
          }
        );
      }
    }

    // for (let testCase of testCasesBig) {
    //   if (testCase["p"] < 1e-284 || testCase["q"] < 1e-203) {
    //     continue;     // TODO: hopefully we can remove these restrictions someday
    //   }
    //
    //   it("should match high accuracy estimates for cdf in lower tail with extreme values",
    //     function (){
    //       let testValue = chi2.cdf(
    //         testCase["x"],
    //         testCase["dof"],
    //         true,
    //         testCase["ncp"]
    //       );
    //       let doa = digitsOfAgreement(testCase["p"], testValue);
    //
    //       doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
    //     });
    //
    //   it("should match high accuracy estimates for cdf in upper tail with extreme values",
    //     function (){
    //       let testValue = chi2.cdf(
    //         testCase["x"],
    //         testCase["dof"],
    //         false,
    //         testCase["ncp"]
    //       );
    //       let doa = digitsOfAgreement(testCase["q"], testValue);
    //
    //       doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
    //     });
    //   caseNum++;
    //
    //   if (testCase["p"]  < 0.99 && testCase["p"] !== 0) {
    //     it ("should match high accuracy estimates for quantile in lower tail with extreme values",
    //       function(){
    //         let testValue = chi2.quantile(
    //           testCase["p"],
    //           testCase["dof"],
    //           true,
    //           testCase["ncp"],
    //         );
    //
    //         let doa = digitsOfAgreement(testCase["x"], testValue);
    //
    //         doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
    //       });
    //   }
    //
    //   if (testCase["q"]  < 0.99 && testCase["q"] !== 0) {
    //     it ("should match high accuracy estimates for quantile in upper tail with extreme values",
    //       function(){
    //         let testValue = chi2.quantile(
    //           testCase["q"],
    //           testCase["dof"],
    //           false,
    //           testCase["ncp"],
    //         );
    //
    //         let doa = digitsOfAgreement(testCase["x"], testValue);
    //
    //         doa.should.be.greaterThan(DIGIT_AGREE_TOLERANCE);
    //       });
    //   }
    // }
  });
});
